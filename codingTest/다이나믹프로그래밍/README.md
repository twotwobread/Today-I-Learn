# LIS (Longest Increasing Subsequence), 최장 증가 부분 수열
- Dynamic Programming 문제로 자주 나오는 유형이며, O(N^2)의 시간복잡도를 가진 알리즘과 O(NlogN)의 시간복잡도를 갖는 알고리즘 존재
- 개념 : 단어 그대로 가장 긴 증가하는 부분 수열을 구하는 것.
  + 어떠한 수열이 주어질 때, 그 수열에서 일부 원소를 뽑아내어 새로 만든 수열을 '부분 수열'
  + 이 수열이 오름차순을 유지하면 '증가하는 부분 수열'
  + 그러므로 어떤 수열에서 만들 수 있는 부분 수열 중 가장 길면서 오름차순을 유지하는 수열이 LIS
- O(N^2)의 시간 복잡도를 가지는 알고리즘
  1. 수열의 길이와 같은 dp 배열을 하나 선언.
  2. 수열을 처음부터 끝까지 순서대로 1개씩 탐색 (현재 위치 = i)
    1. dp[i]에 넣을 값을 초기화 ( val )
    2. 현재 위치(i)보다 이전에 있는 원소(j) 중에서 현재 원소보다 작은지 체크.(크거나 같으면 LIS 불가능)
    3. 현재 원소보다 작으면, dp[j]가 val보다 큰지 체크.
      - 이때, val보다 크다면 j번째 원소를 포함했을 떄가, 지금까지 확인한 최장 증가 부분 수열보다 더 길다는 의미이므로 val에 dp[j]를 할당.
    4. 현재 원소도 포함해주어야 해서 dp[i]에 val+1을 할당.
  3. dp 배열의 원소 중 가장 큰 값을 출력.
- O(NlogN)의 시간복잡도 알고리즘, 길이만 구하기
  + 위의 알고리즘은 배열의 원소를 하나씩 탐색하면서, 그 이전의 원소들을 모두 탐색하여 오래걸림.
  + 이전의 원소들을 탐색하는 과정( O(N) )을 lower bound( O(logN) )을 이용하여 줄여주는 것.
  + 핵심 아이디어 : LIS를 만들기 위해서는 만드는 과정에서 LIS의 마지막 원소가 가능한 작을수록 더 긴 LIS를 생성할 수 있다는 것.
    - 그러므로 원소가 들어올 때, 만약 현재 생성된 LIS의 마지막 원소보다 작은 경우, LIS에 들어갈 위치를 찾아( O(logN) ) 대체.
  + ex) [1,2,3,7,5,6] -> 5까지 탐색을 한 경우 가능한 LIS는 [1,2,3,7], [1,2,3,5] 두 가지가 만들어짐.
  + 최장 길이를 가지기만 하면 되니까 둘 다 LIS를 만족하지만, 더 긴 LIS를 만들기 위해선 [1,2,3,5]가 적합.
  + 6이 들어오면 전자는 생성 불가하지만 후자는 가능.
  + [1] -> [1,2] (2>1) -> [1,2,3] (3>2) -> [1,2,3,7] (7>3) -> [1,2,3,5] (5<7 5가 들어갈 위치 찾기 후 대체) -> [1,2,3,4,5,6] (6>5)
  + 해당 알고리즘을 이용하면 항상 LIS가 만들어지는 것 같지만 실제로는 길이만 구할 수 있게 됨.
  + [3,5,2,6,1] -> 만들어 질 수 없는 부분 수열인 [1,5,6]이 답이 됨.
  + so, 단순히 길이를 구하는 목적이라면 답에 영향을 주지 않음.
  + 실제 LIS를 이루는 부분 수열을 구하기 위해서는 추가적인 작업이 필요
- O(NlogN)의 시간복잡도 알고리즘, 길이와 수열 모두 구하기
  + 위 알고리즘에서 주어진 수열의 각각의 원소들이 배열에 들어가는 index를 배열로 별도 저장.
  + 그리고 마지막 원소부터 LIS의 길이를 감소시켜 가면서, 처음으로 해당 길이의 index가 나오는 원소만 뽑아냄.
  + ex) [3,5,2,6,1]
    1. K=[3]
    2. K=[3,5]
    3. K=[2,5]
    4. K=[2,5,6]
    5. K=[1,5,6]
    - 3은 1번째, 5는 2번째, 2는 1번째, 6은 3번째, 1은 1번째 -> [(3,1),(5,2),(2,1),(6,3),(1,1)]이 됨.
    - LIS의 현재 길이는 3 -> index 배열의 뒤에서부터 처음으로 3이 나오는 원소는 6.
    - 그 다음 처음으로 2가 나오는 원소는 5, 그 다음 처음으로 1이 나오는 원소는 3 
    - 이를 역으로 정렬하면 [3,5,6]
# LCS (Longest Common Substring or Subsequence, 최장 공통 부분수열 혹은 문자열)
- 최장 공통 부분수열과 최장 공통 문자열은 차이 존재.
  + ex) ABCDEF, GBCDFE를 봤을 때, 부분수열 : BCDF or BCDE, 문자열 : BCD -> 문자열은 한번에 이어져있는 문자열만 가능
- 최장 공통 문자열 알고리즘.
  + 해당 과정이 부분수열에 비해 쉽고 부분수열에서 사용되기에 먼저 알아보자.
  1. 문자열 A, 문자열 B를 한글자씩 비교
  2. 두 문자가 다르다면 LCS[i][j]에 0을 표시 (마진값)
  3. 두 문자가 같다면 LCS[i][j] = LCS[i-1][j-1]+1
  4. 위 과정 반복
  5. 최대 값을 찾고 값을 처리.
  + 위 과정이 성립하는 이유 : 고통 문자열은 연속되야 하기 때문.
  + 현재 두 문자가 같을때 두문자의 앞 글자까지가 공통 문자열이라면 계속 공통 문자열이 이어질 것이고, 아니라면 자기자신부터 다시 공통 문자열을 만들어 갈것.
- 최장 공통 부분수열 알고리즘, 길이 구하기.
  + 위와 마찬가지로 2차원 배열에 매칭하고 마진값을 설정한 후 검사.
  1. 문자열 A, 문자열 B의 한 글자씩 비교.
  2. 두 문자가 다르다면 LCS[i][j] = max(LCS[i-1][j], LCS[i][j-1])
    - LCS[i-1][j], LCS[i][j-1]의 의미 -> 부분수열은 같지 않아도 이전 값이 유지되어야 함.
    - '현재의 문자를 비교하는 과정' 이전의 과정을 의미.
    - ex) AB, GBC -> LCS : B를 알기 위해 A, GBC 비교과정, AB, GB 비교과정이 필요.
    - AB, GB의 비교과정에서 최대 공통 부분수열이 B임을 확인했기에 문자열 AB, GBC의 LCS = B가 됨.
    - AB, GBC의 LSC = max(A,GBC의 LSC, AB,GB의 LSC)
    - A, ABC를 생각한다면 A가 일치하는 인덱스부터 끝까지 1로 채워졌을 것이다.
    - AB, AB를 보면 B 인덱스부터 2가 채워졌을 것 이고, 1과 비교해서 더 큰 2로 쭉 채워나가야 부분수열의 크기가 2인 것으로 채워나갈 수 있음.
  3. 두 문자가 같다면 LSC[i][j] = LCS[i-1][j-1]+1.
    - 문자열 알고리즘과 같은 과정을 거침.
    - 왜 같을까 -> 부분수열이 연속될 필요가 없음을 위 과정에서 여러번 보았음.
    - 그리고 2번에서 봤듯이 같은 인덱스부터 끝까지 해당 값을 채워줌. 그게 다른 행에도 쭉 적용되고
    - 최대값으로 갱신해 나감 -> 그래서 지금까지의 최대 공통 부분수열이 LCS[i-1][j-1]이라고 볼 수 있음.
  4. 위 과정을 반복.
  5. 최대 값을 찾으면 길이를 구할 수 있음.
  + 문자열과 다른 부분은 비교하는 두 문자가 다를 때임.
  + 비교하는 두 문자가 같을 때는 같은 과정을 이용.
- 최장 공통 부분수열 알고리즘, 부분수열 찾기.
  1. LCS 배열의 가장 마지막 값에서 시작.
  2. LCS[i-1][j]와 LCS[i][j-1] 중 현재 값과 같은 값을 찾음.
    2-1. 같은 값이 있으면 해당 값으로 이동.
    2-2. 같은 값이 없으면 result 배열에 해당 문자를 넣고 LCS[i-1][j-1]로 이동.
  3. 2번 과정 반복 -> 0으로 이동 시 종료. result의 역순이 LCS.

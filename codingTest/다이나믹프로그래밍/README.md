# LIS (Longest Increasing Subsequence), 최장 증가 부분 수열
- Dynamic Programming 문제로 자주 나오는 유형이며, O(N^2)의 시간복잡도를 가진 알리즘과 O(NlogN)의 시간복잡도를 갖는 알고리즘 존재
- 개념 : 단어 그대로 가장 긴 증가하는 부분 수열을 구하는 것.
  + 어떠한 수열이 주어질 때, 그 수열에서 일부 원소를 뽑아내어 새로 만든 수열을 '부분 수열'
  + 이 수열이 오름차순을 유지하면 '증가하는 부분 수열'
  + 그러므로 어떤 수열에서 만들 수 있는 부분 수열 중 가장 길면서 오름차순을 유지하는 수열이 LIS
- O(N^2)의 시간 복잡도를 가지는 알고리즘
  1. 수열의 길이와 같은 dp 배열을 하나 선언.
  2. 수열을 처음부터 끝까지 순서대로 1개씩 탐색 (현재 위치 = i)
    1. dp[i]에 넣을 값을 초기화 ( val )
    2. 현재 위치(i)보다 이전에 있는 원소(j) 중에서 현재 원소보다 작은지 체크.(크거나 같으면 LIS 불가능)
    3. 현재 원소보다 작으면, dp[j]가 val보다 큰지 체크.
      - 이때, val보다 크다면 j번째 원소를 포함했을 떄가, 지금까지 확인한 최장 증가 부분 수열보다 더 길다는 의미이므로 val에 dp[j]를 할당.
    4. 현재 원소도 포함해주어야 해서 dp[i]에 val+1을 할당.
  3. dp 배열의 원소 중 가장 큰 값을 출력.
- O(NlogN)의 시간복잡도 알고리즘, 길이만 구하기
  + 위의 알고리즘은 배열의 원소를 하나씩 탐색하면서, 그 이전의 원소들을 모두 탐색하여 오래걸림.
  + 이전의 원소들을 탐색하는 과정( O(N) )을 lower bound( O(logN) )을 이용하여 줄여주는 것.
  + 핵심 아이디어 : LIS를 만들기 위해서는 만드는 과정에서 LIS의 마지막 원소가 가능한 작을수록 더 긴 LIS를 생성할 수 있다는 것.
    - 그러므로 원소가 들어올 때, 만약 현재 생성된 LIS의 마지막 원소보다 작은 경우, LIS에 들어갈 위치를 찾아( O(logN) ) 대체.
  + ex) [1,2,3,7,5,6] -> 5까지 탐색을 한 경우 가능한 LIS는 [1,2,3,7], [1,2,3,5] 두 가지가 만들어짐.
  + 최장 길이를 가지기만 하면 되니까 둘 다 LIS를 만족하지만, 더 긴 LIS를 만들기 위해선 [1,2,3,5]가 적합.
  + 6이 들어오면 전자는 생성 불가하지만 후자는 가능.
  + [1] -> [1,2] (2>1) -> [1,2,3] (3>2) -> [1,2,3,7] (7>3) -> [1,2,3,5] (5<7 5가 들어갈 위치 찾기 후 대체) -> [1,2,3,4,5,6] (6>5)
  + 해당 알고리즘을 이용하면 항상 LIS가 만들어지는 것 같지만 실제로는 길이만 구할 수 있게 됨.
  + [3,5,2,6,1] -> 만들어 질 수 없는 부분 수열인 [1,5,6]이 답이 됨.
  + so, 단순히 길이를 구하는 목적이라면 답에 영향을 주지 않음.
  + 실제 LIS를 이루는 부분 수열을 구하기 위해서는 추가적인 작업이 필요
- O(NlogN)의 시간복잡도 알고리즘, 길이와 수열 모두 구하기
  + 위 알고리즘에서 주어진 수열의 각각의 원소들이 배열에 들어가는 index를 배열로 별도 저장.
  + 그리고 마지막 원소부터 LIS의 길이를 감소시켜 가면서, 처음으로 해당 길이의 index가 나오는 원소만 뽑아냄.
  + ex) [3,5,2,6,1]
    1. K=[3]
    2. K=[3,5]
    3. K=[2,5]
    4. K=[2,5,6]
    5. K=[1,5,6]
    - 3은 1번째, 5는 2번째, 2는 1번째, 6은 3번째, 1은 1번째 -> [(3,1),(5,2),(2,1),(6,3),(1,1)]이 됨.
    - LIS의 현재 길이는 3 -> index 배열의 뒤에서부터 처음으로 3이 나오는 원소는 6.
    - 그 다음 처음으로 2가 나오는 원소는 5, 그 다음 처음으로 1이 나오는 원소는 3 
    - 이를 역으로 정렬하면 [3,5,6]

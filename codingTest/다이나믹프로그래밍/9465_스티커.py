# 2행 n열인 스티커를 구매했다. 하나의 스티커를 떼면 상하좌우 인접한 스티커들이 찢어져 쓰지 못하게 된다.
# 스티커 하나마다의 점수가 존재하고 이 점수가 최대값이 되는 경우는?
# 이 문제는 가능한 모든 경우의 수를 구해서 그중 가장 높은 점수인 조합을 구하면 된다.
# 하지만, 조합의 시간복잡도는 O(2^N)이고 여기서 주어진 N의 최대값은 100,000이다. 인접한 스티커는 선택하지 못한다는 조건이 붙어도 N의 값이 너무 커서 원하는 시간 내에 수행하지 못한다.
# 이럴 떄, 시간을 줄이기 위해서 중복되는 연산을 저장된 이전 연산의 결과를 이용해서 줄여주는 알고리즘인 DP를 이용하는 것이 좋을 것 같다.
# 바텀업을 이용해서 풀기 위해선 작은 단위의 연산을 생각하고 큰 단위의 연산으로 올라가야한다. seed에 해당할 수 있는 작은 단위의 연산을 생각해보자.
# 만약, 2x1의 스티커다 하면 최대값은 얼마일까? 50이다. 둘 중 가장 높은 값을 쓰면된다.
# dp 테이블은 2x(N+1)의 크기로 생성할 것이고 0으로 초기화할 예정이다. seed값에 해당하는 맨처음 스티커들의 값을 삽입하고
# 그 다음 인덱스부터 각 열에 맞는 이전 인덱스의 값과 해당 인덱스에서 대각에 존재하는 이전 인덱스랑 현재 스티커의 가치를 더한 값과 2칸 전에 존재하는 인덱스 중 max값과 현재 스티커의 값을
# 더한 값 중 최대값을 현재 인덱스에 넣을 것이다.

if __name__ == "__main__":
    T = int(input())
    for _ in range(T):
        N = int(input())
        dp = [[0]*(N+1) for _ in range(2)]
        stickers = [list(map(int, input().split())) for _ in range(2)]
        dp[0][1], dp[1][1] = stickers[0][0], stickers[1][0] # seed 값
        for i in range(2, N+1):
            dp[0][i] = max(dp[0][i-1], dp[1][i-1] + stickers[0][i-1], max(dp[0][i-2], dp[1][i-2]) + stickers[0][i-1])
            dp[1][i] = max(dp[1][i-1], dp[0][i-1] + stickers[1][i-1], max(dp[0][i-2], dp[1][i-2]) + stickers[1][i-1])
        print(max(dp[0][N], dp[1][N]))


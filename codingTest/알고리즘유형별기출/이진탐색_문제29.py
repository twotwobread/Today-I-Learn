# file name : 이진탐색_문제29.py
# 공유기 설치
# 집 N개가 수직선 위에 있습니다. 각각의 집의 좌표는 x1,x2,....,xn이고, 집 여러 개가 같은 좌표를 가지지 않는다.
# 공유기 C개를 설치하려 한다. 최대한 많은 곳에서 와이파이를 사용하려 하기에 한 집에는 하나만 설치가 가능하고
# 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.
# C개의 공유기를 N개의 집에 적당히 설치하여, 가장 인접한 두 공유기 가이의 거리를 최대로 하는 프로그램을 작성하라.
# 2 <= N <= 200,000 ( 집의 개수 ), 2 <= C <= N ( 공유기의 개수 )
# 1 <= xi <= 1,000,000,000
# author : Lee Suyoung (2022-02-10)

# 범위를 딱 봤을때 무조건 이진탐색이다. 노드의 개수도 너무 많고 값의 범위도 굉장히 크다.
# 이거 느낌이 살짝 온게 떡볶이 풀 듯이 풀면 될꺼 같은데
# 일단 전체 모든 노드의 사이를 벌릴 수 있을 만큼 벌려야하는 거 같은데 그럴려면 두개를 끝이랑 끝에 배치하고 그 다음에 
# 거기에 중간에 아 근데 이러면 또 아닌거 같은데 
# 짝수일때랑 홀수 일때를 나눠야 할꺼 같음.
# 짝수일때는 맨끝 두개 두고 처음과 정중앙의 중앙, 끝과 정중앙의 중앙 이런 식
# 홀수일때는 맨끝 두개 두고 처음과 끝의 중앙에 배열
# 이것도 최대 값을 구해야 하기때문에 값을 저장하는 부분이 필요

# 답지를 봐버렸다. 이 문제는 내가 문제의 키포인트를 제대로 못잡는 것 같았다.
# 떡볶이 문제를 풀듯이 파라메트릭 서치 유형이다라는 것은 알았는데 
# 떡볶이 문제에서는 썬 떡의 총 길이의 합이라는 비교하는 값이 있다라고 느꼈는데
# 이 문제는 무엇을 비교를 해야하나에서 막힌 것 같다.
# 가장 인접한 두 공유기 사이의 거리를 비교를 해야하는데 그럼 공유기가 있는 노드들을 다 비교하면서 최소의 값을 계속 찾아야하나
# 이런 생각을 했는데 너무 시간이 오래걸릴 것 같아서 포기했다.
# 알고 보니까 간단하게 생각을 했어야했다. 그냥 인접한 노드의 최대 거리차부터 줄여가면서 해당 거리차에서 공유기를 몇개 설치할
# 수 있는지를 생각하면 된다. 최대 인접한 노드의 거리가 8의 차이가 가능하니까 그것부터 생각하면 8의 차이에서는 최대 공유기를 
# 2개밖에 설치를 못하고 이것은 갭이 줄어들어야 하니까. 중간 값인 4와 밑으로 리스트 해서 1-3의 범위에서 중간은 2인데 
# 이것은 공유기 3개 이상이다. 근데 더 갭이 커졌을 때도 가능할 수 있기 때문에 확인해야한다.범위를 3-3으로 수정을 하고 보면 
# 이 경우도 공유기 3개를 설치할 수 있다. 그래서 갭이 3일때가 최적의 경우이다.

import sys
input = sys.stdin.readline
# n, c 입력
n, c = map(int, input().split())
# home 정보 입력
home=[]
for i in range(n):
    home.append(int(input()))
home.sort()

start = home[1] - home[0] # 최저 노드에서 최소 갭
end = home[-1] - home[0] # 최저 노드에서 최대 갭
result = 0

while(start<=end):
    mid = (end+start)//2 # 현재 설정한 기준 갭
    value = home[0] # 일단 맨 처음 노드에는 와이파이를 설치
    count = 1 # 첫 노드에 와이파이를 설치해서 1부터 시작
    # 현재 mid값을 이용하여 공유기를 설치
    for i in range(1, n):
        if home[i] >= value + mid: # 설정된 value = 첫 노드 이미 와이파이 설치했으니까 여기서 기준 갭만큼 떨어진노드를 찾음.
            value = home[i] # 거기에도 와이파이 설치
            count += 1 # 와이파이 개수 증가
    if count < c: # c의 갯수 만큼 설치못했으니까 갭을 줄이자
        end = mid - 1
    else: # c의 개수 이상 설치했음. 가장 인접한 노드의 최대 거리이기 때문에 이렇게 하는 겨.
        start = mid + 1
        result = mid # 최적의 해
print(result)

# 가장 인접한 노드를 찾으려고 하는게 아니라 
# 하나의 기준을 정하고 그 노드를 가장 인접한 노드로 만들어 가면서 푼다.
# 이런 생각을 배워야 한다.
# 2022-02-11에 이 문제랑 떡볶이 문제 풀어볼 것

# 알고리즘 유형 공부
## 당장 좋은 것만 선택하는 '그리디'
- 그리디 알고리즘은 단순하지만 강력한 문제 해결 방법이다. 어떠한 문제가 있을 때 단순 무식하게, 탐욕적으로 문제를 푸는 알고리즘이다.
- 여기서 탐욕적이라는 말은 '현재 상황에서 지금 당장 좋은 것만 고르는 방법'을 의미한다.
- 매 순간 가장 좋아보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.
- 보통 코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.
- 특정한 문제를 만났을 때 단순히 현재 상황에서 가장 좋아 보이는 것만을 선택해도 문제를 풀 수 있는지를 파악할 수 있어야 한다.
- 그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준을 알게 모르게 제시해준다. 대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 그리디 알고리즘 문제는 자주 정렬 알고리즘과 짝을 이훠 출제된다.
- 대부분의 그리디 알고리즘 문제에서는 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다.

ex) 거스름돈 문제에서는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이기에 작은 단위의 동전들을 종합해 다른 해가 나올 수 없다. 그래서 이 아이디어가 정당하다고 판단할 수 있다. -> 만약 단위가 배수가 아니라면? 그리디로 해결할 수 없다!!! 이 경우 다이나믹 프로그래밍으로 해결해야 한다.

어떤 코딩 문제를 만났을 때 바로 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하고, 문제를 해결할 수 있는 탐욕적 해결법이 존재하는지 고민해보자.
만약 오랜 시간을 고민해도 그리디로 해결 방법을 찾을 수 없다면, 그때 다이나믹 프로그래밍이나 그래프 알고리즘 등으로 문제를 해결할 수 있는지를 재차 고민해보는 것도 한 방법이다.

## 아이디어를 코드로 바꾸는 '구현'
- 코딩 테스트에서 구현이란 '머릿속에 있는 알고리즘을소스코드로 바꾸는 과정'이다.
- 어떤 문제를 풀든 간에 소스코드를 작성하는 과정은 필수이므로 구현 문제 유형은 모든 범위의 코딩 테스트 문제 유형을 포함하는 개념이다.
- 문제 해결과정은 문제 인식 -> 생각 -> 풀이 방법 발견 -> __코드로 옮기기__
- 코드로 옮기지 못하면 말짱 도로묵이다. 구현 유형의 문제는 '풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제'를 의미한다.
- 구현하기 어려운 문제는 알고리즘은 간단한데 코드가 지나치게 길어지는 문제, 특정 소수점 자리까지 출력해야 하는 문제, 파싱을 해야 하는 문제 등이 있다.
- 구현 문제를 풀 땐 언어 문법을 정확하게 숙지하지 못햇거나, 라이브러리 사용 경험이 부족하면 불리하다.
- 완전 탐색, 시뮬레이션 유형 모두 '구현' 유형으로 묶어서 보자 완전 탐색은 모든 경우 수 다 계산하는 해결방법이고 시뮬레이션은 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야 하는 문제 유형이다.
- 둘 다 구현이 핵심이 되는 경우가 많다.
< 언어에서의 제약 사항 >
### < 언어에서의 제약 사항 > ###
- 파이썬에서의 실수형 변수는 다른 언어와 마찬가지로 유효숫자에 따라서 연산 결과가 원하는 값이 나오지 않을 수 있다
#### 파이썬에서 리스트 크기
- 파이썬에서 리스트 이용 시 고려할 점은 코딩 테스트의 메모리 제한이다. 대체로 128~512MB로 메모리를 제한한다.
- int 자료형의 데이터 개수에 따른 메모리 사용량을 확인해보자. (시스템 내부적으로 다음 표에서 보여주는 것과 유사한 크기만큼 메모리를 차지한다.
| 데이터의 개수(리스트의 길이) | 메모리 사용량 |
| :---: | :---: |
| 1,000 | 약 4KB |
| 1,000,000 | 약 4MB |
| 10,000,000 | 약 40MB |

- 파이썬은 다른 언어에 비해서 구현상의 복잡함이 적은 편이지만 데이터 처리량이 많을 때는 꼭 메모리 제한을 고려하도록 해야한다.
- 크기가 1,000만 이상인 리스트가 있다면 메모리 용량 제한으로 문제를 풀 수 없게 되는 경우도 있다.
- 하지만 이런 문제 또한 드물다. 이 정도 크기면 입출력에 너무 많은 시간이 소요되며 채점 환경에서도 문제가 발생할 수 있기 때문이다.
- 따라서 일반적인 코딩 테스트 수준에서는 메모리 사용량 제한보다 더 적은 메모리를 사용해야 한다는 점 정도만 기억하면 된다.
#### 채점 환경
- 보통 코딩 테스트 환경에서는 채점 시스템의 시간 제한 및 메모리 제한 정보가 적혀있다.
 + 시간 제한: 1초
 + 메모리 제한: 128MB
- 일반적으로 코딩테스트 환경에서 1초에 2,000만 번의 연산을 수행한다고 생각하고 푸는 것이 무리가 없다.
- N = 1,000,000일 때, Nlog2 N은 약 20,000,000이다. 그니까 O(NlogN) 이내의 알고리즘으로 문제를 풀어야한다. 100만 개일때

#### 구현 문제에 접근하는 방법
- 고차원적인 사고력을 요구하는문제는 나오지 않는 편이기에 문법에 익숙하다면 오히려 쉽게 풀 수 있다.
- API 개발 문제 또한 구현 유형과 상당히 맞닿아 있다. ex) 카카오 문제 풀이 서버와 통신하는 프로그램 모듈을 작성해라 이는 알고리즘 문제와 별개로 웹 서버나 데이터 분석에 대한 기초지식도 필요하다. 이런 기능을 구현해야 할때 , C++나 자바에 비해 파이썬은 매우 간결하고 직관적인 코드의 라이브러리를 사용할 수 있어 더 유리하다.


## [번외] 꼭 필요한 자료구조 기초
- 탐색 : 많은 양의 데이터 중에서 원하는 데이터를 차즌 과정
  + 대표적인 탐색 알고리즘 : DFS, BFS

- 자료구조 : 데이터를 표현하고 관리하고 처리하기 위한 구조
  + 스택과 큐는 자료구조의 기초 개념으로 다음의 두 핵심적인 함수로 구성된다.
    * 삽입(Push): 데이터를 삽입한다
    * 삭제(Pop): 데이터를 삭제한다.
  + 물론 실제로는 오버플로, 언더플로를 고민해야 한다.

### 스택
- 스택 : 선입후출(FILO) 구조 or 후입선출(LIFO) 구조
- 파이썬에서 스택은 list와 같다.

### 큐
- 큐 : 선입선출(FIFO) 구조
- 파이썬에서 collections 모듈에서 제공하는 deque 자료구조를 활용하자.

### 재귀 함수
- 재귀 함수 : 자기 자신을 다시 호출하는 함수
- 보통 파이썬 인터프리터는 호출 횟수 제한이 있다. 따라서 무한대로 재귀 호출을 진행할 수는 없다.
- 종료 조건을 무조건 명시해야 한다. 
- 컴퓨터 내부에서 재귀 함수의 수행은 스택자료구조를 이용한다. 함수를 계속 호출했을 때 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 때문이다.
- 따라서 스택 자료구조를 활용해야 하는 상당수 알고리즘은 재귀 함수를 이용해서 간편하게 구현될 수 있다. DFS가 대표적이다.
- 재귀 함수를 이용하면 코드가 간결해진다. 수학의 점화식(재귀식)을 그대로 코드로 옮겼기 때문이다.
- 재귀 함수는 반복문을 이용하는 것과 비교했을 때 더욱 간결한 형태이다.

## 탐색 알고리즘 'DFS/BFS'
### DFS
- Depth-First Search, 깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다. 즉, 최대한 멀리 있는 노드를 우선으로 탐색
- 먼저 그래프의 기본 구조에 대해 알아보자.
  + 그래프는 노드와 간선으로 표현되며 이때 노드를 정점이라고도 말한다.
  + 또한 두 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다(Adjacent)'라고 표현한다.
  + 프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있는데 코테에서는 이 두 방식 모두 필요하니 두 개념에 대해 바르게 알고 있도록 하자.
    * 인접 행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
      - 연결된 그래프를 인접 행렬로 표현할 때 파이썬에서는 2차원 리스트로 구현할 수 있다.
      - 연결되어 있지 않으면 무한(INF)의 비용이라고 작성한다.
    * 인접 리스트(Adjacency List) : 리스트로 그래프의 연결 관계를 표현하는 방식
      - 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다. (연결 리스트 방식)
      - C++, Java는 연결 리스트 기능을 위한 표준 라이브러리를 제공하지만 파이썬은 리스트를 이용하면 된다. 인접 리스트를 이용해 그래프를 표현하고자 할 때에도 단순히 2차원 리스트를 이용하면 된다는 점을 기억하자.
      - graph[0].append((1, 7)) # 노드0에 연결된 (노드, 거리) 노드 1이 연결되어 거리 7의 edge를 가지고 있다는 의미
    * 그렇다면 위 두 방식은 어떤 차이가 있을까?
    * 메모리와 속도 측면에서 살펴보겠다.
    * 메모리 측면에서는 모든 관계를 저장하는 인접 행렬 방식이 불리하다.
    * 속도 측면에서는 인접 리스트 방식은 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻기 위해선 연결된 데이터를 하나씩 확인해야 하기 때문에 느리다.
- DFS의 구체적인 동작
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
  2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 거낸다.
  3. 위 과정을 반복한다.
- 데이터의 개수가 N개인 경우 O(N)의 시간이 소요된다는 특징이 있다.

### BFS
- Breadth First Search, 너비 우선 탐색이라는 의미를 가진다. 가까운 노드부터 탐색하는 알고리즘이다.
- 선입선출 방식인 큐 자료구조를 이용하는 것이 정석이다.
- BFS의 구체적인 동작
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
  2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
  3. 위 과정을 반복한다.
- 탐색을 수행함에 있어 O(N)의 시간이 소요된다.
- 일반적인 경우 실제 수행 시간은 DFS보다 좋은 편이라는 점까지만 추가로 기억하자.

## 기준에 따라 데이터를 '정렬'
### 정렬 알고리즘 개요
- 정렬 : 데이터를 득정한 기준에 따라서 순서대로 나열하는 것
- 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬을 알아볼 것이다.
- 컴퓨터는 사람과 다르게 데이터의 규칙성을 직관적으로 알 수 없기에 어떻게 정렬을 수행할 것인지에 대해 구체적으로 명시해야한다.
### 선택정렬
- 가장 원시적인 방법으로 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복
- 매번 가장 작은 것을 선택한다는 의미
- 시간 복잡도는 간단히 O(N^2)이다.

### 삽입정렬
- 데이터를 하나씩 환인하며, 각 데이터를 적절한 위치에 삽입하는 동작을 이용
- 구현 난이도는 높지만 실생 시간 측면에서 선택정렬에 비해 효율적
- 데이터가 거의 정렬되어 있을때 훨씬 효율적이다.
- 선택정렬은 모든 훤소를 비교하고 위치를 바꾸는 반면 삽입 정렬은 그렇지 않다.
- 삽입정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에 , 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.
- 정렬이 되면 항상 오름차순을 유지한다.
- 시간 복잡도는 O(N^2)이고 선택 정렬과 마찬가지로 2개의 반복문이 중첩되었다.
- 보통은 비효율적이나 거의 정렬이 되어있는경우 퀵 정렬보다 더 강력하다.

### 퀵 정렬
- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면 어떨까??
- 호어 분할 방식은 가장 첫 번째 데이터를 피벗으로 정한다.
- 시간 복잡도는 O(NlogN)이다. 앞에서 봤던 두 정렬에 비해 매우 빠른 편이다.
- 이미 데이터가 정렬되어 있는 경우에 매우 느리게 동작한다.

### 계수 정렬
- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
- 데이터의 개수 N, 데이터 중 최댓값이 K -> 계수 정렬은 최악의 경우에도 O(N + K)를 만족한다.
- 데이터의 크기범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용한다. 
- 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.
- 예를 들어 0 이상 100 이하인 성적 데이터를 정렬할 때 계수 정렬이 효과적이다. 다만, 가장 큰 데이터와 가장 작은 데이터의 차이가 너무 크다면 계수 정렬은 사용할 수 없다. 계수 정렬이 이러한 특징을 가지는 이유는 계수 정렬을 이용할 때는 모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언해야 하기 때문이다.
- 예를 들어 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000이라면 총 1,000,001가 들어갈 수 있는 리스트를 초기화해야 한다. 여기서 1개를 더해주는 이유는 0부터 1,000,000까지는 총 1,000,001개의 수가 존재하기 때문이다.
- 계수 정렬은 앞서 다루었던 3가지 정렬 알고리즘처럼 비교 기반의 정렬 알고리즘이 아니다.
- 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.
- 시간복잡도는 O(N+K)이다. 데이터 범위만 한정되어있다면 항상 빠르게 동작한다. 
- 사실상 현존하는 정렬 알고리즘 중에서 기수 정렬과 더불어 가장 빠르다고 볼 수 있다.
- 기수정렬은 계수정렬에 비해 느리지만 처리할 수 있는 정수의 크기는 더 크다. 다행히 기수 정렬을 이용해야만 해결할 수 있는 코테는 거의 출제되지 않는다.
- 공간 복잡도는 개구데기다. 하나의 수에만 몰리는 경우 쓰잘데기 없이 메모리를 차지한다.

### 파이썬의 정렬 라이브러리
- sorted() 병합 정렬을 기반으로 만들어짐.
- sort(), sorted() 둘다 키 매개변수를 입력으로 받을 수 있다.
- 정렬 기준을 설정할 수 있다.

### 정렬 라이브러리의 시간 복잡도
- 최악의 경우에도 O(NlogN)을 보장한다.
- 별도의 요구없이 단순히 정렬을 해야한다면 라이브러리 쓰는게 최고다. 데이터가 한정되어 있다면 계수 정렬을 쓰자
1. 정렬 라이브러리로 풀 수 있는 문제 : 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용 방법을 숙지하고 있으면 어렵지 않게 풀 수 있다.
2. 정렬 알고리즘의 원리에 대해서 물어보는 문제 : 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다.
3. 더 빠른 정렬이 필요한 문제 : 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.


















# 알고리즘 유형 공부
## 당장 좋은 것만 선택하는 '그리디'
- 그리디 알고리즘은 단순하지만 강력한 문제 해결 방법이다. 어떠한 문제가 있을 때 단순 무식하게, 탐욕적으로 문제를 푸는 알고리즘이다.
- 여기서 탐욕적이라는 말은 '현재 상황에서 지금 당장 좋은 것만 고르는 방법'을 의미한다.
- 매 순간 가장 좋아보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.
- 보통 코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.
- 특정한 문제를 만났을 때 단순히 현재 상황에서 가장 좋아 보이는 것만을 선택해도 문제를 풀 수 있는지를 파악할 수 있어야 한다.
- 그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준을 알게 모르게 제시해준다. 대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 그리디 알고리즘 문제는 자주 정렬 알고리즘과 짝을 이훠 출제된다.
- 대부분의 그리디 알고리즘 문제에서는 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다.

ex) 거스름돈 문제에서는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이기에 작은 단위의 동전들을 종합해 다른 해가 나올 수 없다. 그래서 이 아이디어가 정당하다고 판단할 수 있다. -> 만약 단위가 배수가 아니라면? 그리디로 해결할 수 없다!!! 이 경우 다이나믹 프로그래밍으로 해결해야 한다.

어떤 코딩 문제를 만났을 때 바로 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하고, 문제를 해결할 수 있는 탐욕적 해결법이 존재하는지 고민해보자.
만약 오랜 시간을 고민해도 그리디로 해결 방법을 찾을 수 없다면, 그때 다이나믹 프로그래밍이나 그래프 알고리즘 등으로 문제를 해결할 수 있는지를 재차 고민해보는 것도 한 방법이다.

## 아이디어를 코드로 바꾸는 '구현'
- 코딩 테스트에서 구현이란 '머릿속에 있는 알고리즘을소스코드로 바꾸는 과정'이다.
- 어떤 문제를 풀든 간에 소스코드를 작성하는 과정은 필수이므로 구현 문제 유형은 모든 범위의 코딩 테스트 문제 유형을 포함하는 개념이다.
- 문제 해결과정은 문제 인식 -> 생각 -> 풀이 방법 발견 -> __코드로 옮기기__
- 코드로 옮기지 못하면 말짱 도로묵이다. 구현 유형의 문제는 '풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제'를 의미한다.
- 구현하기 어려운 문제는 알고리즘은 간단한데 코드가 지나치게 길어지는 문제, 특정 소수점 자리까지 출력해야 하는 문제, 파싱을 해야 하는 문제 등이 있다.
- 구현 문제를 풀 땐 언어 문법을 정확하게 숙지하지 못햇거나, 라이브러리 사용 경험이 부족하면 불리하다.
- 완전 탐색, 시뮬레이션 유형 모두 '구현' 유형으로 묶어서 보자 완전 탐색은 모든 경우 수 다 계산하는 해결방법이고 시뮬레이션은 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야 하는 문제 유형이다.
- 둘 다 구현이 핵심이 되는 경우가 많다.
< 언어에서의 제약 사항 >
### < 언어에서의 제약 사항 > ###
- 파이썬에서의 실수형 변수는 다른 언어와 마찬가지로 유효숫자에 따라서 연산 결과가 원하는 값이 나오지 않을 수 있다
#### 파이썬에서 리스트 크기
- 파이썬에서 리스트 이용 시 고려할 점은 코딩 테스트의 메모리 제한이다. 대체로 128~512MB로 메모리를 제한한다.
- int 자료형의 데이터 개수에 따른 메모리 사용량을 확인해보자. (시스템 내부적으로 다음 표에서 보여주는 것과 유사한 크기만큼 메모리를 차지한다.
| 데이터의 개수(리스트의 길이) | 메모리 사용량 |
| :---: | :---: |
| 1,000 | 약 4KB |
| 1,000,000 | 약 4MB |
| 10,000,000 | 약 40MB |

- 파이썬은 다른 언어에 비해서 구현상의 복잡함이 적은 편이지만 데이터 처리량이 많을 때는 꼭 메모리 제한을 고려하도록 해야한다.
- 크기가 1,000만 이상인 리스트가 있다면 메모리 용량 제한으로 문제를 풀 수 없게 되는 경우도 있다.
- 하지만 이런 문제 또한 드물다. 이 정도 크기면 입출력에 너무 많은 시간이 소요되며 채점 환경에서도 문제가 발생할 수 있기 때문이다.
- 따라서 일반적인 코딩 테스트 수준에서는 메모리 사용량 제한보다 더 적은 메모리를 사용해야 한다는 점 정도만 기억하면 된다.
#### 채점 환경
- 보통 코딩 테스트 환경에서는 채점 시스템의 시간 제한 및 메모리 제한 정보가 적혀있다.
 + 시간 제한: 1초
 + 메모리 제한: 128MB
- 일반적으로 코딩테스트 환경에서 1초에 2,000만 번의 연산을 수행한다고 생각하고 푸는 것이 무리가 없다.
- N = 1,000,000일 때, Nlog2 N은 약 20,000,000이다. 그니까 O(NlogN) 이내의 알고리즘으로 문제를 풀어야한다. 100만 개일때

#### 구현 문제에 접근하는 방법
- 고차원적인 사고력을 요구하는문제는 나오지 않는 편이기에 문법에 익숙하다면 오히려 쉽게 풀 수 있다.
- API 개발 문제 또한 구현 유형과 상당히 맞닿아 있다. ex) 카카오 문제 풀이 서버와 통신하는 프로그램 모듈을 작성해라 이는 알고리즘 문제와 별개로 웹 서버나 데이터 분석에 대한 기초지식도 필요하다. 이런 기능을 구현해야 할때 , C++나 자바에 비해 파이썬은 매우 간결하고 직관적인 코드의 라이브러리를 사용할 수 있어 더 유리하다.


## [번외] 꼭 필요한 자료구조 기초
- 탐색 : 많은 양의 데이터 중에서 원하는 데이터를 차즌 과정
  + 대표적인 탐색 알고리즘 : DFS, BFS

- 자료구조 : 데이터를 표현하고 관리하고 처리하기 위한 구조
  + 스택과 큐는 자료구조의 기초 개념으로 다음의 두 핵심적인 함수로 구성된다.
    * 삽입(Push): 데이터를 삽입한다
    * 삭제(Pop): 데이터를 삭제한다.
  + 물론 실제로는 오버플로, 언더플로를 고민해야 한다.

### 스택
- 스택 : 선입후출(FILO) 구조 or 후입선출(LIFO) 구조
- 파이썬에서 스택은 list와 같다.

### 큐
- 큐 : 선입선출(FIFO) 구조
- 파이썬에서 collections 모듈에서 제공하는 deque 자료구조를 활용하자.

### 재귀 함수
- 재귀 함수 : 자기 자신을 다시 호출하는 함수
- 보통 파이썬 인터프리터는 호출 횟수 제한이 있다. 따라서 무한대로 재귀 호출을 진행할 수는 없다.
- 종료 조건을 무조건 명시해야 한다. 
- 컴퓨터 내부에서 재귀 함수의 수행은 스택자료구조를 이용한다. 함수를 계속 호출했을 때 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 때문이다.
- 따라서 스택 자료구조를 활용해야 하는 상당수 알고리즘은 재귀 함수를 이용해서 간편하게 구현될 수 있다. DFS가 대표적이다.
- 재귀 함수를 이용하면 코드가 간결해진다. 수학의 점화식(재귀식)을 그대로 코드로 옮겼기 때문이다.
- 재귀 함수는 반복문을 이용하는 것과 비교했을 때 더욱 간결한 형태이다.

## 탐색 알고리즘 'DFS/BFS'
### DFS
- Depth-First Search, 깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다. 즉, 최대한 멀리 있는 노드를 우선으로 탐색
- 먼저 그래프의 기본 구조에 대해 알아보자.
  + 그래프는 노드와 간선으로 표현되며 이때 노드를 정점이라고도 말한다.
  + 또한 두 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다(Adjacent)'라고 표현한다.
  + 프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있는데 코테에서는 이 두 방식 모두 필요하니 두 개념에 대해 바르게 알고 있도록 하자.
    * 인접 행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
      - 연결된 그래프를 인접 행렬로 표현할 때 파이썬에서는 2차원 리스트로 구현할 수 있다.
      - 연결되어 있지 않으면 무한(INF)의 비용이라고 작성한다.
    * 인접 리스트(Adjacency List) : 리스트로 그래프의 연결 관계를 표현하는 방식
      - 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다. (연결 리스트 방식)
      - C++, Java는 연결 리스트 기능을 위한 표준 라이브러리를 제공하지만 파이썬은 리스트를 이용하면 된다. 인접 리스트를 이용해 그래프를 표현하고자 할 때에도 단순히 2차원 리스트를 이용하면 된다는 점을 기억하자.
      - graph[0].append((1, 7)) # 노드0에 연결된 (노드, 거리) 노드 1이 연결되어 거리 7의 edge를 가지고 있다는 의미
    * 그렇다면 위 두 방식은 어떤 차이가 있을까?
    * 메모리와 속도 측면에서 살펴보겠다.
    * 메모리 측면에서는 모든 관계를 저장하는 인접 행렬 방식이 불리하다.
    * 속도 측면에서는 인접 리스트 방식은 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻기 위해선 연결된 데이터를 하나씩 확인해야 하기 때문에 느리다.
- DFS의 구체적인 동작
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
  2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 거낸다.
  3. 위 과정을 반복한다.
- 데이터의 개수가 N개인 경우 O(N)의 시간이 소요된다는 특징이 있다.

### BFS
- Breadth First Search, 너비 우선 탐색이라는 의미를 가진다. 가까운 노드부터 탐색하는 알고리즘이다.
- 선입선출 방식인 큐 자료구조를 이용하는 것이 정석이다.
- BFS의 구체적인 동작
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
  2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
  3. 위 과정을 반복한다.
- 탐색을 수행함에 있어 O(N)의 시간이 소요된다.
- 일반적인 경우 실제 수행 시간은 DFS보다 좋은 편이라는 점까지만 추가로 기억하자.

## 기준에 따라 데이터를 '정렬'
### 정렬 알고리즘 개요
- 정렬 : 데이터를 득정한 기준에 따라서 순서대로 나열하는 것
- 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬을 알아볼 것이다.
- 컴퓨터는 사람과 다르게 데이터의 규칙성을 직관적으로 알 수 없기에 어떻게 정렬을 수행할 것인지에 대해 구체적으로 명시해야한다.
### 선택정렬
- 가장 원시적인 방법으로 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복
- 매번 가장 작은 것을 선택한다는 의미
- 시간 복잡도는 간단히 O(N^2)이다.

### 삽입정렬
- 데이터를 하나씩 환인하며, 각 데이터를 적절한 위치에 삽입하는 동작을 이용
- 구현 난이도는 높지만 실생 시간 측면에서 선택정렬에 비해 효율적
- 데이터가 거의 정렬되어 있을때 훨씬 효율적이다.
- 선택정렬은 모든 훤소를 비교하고 위치를 바꾸는 반면 삽입 정렬은 그렇지 않다.
- 삽입정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에 , 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.
- 정렬이 되면 항상 오름차순을 유지한다.
- 시간 복잡도는 O(N^2)이고 선택 정렬과 마찬가지로 2개의 반복문이 중첩되었다.
- 보통은 비효율적이나 거의 정렬이 되어있는경우 퀵 정렬보다 더 강력하다.

### 퀵 정렬
- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면 어떨까??
- 호어 분할 방식은 가장 첫 번째 데이터를 피벗으로 정한다.
- 시간 복잡도는 O(NlogN)이다. 앞에서 봤던 두 정렬에 비해 매우 빠른 편이다.
- 이미 데이터가 정렬되어 있는 경우에 매우 느리게 동작한다.

### 계수 정렬
- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
- 데이터의 개수 N, 데이터 중 최댓값이 K -> 계수 정렬은 최악의 경우에도 O(N + K)를 만족한다.
- 데이터의 크기범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용한다. 
- 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.
- 예를 들어 0 이상 100 이하인 성적 데이터를 정렬할 때 계수 정렬이 효과적이다. 다만, 가장 큰 데이터와 가장 작은 데이터의 차이가 너무 크다면 계수 정렬은 사용할 수 없다. 계수 정렬이 이러한 특징을 가지는 이유는 계수 정렬을 이용할 때는 모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언해야 하기 때문이다.
- 예를 들어 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000이라면 총 1,000,001가 들어갈 수 있는 리스트를 초기화해야 한다. 여기서 1개를 더해주는 이유는 0부터 1,000,000까지는 총 1,000,001개의 수가 존재하기 때문이다.
- 계수 정렬은 앞서 다루었던 3가지 정렬 알고리즘처럼 비교 기반의 정렬 알고리즘이 아니다.
- 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.
- 시간복잡도는 O(N+K)이다. 데이터 범위만 한정되어있다면 항상 빠르게 동작한다. 
- 사실상 현존하는 정렬 알고리즘 중에서 기수 정렬과 더불어 가장 빠르다고 볼 수 있다.
- 기수정렬은 계수정렬에 비해 느리지만 처리할 수 있는 정수의 크기는 더 크다. 다행히 기수 정렬을 이용해야만 해결할 수 있는 코테는 거의 출제되지 않는다.
- 공간 복잡도는 개구데기다. 하나의 수에만 몰리는 경우 쓰잘데기 없이 메모리를 차지한다.

### 파이썬의 정렬 라이브러리
- sorted() 병합 정렬을 기반으로 만들어짐.
- sort(), sorted() 둘다 키 매개변수를 입력으로 받을 수 있다.
- 정렬 기준을 설정할 수 있다.

### 정렬 라이브러리의 시간 복잡도
- 최악의 경우에도 O(NlogN)을 보장한다.
- 별도의 요구없이 단순히 정렬을 해야한다면 라이브러리 쓰는게 최고다. 데이터가 한정되어 있다면 계수 정렬을 쓰자
1. 정렬 라이브러리로 풀 수 있는 문제 : 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용 방법을 숙지하고 있으면 어렵지 않게 풀 수 있다.
2. 정렬 알고리즘의 원리에 대해서 물어보는 문제 : 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다.
3. 더 빠른 정렬이 필요한 문제 : 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.


## 범위를 반씩 좁혀가는 탐색
### 순차 탐색
- 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법

### 이진 탐색
- 내부가 이미 정렬되어 있는 상태에서 사용가능
- 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 게 이진 탐색 과정이다.
- 코딩 테스트에 단골로 나오니 외워두자. 높은 난도의 문제에서 이진 탐색 알고리즘이 다른 알고리즘과 같이 사용되는 경우가 있다.
- 탐색 범위가 2000만을 넘어가면 이진 탐색으로 문제에 접근해보자 처리해야 할 데이터의 개수나 값이 1000만 단위 이상으로 넘어가면 이진 탐색 같이 O(logN)의 속도를 내야 하는 알고리즘을 떠올려야 문제를 풀 수 있는 경우가 많다.

### 트리 자료구조
- 이진 탐색의 전제 조건이 데이터 정렬이다.
- 데이터베이스 내부적으로 대용량 데이터 처리에 적합한 트리 자료구조를 이용하여 항상 데이터가 정렬되어 있다. 따라서 데이터베이스에서의 탐색은 이진 탐색과는 조금 다르지만, 이진 탐색과 유사한 방법을 이용해 탐색을 항상 빠르게 수행하도록 설계되어 있어서 데이터가 많아도 탐색하는 속도가 빠르다.

### 이진 탐색 트리
- 이진 탐색이 동작할 수 있도록 고안된, 효율적인 탐색이 가능한 자료구조이다.
- 모든 트리가 다 이진 탐색 트리는 아니다.
- 부모 노드보다 왼쪽 자식 노드가 작고 오른쪽 자식 노드는 크다라는 특징을 가진다.

### 빠르게 입력받기
- 이진 탐색 문제는 입력 데이터가 많거나 탐색 범위가 매우 넓은 편이다.
- 데이터가 1000만 개를 넘어가거나 탐색 범위가 1000억 이상이라면 이진 탐색 알고리즘을 의심해보자.
- 이때 input()을 사용하면 동작 속도가 느려 시간 초과가 날 수 있다.
- 이럴 땐 sys 라이브러리의 readline() 함수를 이용하면 시간 초과를 피할 수 있다.
- 때로는 sys 라이브러리를 사용하길 출제자가 적어놓는 경우도 있다.

```python
import sys
input_data = sys.stdin.readline().rstrip()
```
- sys를 사용할 때는 한 줄 입력받고 나서 rstrip() 함수를 꼭 호출해야 한다. 소스코드에 readline()으로 입력하면 엔터가 입력되는데 이걸 제거하기 위해서 rstrip() 함수를 사용해야 한다.

## 다이나믹 프로그래밍
### 중복되는 연산을 줄이자.
- 시간이 매우 많이 필요하거나 메모리 공간이 매우 많은 경우 등이 컴퓨터로도 해결하기 어려운 문제.
- 그래서 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야함.
- 대표적인 방법이 다이나믹 프로그래밍(동적 계획법)임.  

※ 다이나믹 프로그래밍과 동적 할당의 다이나믹은 같은 의미일까?
+ 프로그래밍에서 다이나믹은 __'프로그램이 실행되는 도중에'__ 라는 의미이다.
+ 예를 들어 자료구조에서 동적할당은 프로그램 실행 중에 프로그램 실행에 필요한 메모리를 할당하는 기법이다.
+ 하지만 다이나믹 프로그래밍에서의 다이나믹은 이런 의미가 아니라는 것을 기억하자.

- 다이나믹으로 해결할 수 있는 대표적인 예시는 피보나치 수열.
- 피보나치 수열은 이전 두항의 합을 현재의 항으로 설정하는 특징이 있음.
- 점화식은 인접한 항들 사이의 관계식을 의미하고 이를 이용하여 피보나치 수열의 점화식을 만들 수 있음.  
```An+2 = An+1 + An```
- 피보나치 수열은 리스트로 표현할 수 있고 크기가 커질수록 수행시간이 기하급수적으로 늘어난다. 반복되는 연산을 수행하기 때문이다.
- 그래서 재귀 함수를 이용해서 단순히 매번 계산하면 효율적으로 해결할 수 없다. 이 문제는 다이나믹 프로그래밍을 사용하여 효율적으로 해결할 수 있다.
- 다만, 항상 다이나믹 프로그래밍을 사용할 수는 없고, 다음 조건을 만족할 시에 사용할 수 있다.  
__1. 큰 문제를 작은 문제로 나눌 수 있다.__
__2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.__
- 피보나치 수열을 이러한 조건을 만족하는 대표 문제이다.
- 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한결과를 그대로 가져오는 기법을 의미.
- 메모이제이션은 값을 저장하는 방법이므로 캐싱이라고도 한다.
```python
# 메모이제이션을 이용한 피보나치 수열 소스코드(재귀적)
d = [0] * 100 # 메모이제이션을 위한 리스트 초기화

def fibo(x):
  if x==1 or x==2: # 종료 조건
    return 1
  if d[x]!=0: # 이미 연산했었던 문제인 경우, 리스트 값을 반환
    return d[x]
  d[x] = fibo(x-1) + fibo(x-2) # 연산한 적 없으면 피보나치 결과 반환
  return d[x]

print(fibo(99))
```
- 위의 소스코드처럼 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 __탑다운 방식__ 이라고 한다.
- 반면 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 __바텀업 방식__ 이라고 한다.
```python

# 바텀업 방식을 이용한 소스코드
d[0] * 100
d[1] = 1; d[2] = 1
n = 99
for i in range(3,n+1):
  d[i] = d[i-1] + d[i-2]
print(d[n])
```
- 탑다운은 하향식이라고도 하고 바텀업은 상향식이라고도 한다. 다이나믹 프로그래밍의 전형적인 형태는 바텀업 방식이다.
- 바텀업 방식에서 사용되는 결과 저장용 리스트는 'DP 테이블'이라고 부르며, 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.
- 다이나믹 프로그래밍과 메모이제이션의 개념을 혼용해서 사용하는 경우도 있는데, 엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미하므로, 다이나믹 프로그래밍과는 별도의 개념이다.
- 한 번 계산된 결과를 어딘가에 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다.
- 앞서 수열은 리스트로 표현한다고 했는데, 메모이제이션은 때에 따라 딕셔너리를 이용할 수도 있다.
- 딕셔너리는 수열처럼 연속적이지 않은 경우에 유용하다. 예를 들어 An을 계산하고자 할 때 A0~An-1 모두가 아닌 일부의 작은 문제에 대한 해답만 필요한 경우가 존재할 수 있다. 이런 경우 딕셔너리를 사용하는 것이 더 효과적이다.
- 문제를 푸는 첫 단계는 주어진 문제가 어떤 유형임을 파악하는 것이다. 특정한 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인하자.
- 가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 바텀업 방식으로 구현하는 것을 권장한다. 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문이다.
- 실제로 앞선 소스코드에서도 5000번째 이상의 피보나치 수를 구하도록 하면 'recursion depth'와 관련된 오류가 발생할 수 있다. 이경우 sys 라이브러리에 포함된 setrecursionlimit() 함수를 호출하여 재귀 제한을 완화할 수 있다는 점 정도만 기억하자.

## 가장 빠른 길 찾기
### 가장 빠르게 도달하는 방법.
- 최단 경로 알고리즘 유형에는 다양한 종류가 있고 상황에 맞는 알고리즘이 이미 정립되어 있다.
- 예를 들어, '한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우', '모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우' 등의 다양한 사례 존재
- 일반적으로 최단 경로 알고리즘은 보통 그래프로 표현하고 각 지점은 그래프에서 노드로 표현, 지점 간 연결된 도로는 그래프에서 간선으로 표현 된다.
- 실제 코테에서는 단순히 최단 거리를 출력하도록 요구하는 문제가 많이 출제된다.
- 컴공 학부 수준에서 사용하는 최단 거리 알고리즘은 다익스트라, 플로이드 워셜, 벨만 포드 이렇게 3가지이다.
- 그중 다익스트라, 플로이드 워셜 이 2가지가 가장 많이 출제된다.
- 더불어 앞서 공부한 그리디, 다이나믹 프로그래밍 알고리즘이 최단 경로 알고리즘에 그대로 적용된다는 특징이 있다.

### 다익스트라 최단 경로 알고리즘
- 그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발해서 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘이다.
- '음의 간선'이 없는 경우 정상적으로 동작한다.
  + '음의 간선'이란 0보다 작은 값을 가지는 간선을 의미하는데, 현실 세계의 길은 음의 간선으로 표현되지 않으므로 다익스트라 알고리즘은 실제로 GPS 소프트웨어의 기본 알고리즘으로 채택되곤 한다.
- 다익스트라 알고리즘은 기본적으로 그리디 알고리즘으로 분류된다. 매번 '가장 비용이 적은 노드'를 선택해서 임의의 과정을 반복하기 때문이다.
  1. 출발 노드를 설정한다.
  2. 최단 거리 테이블을 초기화한다.
  3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
  4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
  5. 위 과정에서 3,4번을 반복한다.
- 다익스트라 알고리즘은 최단 경로를 구하는 과정에서 '각 노드에 대한 현재까지의 최단 거리' 정보를 항상 1차원 리스트에 저장하며 리스트를 계속 갱신한다는 특징이 있다. ( 최단 거리 테이블)
- 매번 현재 처리하고 있는 노드를 기준으로 주변 간선을 확인한다. 나중에 현재 처리하고 있는 노드와 인접한 노드로 도달하는 더 짧은 경로를 찾으면 그 경로를 최단 경로로 판단하는 것이다.
- 따라서 방문하지 않은 노드 중에서 현재 최단 거리가 가장 짧은 노드를 확인해 그 노드에 대하여 4번 과정을 수행한다는 점에서 그리디 알고리즘으로 볼 수 있다.
- 다익스트라는 구현하지 쉽지만 느리게 동작하는 코드와 구현하기에 조금 더 까다롭지만 빠르게 동작하는 코드가 있다.
- 후자의 코드를 정확히 이해하고 구현할 수 있을 때까지 연습해야 한다.
- 고난이도 문제들이 최단 경로 알고리즘을 응용하여 풀 수 있는 문제들이 많아 자다가 일어나서 바로 코드를 작성할 수 있을 정도로 코드에 숙달되어 있어야 한다.
- 다익스트라 알고리즘은 방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택하는 과정을 반복하는데, 이렇게 선택된 느드는 '최단 거리'가 완전히 선택된 노드이므로, 더 이상 알고리즘을 반복해도 최단 거리가 줄어들지 않는다. 다시 말해 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있다. 그래서 사실상 마지막 노드에 대해서는 해당 노드를 거쳐 다른 노드로 가는 경우를 확인할 필요가 없다.
#### 방법 1. 간단한 다익스트라 알고리즘
- 시간 복잡도 : O(V^2) - Vertex : 노드의 개수
- 직관적이고 쉽게 이해할 수 있다. 처음에 각 노드에 대한 최단 거리를 담는 1차원 리스트를 선언한다. 이후 단계마다 '방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택'하기 위해 매 단계마다 1차원 리스트의 모든 원소를 확인(순차 탐색)한다.
- 사실 최단 경로를 구하는 알고리즘인데 왜 리스트에 최단 거리만을 저장하냐면 코테에서는 대체로 특정 노드에서 다른 특정 노드까지의 최단 거리만을 출력하도록 요청해서 그렇지만 최단 경로를 구하기 위해서는 조금의 수정이 필요하다.

#### 방법 2. 개선된 다익스트라 알고리즘
- 시간 복잡도 : 최악의 경우에도 ElogV 보장
- 간단한 다익스트라 알고리즘에서 최단 거리를 찾기위해 선형적 탐색을 함으로써 O(V)의 시간 복잡도를 잡아 먹었다. 그렇다면 이 탐색의 시간을 줄인다면 시간 복잡도가 확실히 줄어들 것이다.
- 개선된 다익스트라 알고리즘은 힙 자료구조를 사용한다. 이를 이용하면 특정 노드까지의 최단 거리에 대한 정보를 힙에 담아서 처리하므로 출발 노드로부터 가장 거리가 짧은 노드를 더욱 빠르게 찾을 수 있다.
- 이 과정에서 선형 시간이 아닌 로그 시간이 걸린다. N= 1,000,000일 때, log2 N이 약 20인 것을 감안하면 엄청 빨라지는 것을 알 수 있다.
- 힙 설명
  + 우선순위 큐를 구현하기 위하여 사용하는 자료구조 중 하나이다.
  + 우선순위 큐는 우선순위가 가장 높은 데이터를 가장 먼저 삭제한다.
  + 대부분의 환경에서 우선순위 큐 라이브러리를 지원하기 때문에 직접 구현할 일은 없다.
  + 파이썬에서는 PriorityQueue 혹은 heapq를 사용할 수 있는데 일반적으로 heapq가 더 빠르게 동작하여 수행 시간이 제한된 상황에서는 heapq를 이용하는 것을 권장.
  + ( 가치, 물건 )으로 묶어서 우선순위 큐 자료구조에 넣는다. 이후 물건을 꺼내면 우선순위가 가장 높은 물건이 먼저 나온다.
  + 구현시 내부적으로 최소 힙 혹은 최대 힙을 이용한다. 최소 힙을 이용하는 경우 값이 낮은 데이터가 먼저 삭제되고 높으면 값이 높은 데이터가 먼저 삭제된다. 최소 힙을 사용할 것이다.
  + 또한, 최소 힙을 최대 힙처럼 사용하기 위해 일부러 우선순위에 해당하는 값에 음수 부호를 붙여서 넣었다가, 나중에 우선순위 큐에서 꺼낸 다음에 다시 음수 부호를 붙여서 원래 값으로 돌리는 방식을 사용할 수도 있다.
- 우선순위 큐가 적용되어도 다익스트라 알고리즘의 기본 동작은 변하지 않는다.
- 현재 가장 가까운 노드를 저장하기 위한 목적으로만 우선순위 큐를 추가로 이용한다.

#### 개선된 다익스트라 알고리즘의 시간 복잡도
- 직관적으로 봤을 때, 우선순위 큐를 이용하는 방식이 빠른 이유에 대해서 잘 납득이 가지 않을 수  있다.
- 코드에서 확인할 수 있듯이 한번 처리된 노드는 더 이상 처리되지 않는다. 다시 말해 큐에서 노드를 하나씩 꺼내 검사는하는 반복문은 노드의 개수 V 이상의 횟수로는 반복되지 않는다.
- 또한 V번 반복될 때마다 각각 자신과 연결된 간선들을 모두 확인한다. 따라서 '현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인'하는 총 횟수는 총 최대 간선의 개수만큼 연산이 수행될 수 있다.
- 따라서 전체 다익스트라 최단 경로 알고리즘은 E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 비슷하다고 볼 수 있다. 간단하게 시간 복잡도는 최대 E개의 간선 데이터를 힙에 넣었다가 다시 빼는 것으로 볼 수 있으므로 O(ElogE)임을 이해할 수 있다.
- 이때 중복 간선을 포함하지 않는 경우, E는 항상 V^2보다 작다. 왜냐면 모든 노드끼리 서로 다 연결되어 있다고 했을 때 간선의 개수를 약 V^2로 볼 수 있고 E는 항상 V^2이하이기 때문이다. 다시 말해 log E는 log V^2보다 작다. 이때 O(log V^2)은 O(2logV)이고, 이는 O(log V)이다. 따라서 간단히 O(ElogV)라고 볼 수 있다.
- 다익스트라 알고리즘은 우선순위 큐를 이용하여 이를 이용하는 다른 문제 유형과도 흡사하다. 그래서 두루 적용되는 소스코드 형태이다. 예로써 그래프 문제로 유명한 최소 신장 트리 문제를 풀 때에도 일부 알고리즘(Prim 알고리즘)의 구현이 다익스트라와 흡사하다는 특징이 있다.

### 플루이드 워셜 알고리즘
- 다익스트라는 '한 지점에서 다른 특정 지점까지의 최단 경로를 구해야하는 경우' 사용된다.
- 이 알고리즘은 '모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우' 사용할 수 있다.
- 소스코드가 짧아서 다익스트라 알고리즘과 비교하면 구현 과정에서는 어려움이 없지만 핵심 아이디어를 이해하는 것이 중요하다.
- 다익스트라 알고리즘은 단계마다 최단 거리를 가지는 노드를 반복적으로 선택한다. 그리고 해당 노드를 거쳐 가는 경로를 확인하며, 최단 거리 테이블을 갱신하는 방식으로 동작한다. 
- 플루이드 워셜 또한 단계마다 '거쳐 가는 노드'를 기준으로 알고리즘을 수행한다. 하지만 매번 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾을 필요가 없다는 점이 다르다. 
- 노드의 개수가 N개일 때 알고리즘 상으로 N번의 단계를 수행하며, 단계마다 O(N^2)의 연산을 통해 '현재 노드를 거쳐 가는' 모든 경로를 고려한다. 따라서 시간 복잡도가 O(N^3)이다.
- 다익스트라는 출발 노드가 1개이므로 다른 모든 노드까지의 최단 거리를 저장하기 위해서 1차원 리스트를 이용했다. 반면에 플루이드 워셜은 2차원 리스트에 '최단 거리' 정보를 저장한다는 특징이 있다. 모든 노드에서 다른 모든 노드로의 최단 거리 정보를 담아야 하기 때문에 당연하다. 다시 말해 2차원 리스트를 처리해야 하므로 N번의 단계에서 매번 O(N^2)의 시간이 소요된다.
- 또한 다익스트라는 그리디 알고리즘인데 플루이드 워셜은 다이나믹 프로그래밍이라는 특징이 있다.
- 노드의 개수가 N이라고 할 때, N번 만큼의 단계를 반복하며 '점화식에 맞게' 2차원 리스트를 갱신하기 때문에 다이나믹 프로그래밍으로 볼 수  있다.
- 각 단계에서는 해당 노드를 거쳐 가는 경우를 고려한다. 예로 1번노드를 생각하면 A->1번->B로 가는 비용을 확인 후 최단 거리를 갱신한다. A에서 B로 이동하는 비용이 3으로 기록되어 있을 때, A->1번->B로 이동하는 비용이 2라고 밝혀지면 A->B로 이동하는 비용을 2로 갱신한다.
- 따라서 현재 확인하고 있는 노드를 제외하고, N-1 개의 노드 중에서 서로 다른 노드 (A,B)쌍을 선택한다. 이후에 A->1->B로 가는 비용을 확인한 뒤에 최단 거리를 갱신한다. 다시 말해 N-1 P 2 개의 쌍을 단계마다 반복해서 확인하면 된다. 이떄 O(N-1 P 2)는 O(N^2)이라고 볼 수 있어 시간 복잡도는 O(N^3)이라고 할 수 있다.
- 점화식은 다음과 같다. Dab = min(Dab, Dak + Dkb)






































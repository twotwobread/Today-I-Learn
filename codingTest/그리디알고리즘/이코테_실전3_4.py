# file name: 이코테_실전3_4.py
# 어떤 수 N이 1이 될 때까지 다음의 두 과정중 '하나'만 선택하여수행
# 단, 두 번째 연산은 N이 K로 '나누어 떨어질 때'만 가능
# 1. N에서 1을 뺀다.
# 2. N을 K로 나눈다.
# N = 17, K = 4 -> 3회
# 2 <= N <= 100,000 , 2 <= K <= 100,000
# author: 이수영 (2021-01-03)

# 현 시점에서 가장 크게 N을 작게 만들 수 있으면 되기 때문에 그리디 알고리즘 적합 -> '최대한 많이 나누기'
# 이 가정이 틀린 경우를 생각했을때 없음.
# 수열의 형태로 푸는 것은 불가능 규칙적으로 반복되는 부분이 없음.

# n, k 입력
n, k = map(int, input().split())

# 가장 크게 N을 작게 만드는 경우인 2번이 가능한지 비교
cnt = 0
while n > 1:
    if n%k==0:
        n /= k
        cnt += 1
    else:
        n -= 1
        cnt += 1
print(cnt)

# 2번이 안되면 1번 시행

###[ 제안된 예시 답안 ]###
# 이게 또 마찬가지로 갯수가 적어서 가능한 부분이다.
# 나는 이걸 규칙이 반복되는게 없다 생각했는데 사실 있다.
# 그건 나누어 떨어지지 않으면 -1을 한다는 것이다.
# 그럼 나누어 떨어질때 까지 -1을 해야하는 것이고 이걸 계속 -1하는 것보다 한 번에 빼는 것이 빠르게 동작할 것이다.
n, k = map(int, input().split())

# 가장 크게 N을 작게 만드는 경우인 2번이 가능한지 비교
cnt = 0
while True:
    # 먼저 나누어 떨어질 때까지 다 빼기
    target = int(n//k) * k
    cnt += n-target
    n = target
    if n < k:
        break
    # k로 나누기
    cnt += 1
    n //= k

cnt += (n-1) # 1이 마지막에 남고 반복문이 한번더 진행되는 경우를 생각하면 1의 개수까지도 넣게 된다.
print(cnt)

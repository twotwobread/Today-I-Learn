# file name: 이코테_예제3_2.py
# 수영이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다.
# 단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 특징이다.
# 예를 들어 순서대로 2 4 5 4 6 이면 M=8, K=3
# 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5=46이 된다.
# 단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.
# N(2<=N<=1,000), M(1<=M<=10,000), K(1<=K<=10,000)
# author: Lee Suyoung (2022-01-03)
# update

# 배열의 크기가 1000개 밖에 안되니까 먼저 배열을 정리하고 가장 큰 놈을 K번 더하고 그 다음놈 하나 더하고를 반복하자

# N, M, K 입력 부분
n, m, k = map(int, input().split())
l = list(map(int, input().split()))
# N 정렬하는 부분5
print(l)
l.sort(reverse=True)
print(l)
# M번 만큼 돌리면서 K번 만큼 제일 높은놈 더해주는 부분
re = k; sum = 0
while m>0:
    if re == 0:
        sum += l[1]
        re = k
        m -= 1
        continue
    sum += re*l[0]
    m -= re
    re = 0

print(sum)
# 결과값 출력하는 부분

###[ 제시된 예시 답안 ]###
# 위의 방식을 이용한다면 M의 크기가 커지면 시간 초과로 터진다.
# 간단한 수학적 아이디어를 이용하자
# 지금 이놈의 형식 자체가 가장 큰 놈을 K번 만큼 더하고 그보다 인덱스하나 작은 놈을 1번 더하고를 반복하는 문제이다.
# 그럼 수열의 느낌으로 나타낼 수 있게 된다.
# M=8, K=3, N=5 , data = 2 4 5 4 6 이면 
# [6+6+6+5]+[6+6+6+5] .... 이런 식으로 더해간다.
# M/(k+1) 이것이 반복되는 수열의 길이가 된다. 
# (M/(k+1))*k 이것이 가장 높은 숫자가 더해지는 횟수가 된다. 
# 경우의 수는 나누어 떨어지는 경우거나 나누어 떨어지지 않는 경우 두개를 생각하면 된다. 
# M%(k+1)도 생각을 해야한다. 이 경우는 당연히 가장 큰 놈을 다 더해야겠지

n,m,k = map(int, input().split())
l = list(map(int, input().split()))

l.sort(reverse=True)
count_first = (m/(k+1))*k + (m%(k+1))

result = count_first*l[0]
result += (m-count_first)*l[1]
print(int(result))

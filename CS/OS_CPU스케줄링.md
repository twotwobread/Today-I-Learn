# 01 스케줄링의 개요
> CPU 스케줄러는 프로세스가 생성된 후 종료될 떄까지 모든 상태 변화를 조정하는 일을 함.
## 1 식당 관리자의 스케줄링
- 대부분의 식당은 주방과 홀 분리 -> 요리사가 홀의 상황을 알기 어려움.
- 그래서 식당 관리자가 주문을 받거나 대기자를 관리 그리고 주문을 요리사에게 전달.
- 예약관리, 좌석관리를 수행
  + 손님이 없으면 바로 테이블로 안내 후 주문 받기
  + 손님이 많으면 대기 번호를 주고 순서대로 자리 배정
  + 예약 손님이 있으면 예약 자리 비워두고 제시간에 예약 손님이 나타나지 않으면 연락 혹은 다른 손님 배정
- 주문관리
  + 손님이 주문한 요리, 고기의 익힘 정도 등을 주문서에 적어 주방으로 전달.
- 조리순서 관리
  + 예약손님의 음식을 먼저 주거나 한 손님이 디저트를 먹어야하는 시점에서 다른 손님은 메인요리도 못받았다면 다른 손님의 음식을 먼저 조리 요청
    - 관리자의 재량에 따라 관리할 수 있음.
    - 요리사는 홀의 상황을 잘모르기 때문에 관리자가 조리 순서도 관리.
- 손님의 개별적인 요구 대응
  + 케이크를 주문했는데 과일로 변경 등
- 이러한 역할을 OS에서 CPU 스케줄러가 담당.
  + 스케줄링 : 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일.
## 2 스케줄링의 단계
- 식당 관리자의 주문과 관련된 두 가지 일
  1. 좌석관리
    + 전체 좌석수, 실시간 좌석 배정, 여유 좌석 배분같이 큰 틀에서 좌석을 관리
  2. 조리순서 관리
    + 자리를 배정받은 손님에 한하여 이루어지는 작은 틀의 관리.
    + 손님들의 다양한 상황을 고려하여 요리가 나가는 순서와 속도 관리.
- 이와 같이 CPU 스케줄링도 관리의 범주를 나누어 스케줄링
  + 위에서 처럼 큰 틀에서의 관리와 작은 틀에서의 관리를 병행
  + 규모에 따라 고수준 스케줄링, 중간 수준 스케줄링, 저수준 스케줄링으로 구분.
### 2.1 고수준 스케줄링
- 가장 큰 틀에서 이루어지는 스케줄링, 장기 스케줄링(long-term scheduling), 작업 스케줄링(job scheduling)
- 많은 작업을 동시에 할 시 시스템에 과부하 -> 작업 원활 X
- 시스템 내의 전체 작업 수를 조절.
  + 작업이란 OS에서 다루는 일의 가장 큰 단위 ( 1개 or 여러 개의 프로세스 )
  + 어떤 작업을 시스템이 받아들일지 or 거부할지를 결정, 승인 스케줄링 (admission scheduling)
  + 작업이 시작되면 시스템 자원을 사용하여 기존 작업에 영향.
- 시스템 내에서 동시에 실행 가능한 프로세스의 총개수가 정해짐.
### 2.2 저수준 스케줄링
- 반대로 가장 작은 단위의 스케줄링.
- 각 손님의 주문과 그에 따른 요리 제공 순서를 미세하게 조절하는 단계.
- CPU 스케줄러의 입장에서 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 일.
  + 준비 -> 실행, 실행 -> 대기, 대기 -> 준비 등.
- 앞에서 학습한 프로세스 상태에 관한 내용은 대부분 저수준 스케줄링에 해당.
- 아주 짧은 시간에 일어나 단기 스케줄링 ( short-term scheduling )
### 2.3 중간 수준 스케줄링
- 고수준, 저수준사이에 일어나는 스케줄링.
- 고수준에서 프로세스 활성화를 결정 -> 전체 프로세스 수를 조절
- but 활성화된 후에도 여러 사정으로 시스템 과부화 가능.
  + 이는 식당 관리자의 판단으로 좌석관리를 하여 손님을 받았는데, 하필 모든 손님이 조리 시간이 긴 코스를 주문한 경우에 비유.
  + 이럴 때, 식당 관리자는 시간이 덜 걸리는 코스 요리로 변경 유도 or 주문을 천천히 받음.
- 중지(suspend)와 활성화(active)로 전체 시스템의 활성화된 프로세스 수를 조절.
  + 즉, 일부 프로세스를 중지 상태로 옮김으로써 나머지 프로세스 원만히 작동.
  + 이는 프로세스의 상태 중 보류 상태에 해당, 저수준 스케줄링이 원만히 이루어지도록 완충하는 (buffer) 역할을 함.
- 이후의 CPU 스케줄러는 특별한 명시가 없는 한 저수준 스케줄러를 의미.  
## 3 스케줄링의 목적
1. 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안됨.
2. 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 함.
3. 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호
4. 확장성 : 프로세스가 늘어나도 시스템이 안정적으로 작동하도록 조치해야함. 또한 시스템 자원이 늘어나는 경우 이 혜택이 시스템에 반영되도록 해야함.
5. 반응 시간 보장 : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야함.
6. 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되어서는 안됨.
- 일반적으로 모든 프로세스가 공평히 CPU를 할당받아야하지만 시스템의 안정성과 효율성을 높이기 위해 일정 부분 공평성을 희생.
- OS 프로세스는 일반 프로세스보다 우선적으로 CPU를 배정.
- 또한 일반 프로세스간에도 우선순위에 따라 CPU 배정 순서가 달라짐.

# 02 스케줄링 시 고려 사항
> CPU 스케줄러가 어떤 프로세스를 먼저 CPU 할당할 것인지 결정할 때 고려사항.
## 1 선점형 스케줄링과 비선점형 스케줄링
- 선점형 스케줄링 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 OS가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
  + ex) 인터럽트 - CPU가 인터럽트를 받으면 실행 중인 작업을 중단하고 커널을 깨워서 인터럽트 처리 후 다시 작업으로 돌아감.
  + 단점 : 문맥 교환 같은 부가적인 작업으로 인해 낭비가 생김.
  + 하나의 프로세스가 CPU를 독점할 수 없어서 빠른 응답을 요구하는 대화형 시스템이나 시분할 시스템에서 적합.
  + 대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용.
- 비선점형 스케줄링 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식.
  + 자발적 종료 혹은 대기 상태에 들어가기 전까지는 계속 실행.
  + 스케줄러의 작업량이 적고 문맥 교환에 의한 낭비도 적음.
  + 여러 프로세스가 오랫동안 기다려야 하여 전체 시스템의 효율성이 떨어짐.
  + 과거의 일괄 작업 시스템에서 사용하던 방식.
- 선점형 스케줄링 방식의 스케줄러에도 비선점형 프로세스가 존재.
  + 시스템 백업하는 프로세스는 비선점형.
  + 두 개가 같이 혼재하는 경우엔 비선점형 프로세스의 중요도를 매우 낮게 설정하여 프로세스에 영향을 덜 미치도록 한다.
## 2 프로세스 우선순위.
- 대부분의 CPU 스케줄러는 우선순위 사용.
- 커널 프로세스 > 일반 프로세스. -> 커널과 관련된 중요한 프로세스의 작업을 제대로 처리하기 위해서.
- 일반 프로세스 중에도 우선순위가 존재.
  + ex) 워드와 비디오 플레이어 중에는 비디오가 우선순위 높음.
  + 워드의 경우 타이핑하는 속도가 CPU의 연산 속도보다 느리기에 천천히 실행되어도 문자 입력 처리 가능.
  + 반면, 비디오는 실시간으로 데이터를 읽어와 영상과 소리를 출력해야 하기에 자주 실행되지 않으면 끊김.
  + 일반 프로세스의 우선순위는 유닉스 OS에서는 nice 명령어를 이용하여 사용자가 조절 가능. 단, 관리자만 우선순위를 높일 수 있고 일반 계정은 낮추는 것만 가능.
  + 우선순위 조절 시에는 해당 프로세스뿐만 아니라 다른 프로세스의 실행 속도에도 영향을 미친다는 것 주의.
  + 시스템에 따라 높은 순자가 높은 우선순위 일수도 있고 반대일 수도 있는데 여기서는 낮은 숫자가 높은 우선순위라고 가정.
## 3 CPU 집중 프로세스와 입출력 집중 프로세스.
- 프로세스 상태 중 실행, 대기 상태가 실제 작업이 일어나는 상태
- CPU를 할당받아 실행하는 작업을 CPU 버스트, 입출력 작업을 입출력 버스트.
- CPU 집중 프로세스 : 수학 연산과 같이 CPU를 많이 사용하는 프로세스 (즉, CPU 버스트가 많음.)
- 입출력 집중 프로세스 : 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스 (즉, 입출력 버스트 많음.)
- 두 집중 프로세스가 혼재할 떈 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적.
  + 입출력 요구에 의해 대기 상태로 옮겨지기에 다른 프로세스가 CPU를 사용가능하기 때문.
  + CPU 집중의 경우 타임 슬라이스가 끝날 때까지 다른 프로세스 사용불가능.
  + so, 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템 효율 상승.
  + 입출력 집중 프로세스가 CPU 집중 프로세스보다 실행 상태에 먼저 들어가는 경우를 사이클 훔치기(cycle stealing)
## 4 전면 프로세스와 후면 프로세스.
- 워드를 사용하면서 큰 파일을 압축하는 경우.
  + 워드는 입력을 받아야 하기에 전면, 압축은 입력이 필요없기에 후면.
- 전면 프로세스 : GUI를 사용하는 OS에서 화면의 맨 앞에 높인 프로세스를 의미. 현재 입출력을 사용하는 프로세스이며, 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 불림.
- 후면 프로세스 : 사용자와 상호작용이 없는 프로세스. 사용자의 입력없이 동작하여 일괄 작업 프로세스라고도 불림.
- 전면 프로세스는 사용자의 요구에 즉각 반응 해야하지만 후면은 상호작용 X
- so, 전면 프로세스 > 후면 프로세스.
## 5 정리
- 우선순위 높은 프로세스 : 커널, 전면, 대화형, 입출력 집중 프로세스
- 우선순위 낮은 프로세스 : 일반, 후면, 일괄 작업, CPU 집중 프로세스
- 커널과 일반, 전면과 후면의 경우 확실하게 기준이 명확함. -> 프로세스의 우선순위 배정 기준으로 사용
- but, 대화형과 일괄 작업, CPU 집중과 입출력 집중은 명확하게 구분 불가한 경우도 있음. -> 우선순위를 고려하기 어려움.  

# 03 다중 큐
## 1 준비 상태의 다중 큐
> 매번 프로세스의 PCB를 뒤져 가장 높은 우선순위의 프로세스를 찾는 일은 번거로움.
> so, 우선순위에 따라 여러 개의 큐를 만들어 관리 시 편리.
  + ex) 우선순위 1인 큐, 우선순위 2인 큐 등
- 프로세스가 준비 상태에 들어올떄마다 자신의 우선순의 큐의 tail에 삽입.
- 스케줄링 알고리즘에 따라 준비 큐를 몇 개로 나눌지, 여러 준비 큐에 있는 프로세스 중 어떤 프로세스에 CPU를 할당할지 결정하는 일이 달라짐.
- 프로세스의 우선순위를 배정하는 방식에는 고정 우선순위 방식과 변동 우선순위 방식 존재.
  + 고정 우선순위 방식 : OS가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식.
    - 구현은 쉽지만 시스템의 상황의 변환에 따라 대응하기 어려워 작업 효율이 떨어짐.
  + 변동 우선순위 방식 : 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식.
    + 구현은 어렵지만 효율성을 높일 수 있음.
    + ex) 우선순위가 낮은 P1이 중요한 자원을 사용 중 다른 프로세스는 P1이 끝날 때까지 기다려야함.
    + 이때 우선순위를 높이면 더 빨리 자주 사용되어 작업을 빨리 끝낼 수 있음.
    + 낮은 우선순위 -> 높은 우선순위 로의 교체 : 반전 우선순위 (priority inversion)
    + 변동 우선순위 방식인 반전 우선순위를 이용 시 시스템의 효율성 향상.
## 2 대기 상태의 다중 큐
- 다양한 입출력 장치가 존재해 혼재하면 관리하기 불편함.
- 특정 완료 인터럽트 발생 시 프로세스를 다 검색해야함. -> 번거로움.
- so, 대기 상태에서는 같은 입출력을 요구한 프로세스끼리 모음.
- 준비 상태와 대기 상태의 다중 큐는 차이가 존재.
  + 준비 큐 : 한 번에 하나의 프로세스 CPU 할당.
  + 대기 큐 : 여러 개의 PCB를 동시에 꺼내어 준비 상태로 옮김.
    - 시스템에 많은 입출력 장치가 존재하여 입출력이 동시에 끝날 경우 여러 개의 인터럽트 한번에 처리.
    - 동시에 끝나는 인터럽트를 처리하기 위해 인터럽트 벡터라는 자료 구조 사용.
      + 동시에 완료된 입출력 정보와 처리 방법이 담김.
- 대기 상태의 다중 큐에 존재하는 PCB는 큐에 삽입된 순서대로 처리되지만 일부는 나중에 들어온 PCB가 먼저 준비 상태로 가기도함.
  + 입출력 장치는 CPU나 메모리보다 느려 작업 속도를 높이기 위해 작업 순서를 바꾸는 경우 존재.  

# 04 스케줄링 알고리즘
 - 비선점형 알고리즘 : 프로세스가 CPU를 할당받으면 작업이 끝날 떄까지 CPU를 놓지 않음. 
  + 효율성이 떨어져 지금은 거의 사용 X
  + ex) FCFS 스케줄링, SJF 스케줄링, HRN 스케줄링 등
 - 선점형 알고리즘 : 시분할 시스템을 고려하여 만들어진 알고리즘으로, 어떤 프로세스가 CPU를 할당받아 실행 중이라도 CPU를 강제로 뺴앗을 수 있음.
  + ex) 라운드 로빈 스케줄링, SRT 스케줄링, 다단계 큐 스케줄링, 다단계 피드백 큐 스케줄링
- 둘 다 가능
  + ex) 우선순위 스케줄링
## 1 스케줄링 알고리즘의 선택 기준
- CPU 사용률 : 전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법.
  + 이상적인 수치는 100%이지만 실제로는 여러 이유로 90%도 못 미침.
- 처리량 : 시스템이 정상적으로 작동한다면 일정 시간 후 작업이 끝남.
  + 처리량은 단위 시간당 작업을 마친 프로세스의 수로, 이 수치가 끌수록 좋음.
- 대기 시간 : 작업 요청 시 실제 작업이 이루어지기 전까지 대기 시간이 필요.
  + 짧을수록 좋음.
- 응답 시간 : 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 떄까지 걸리는 시간.
  + 역시 짧을수록 좋음.
- 반환 시간 : 프로세스가 생상된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간.
  + 반환 시간 = 대기 시간 + 실행 시간.
- 사용률과 처리량은 계산하기 어려워 주로 대기 시간, 응답 시간, 반환 시간을 계산하여 효율성 평가.
  + 대기 시간 : 프로세스가 생성된 후 실행되기 전까지 대기하는 시간.
  + 응답 시간 : 첫 작업을 시작한 후 첫 번째 출력(반응)이 나오기까지의 시간.
  + 실행 시간 : 프로세스 작업이 시작된 후 종료되기까지의 시간
  + 반응 시간 : 대기 시간을 포함하여 실행이 종료될 떄까지의 시간
- 스케줄링 알고리즘의 성능을 비교할 때는 주로 평균 대기 시간을 확인.
  + 평균 대기 시간 : 모든 프로세스의 대기 시간을 합한 뒤 프로세스의 수로 나눈 값.
- 작업 패턴이 바뀔 시 평균 대기 시간이 역전되기도 함.
## 2 FCFS 스케줄링
### 2.1 FCFS 스케줄링의 동작 방식.
- FCFS (Firse Come First Served) 스케줄링 : 준비 큐에 도착한 순서대로 CPU 할당하는 비선점형 방식, 선입선출 스케줄링.
  + 큐가 하나라 모든 프로세스 우선순위가 동일.
  + FCFS는 FIFO이라고도 하는데 일반적으로 FIFO는 큐를 가르키기 때문에 이와 구분을 위해 FCFS로 부름.
### 2.2 FCFS 스케줄링의 성능.
ex) P1, P2, P3 순서대로 도착 -> 도착시간 : 0ms, 3ms, 6ms / 작업시간 : 30ms, 18ms, 9ms  
so, P1->P2->P3, (0+27+42) / 3 = 23ms
### 2.3 FCFS 스케줄링의 평가
- 단순하고 공평하지만 처리 시간이 긴 프로세스가 CPU를 차지 시 다른 프로세스들은 긴 시간을 기다려야 하고 이로 인해 효율성이 떨어짐.
  + 콘보이 효과(convoy effect) or 호위 효과 : 위와 같은 이유로 효율성이 떨어지는 문제.
- 현재 작업 중인 프로세스가 입출력 작업을 요청하는 경우 CPU가 작업하지 않고 쉬는 시간이 많아져 작업 효율이 떨어짐.
  + 시분할 시스템의 경우 대기 상태로 보내어 처리 가능 but, 일괄 작업 시스템의 경우 프로세스 상태 변화가 없어 작업 효율 떨어짐.  
## 3 SJF 스케줄링
### 3.1 SJF 스케줄링의 동작 방식
- SJF (Shortest Job First) 스케줄링 : 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU 할당하는 비선점형 방식, 최단 작업 우선 스케줄링.
  + SPF (Shortest Process FIrst) 스케줄링, 최단 프로세스 우선 스케줄링이라고도 함.
- 프로세스에 CPU를 배정 시 시간이 오래 걸리는 작업이 앞에 있고 간단한 작업이 뒤에 있을 시 순서를 바꾸어 실행.
  + 콘보이 효과를 완화하여 시스템의 효율성 높임.
### 3.2 SJF 스케줄링의 성능
ex) P1, P2, P3 순서대로 도착 -> 도착시간 : 0ms, 3ms, 6ms / 작업시간 : 30ms, 18ms, 9ms  
so, P1->P3->P2, (0+24+36)/3 = 20ms
### 3.3 SJF 스케줄링의 평가.
- 작은 작업을 먼저 실행하여 시스템의 효율성이 좋아짐.
- 먼저 도착한 큰 작업으로 이한 지연이 있는 FCFS 스케줄링보다 평균 대기 시간이 줄어듬.
- 이러한 장점에도 SJF는 다음과 같은 이유로 사용하기 힘듬.
  + OS가 프로세스의 종료 시간을 정확하게 예측하기 어려움.
    - 현대 프로세스는 사용자와의 상호작용이 빈번해 종료 시간을 파악하기 어려움.
    - ex) 워드를 사용 시 몇 분 만에 종료하는 경우도 있고 몇 시간에 걸쳐 작업하는 경우도 있음.
    - so, 현대의 OS에서는 프로세스의 작업 길이를 추정하는 것이 어려워 SJF 스케줄링을 사용하기 힘듬.
  + 공평하지 못함.
    - SJF는 공평성을 위배
    - P3 같은 작은 작업이 계속 준비 큐에 들어오면 P2의 작업이 계속 연기가 됨.
      + 위와 같은 상황을 아사(starvation) 현상 or 무한 봉쇄(infinite blocking) 현상
    - 작업 시간이 길다는 이유로 계속 뒤로 밀리면 공평성이 현저히 떨어짐.
- 이러한 두 문제의 해결 방안이 없는 것은 아님.
  1. 프로세스가 자신의 작업 시간을 OS에 알려주어 해결 가능.
    + but, 프로세스가 자신의 작업 시간을 정확히 알기 어려움.
    + 일부 악의적 프로세스가 작업 시간을 속이면 시스템의 효율성이 나빠짐.
  2. aging(나이 먹기)로 완화가능
    + 프로세스가 양보할 수 있는 상한성을 정하는 방식
    + ex) P1 프로세스가 세살만 먹으면(세번만 양보하면) 무조건 실행되도록 하는 것
    + but, 에이징 값을 어떤 기준으로 정할 것인지가 문제라 한계 존재.
- 결론적으로, SJF 스케줄링은 프로세스의 종료 시간을 파악하기 어렵고 starvation 현상이 일어나기에 잘 사용하지 않음.
## 4 HRN 스케줄링
### 4.1 HRN 스케줄링의 동작 방식
- HRN (Highest Response Ratio Next) 스케줄링 : SJF 스케줄링에서 발생할 수 있는 starvation 현상을 해결하기 위해 만들어진 비선점형 알고리즘, 최고 응답률 우선 스케줄링.
- SJF = 실행시간이 기준 -> 항상 적은 시간을 사용하는 프로세스에 우선권
- HRN = 서비스를 받기 위해 기다린 시간과 CPU 사용 시간을 고려하여 스케줄링.
  + HRN에서 우선순위를 결정하는 기준 : (대기시간 + CPU 사용 시간) / CPU 사용 시간
  + 이로써 starvation 완화 스케줄링 방식에 aging 구현.
### 4.2 HRN 스케줄링의 성능
ex) P1, P2, P3 순서대로 도착 -> 도착시간 : 0ms, 3ms, 6ms / 작업시간 : 30ms, 18ms, 9ms
먼저 P1 30ms동안 실행 -> 준비 큐에 있는 프로세스 P2, P3의 우선순위 계산 P2 = 27ms 기다렸으므로 우선순위 (27+18)/18 = 2.5이고 P3 = (24+9)/9 = 3.67이라서 P3 먼저 실행
실행 순서 SJF와 같아서 20ms걸림.
### 4.3 HRN의 스케줄링의 평가
- 실행시간이 짧은 프로세스의 우선순위를 높게 설정하면서도 대기 시간을 고려하여 starvation 완화
- SJF 스케줄링과 비교하면 대기 시간이 긴 프로세스의 우선순위를 높임으로써 CPU를 할당받을 확률을 높임.
- but, 여전히 공평성이 위배되어 많이 사용되지 않음.
  
## 5 라운드 로빈 스케줄링
### 5.1 라운드 로빈 스케줄링의 동작 방식
- 라운드 로빈(Round Robin, RR) 스케줄링 : 한 프로세스가 할당받은 타임 슬라이스 동안 작업 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식, 순환 순서 방식
- 선점형 알고리즘 중 가장 단순하고 대표적인 방식으로 프로세스들이 작업을 완료할 때까지 계속 순환하면서 실행.
- FCFS 스케줄링과 유사하지만 타임 슬라이스가 있다는 차이점 존재.
- 우선순위가 적용되지 않는 가장 단순한 선점형 스케줄링 방식.
### 5.2 라운드 로빈 스케줄링의 성능
ex) P1, P2, P3 순서대로 도착 -> 도착시간 : 0ms, 3ms, 6ms / 작업시간 : 30ms, 18ms, 9ms / 타임 슬라이스 : 10ms
P1 10ms동안 실행 -> P2 3ms 후 도착하여 7ms 기다렸다가 10ms 동안 실행 -> P3 6ms 후 도착 14ms 기다렸다가 9ms 동안 실행, P3 작업 끝 -> P1 29ms 후에 작업 다시 시작 (실제 대기 시간 19ms) 10ms 동안 실행 -> P2 8ms 실행, P2 작업 끝 -> P1 10ms 실행, P1 작업 끝  
총 대기 시간 = 0(P1) + 7(P2) + 14(P3) + 19(P1) + 19(P2) + 8(P1) = 67ms/3 = 22.33ms
- CPU를 일정 시간 사용 후 다른 프로세스로 주어야 해서 긴 작업을 무작정 기다리는 convoy 효과가 줄어듬.
### 5.3 타임 슬라이스의 크기와 문맥 교환
- FCFS 보다 약산 라운드 로빈이 앞섬.
- but, FCFS보다 평균 대기 시간이 적다고 단정할 수 없음.
- FCFS와 평균 대기 시간이 같다면 라운드 로빈 스케줄링이 더 비효율적.
  + 문맥 교환 시간을 고려하여 라운드 로빈 스케줄링의 평균대기 시간을 산출하면 앞의 계산보다 좀 더 크게 나옴.
- 효과적으로 작동하기 위해서 문맥 교환의 오버헤드를 고려하여 타임 슬라이스를 적절히 설정.
  + 타임 슬라이스의크기는 반응시간에 영향뿐만 아니라 시스템 전체의 성능에도 영향을 미침.
- 타임 슬라이스가 큰 경우
  + FCFS와 다를게 없어짐.
  + 타임 슬라이스가 1초인 경우, 비디오와 워드를 실행한다 가정
  + 1초 씩 두 프로그램이 실행되어 비디오는 끊겨 보이고 워드는 반응속도가 매우 느릴 것.
- 타임 슬라이스가 작은 경우
  + 시스템의 전반적인 성능이 떨어짐.
  + 문맥 교환이 너무 빈번히 발생하여 오버헤드가 커져 많은 시간을 낭비.
- 결론적으로 타임 슬라이스는 되도록 작게 설정하되 문맥 교환의 오버헤드를 고려하여 적당하게 설정.
- 유닉스 os에서의 타임슬라이스가 대략 100ms.
  + 대략인 이유는 고정되어 있지 않고 100~200ms 사이에서 조정할 수 있도록 했음.
  
## 6 SRT 우선 스케줄링
### 6.1 SRT 스케줄링의 동작 방식
- SRT (Shortest Remaining Time) 스케줄링 : SJF, 라운드 로빈을 혼합한 방식, 최소 잔류 시간 우선 스케줄링.
- 쉽게 말해 SJF의 선점형 버전.
- 기본적으로 라운드 로빈 방식을 사용 but, CPU를 할당받을 프로세스 결정 시 남아 있는 작업 시간이 가장 적은 프로세스 선택
### 6.2 SRT 스케줄링의 성능
- 대기시간 : 0(P1) + 4(P3) + 16(P2) + 27(P1) = 47ms
### 6.3 SRT 스케줄링의 평가
- SJF 보다 SRT의 평균 대기 시간이 짧음.
- but, SRT는 좋은 알고리즘이 아님.
- 현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고 남은 시간이 더 적은 프로세스와 문맥 교환을 해야 하므로 SJF에 없는 작업이 추가.
- SRT 마찬가지로 SJF처럼 OS가 프로세스의 종료 시간을 예측하기 어렵고 starvation 현상이 일어나서 잘 사용하지 않음.
  
## 7 우선순위 스케줄링
### 7.1 우선순위 스케줄링의 동작 방식
- 중요도에 따른 우선순위를 반영한 스케줄링 알고리즘.
- 어떤 기준으로 우선순위를 정하느냐에 따라 다양하게 구현 가능.
- ex) FCFS 스케줄링에서 작업 시간이 짧은 프로세스의 우선순위를 높게 설정했다 가정.
- 그 경우 SJF 스케줄링과 같은 평균 대기 시간 측정
- 우선순위는 비선점형 방식과 선점형 방식 모두 적용 가능
  + SJF 스케줄링 : 작업 시간이 짧은 프로세스에 높은 우선순위
  + HRN 스케줄링 : 작업시간이 짧거나 대기 시간이 긴 프로세스에 높은 우선순위 부여
  + SRT 스케줄링 : 남은 시간이 짧은 프로세스에 높은 우선순위 부여
- 고정 우선순위 알고리즘과 변동 우선순위 알고리즘으로 나뉨.
  + 고정 우선순위 알고리즘 : 우선순위를 부여받으면 종료 시까지 고정.
  + 변동 우선순위 알고리즘 : 일정 시간마다 우선순위가 변함.
### 7.2 우선순위 스케줄링의 평가
- 준비 큐에 있는 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU를 할당하여 공평성을 위배하고 아사 현상을 일으킴.
- 또한 순서를 무시하고 우선순위를 따름으로써 오버헤드 방생 -> 효율성이 떨어짐.
- 그럼에도 우선순위는 효율성이 아니라 프로세스의 중요도를 기준으로 결정.
## 8 다단계 큐 스케줄링
- 우선순위에 따라 여러 준비 큐를 사용하는 방식.
- 자신의 우선순위에 맞는 큐에 삽입됨.
- 우선순위는 고정형으로 사용하며, 상단의 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작됨.
- 우선순위에 따라 다양한 스케줄링이 가능한 선점형 방식
- 우선순위와 작업 형태를 고려하여 스케줄링이 가능.
- 우선순위가 높은 프로세스 때문에 우선순위가 낮은 프로세스의 작업이 연기되는 현상 발생
- 이러한 문제를 해결하기 위해 제안된 것이 다단계 피드백 큐 스케줄링.
## 9 다단계 피드백 큐 스케줄링
- 우선순위가 낮은 프로세스에 불리한 다단계 큐 스케줄링의 문제점을 보완한 방식.
- 기본적인 형태는 같음.
- 다른 점은 CPU를 사용하고 난 프로세스는 원래의 큐로 되돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어간다.
- 우선순위를 낮춤으로써, 우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화.
- 우선순위가 낮아진다라고 해도 커널 프로세스가 일반 프로세스의 큐에 삽입되지는 않음.
- 또 다른 특징은 우선순위에 따라 타임 슬라이스 크기가 달라짐.
- 우선순위가 낮아질수록 타임 슬라이스 크기가 커짐.
- 어렵게 얻은 CPU를 좀 더 오래 사용할 수 있도록 크게 설정.
- 결국 마지막 큐의 프로세스는 무한대의 타임 슬라이스를 얻음. -> 끝까지 작업을 한다는 의미.
- 마지막 큐는 FCFS 스케줄링 방식으로 동작.
- 오늘날의 OS가 CPU 스케줄링을 위해 일반적으로 사용하는 방식으로 변동 우선순위 알고리즘의 전형적인 예.
- 유닉스에서 타임 슬라이스를 고정하지 않고 100~200ms 사이로 조정할 수 있도록 한 이유가 다단계 피드백 큐 스케줄링을 사용하기 때문임.

# 05 [심화학습] 인터럽트 처리
## 1 인터럽트의 개념
- 인터럽트 처리는 입출력뿐만 아니라 시스템을 보호하는 데 매우 중요한 작업.
- 다양한 입출력 장치가 개발되어 모든 입출력을 관리하기 어려워져 이벤트 드리븐 방식과 마찬가지로 입출력 완료시 이벤트를 발생시켜 이 사실을 알림.
  + 이 방식이 인터럽트.
- 예로 컨트롤 + c, 유닉스에서 프로그램이 무한 루프를 돌고 있을 때 이를 통하여 멈추는데 이것은 사용자가 만드는 인터럽트.
- 어떤 프로세스가 실행 도중 다른 프로세스가 사용 중인 메모리 영역을 침범하면 CPU에 있는 메모리 관련 레지스터가 인터럽트 발생.
## 2 동기적 인터럽트와 비동기적 인터럽트
- 동기적 인터럽트 : 프로세스가 실행 중인 명령어로 인해 발생, 사용자 인터럽트
  + 프로그램상의 문제 때문에 발생하는 인터럽트(ex. 다른 사용자의 메모리 영역에 접근하는 경우, 오버플로나 언더플로에 의해 발생하는 경우 등)
  + 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트(ex. 컨트롤+c)
  + 입출력장치 같은 주변장치의 조작에 의한 인터럽트
  + 산술 연산 중 발생하는 인터럽트 (ex. 어떤 수를 0으로 나눔)
- 비동기적 인터럽트 : 실행 중인 명령어와 무관하게 발생.
  + 하드디스크 읽기 오류, 메모리 오류와 같은 하드웨어적인 오류로 발생하는 인터럽트
  + 사용자가 직접 작동하는 키보드 인터럽트, 마우스 인터럽트 등.
## 3 인터럽트 처리 과정
- 인터럽트는 인터럽트 번호와 함수의 쌍으로 이루어져 있음. (ex. 윈도우 최소화 버튼에는 창을 작게 만드는 함수와 특정 인터럽트 번호)
- 윈도우에서 인터럽트 번호 : IRQ -> IRQ를 이용하여 인터럽트 식별.
- 인터럽트 벡터 : 동시에 발생한 인터럽트를 하나로 묶어서 처리하는 개념, 인터럽트의 집합.
  + 인터럽트 발생 시 벡터의 번호가 0에서 1로 변화. (ex. 인터럽트 벡터의 요소 2번이 1이 되면 인터럽트 2번이 발생했다는 의미)
  + 동시에 여러 개가 1이 될 수 있음.
  + 인터럽트 벡터에는 각 인터럽트를 처리하는 함수가 연결.
    - 인터럽트 핸들러 : 해당 인터럽트 발생 시 어떤 일을 처리할 것인지가 정의 되어 있는 함수
    - 모든 인터럽트에는 기본적인 인터럽트 핸들러가 정의되어 있고 사용자가 이를 재정의 가능.
- 인터럽트 처리 과정 정리
  1. 인터럽트 발생 시 현재 실행 중인 프로세스 정지 상태, 재시작하기 위해 현재 프로세스 관련 정보를 임시 저장.
  2. 인터럽트 컨트롤러가 실행 -> 인터럽트의 처리 순서 결정. ( 이때 여러 인터럽트가 동시 발생 -> 우선순위 고려하여 순서 결정 )
  3. 인터럽트 핸들러 실행 -> 해당 인터럽트의 함수가 실행되어 인터럽트 처리.
  4. 인터럽트 핸들러 처리 종료 -> 일시 정지된 프로세스가 다시 실행되고 메모리 영역 침범이나 오류 같은 경우 종료.
## 4 인터럽트와 이중 모드
- 커널 모드 : OS와 관련된 커널 프로세스가 실행되는 상태.
- 사용자 모드 : 사용자가 실행되는 상태.
  + 사용자 프로세스가 프로세스 생성, 하드디스크 입출력과 같은 커널의 기능을 사용하려면 시스템 콜을 이용하여 커널 프로세스에 작업 요청을 해야함.
  + 사용자 프로세스는 시스템 콜을 요청 후 대기 상태로 전환되고 커널 프로세스는 요청받은 작업 처리 
    - 즉, 사용자 모드에서 커널 모드로 전환
    - 이중 모드(dual mode) : OS가 두 모드를 전환하며 일 처리하는 것.
      + 자원을 보호하기 위해 사용하는 기법. ( 사용자 프로세스가 자원에 직접 접근하면 문제가 발생할 수 있어 접근 제한 즉, 사용자 프로세스가 커널 모드에서 실행되지 못하게 함.)
- 커널이 제공하는 시스템 콜은 사용하기 어렵고 매우 제한적 -> 다양한 방법으로 시스템 콜을 사용하기 위해 OS는 API 제공.
- 사용자는 시스템 콜을 사용할 수 있고, API가 준비해놓은 다양한 함수를 이용하여 시스템 자원 접근.
- 내용 종합
  + 사용자가 커널 모드로 진입하는 경우
    - 시스템 콜을 사용한 경우
      + 자발적
    - 인터럽트를 발생시킨 경우
      + 비자발적
      + 프로세스에서 동기적 인터럽트 발생 -> 잘못된 명령 수행 -> 프로세스 강제 종료
    - 자발적으로 커널 모드에 진입할 수 있는 유일한 수단은 시스템 콜











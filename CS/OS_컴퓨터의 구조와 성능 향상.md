# CHAPTER 02 컴퓨터의 구조와 성능 향상
## 01 컴퓨터의 기본 구성
### 1 하드웨어의 구성
> 컴퓨터는 CPU, 메인 메모리, 입출력장치, 저장장치로 구성된다.  
> 컴퓨터로 하는 작업은 대부분 CPU, 메인 메모리의 협업으로 이루어져 필수 장치로 분류된다.
> 나머지는 주변 장치라고 한다.  
> 메인 메모리는 전력이 끊기면 데이터를 잃어버리기 때문에 데이터를 영구히 보관하려면 하드 디스크나 USB 메모리를 사용해야 한다. 그래서 메인 메모리는 제 1저장장치, 하드디스크나 USB 메모리 같은 메모리를 제2저장장치 또는 보조저장장치라고 부른다.

#### 1.1 CPU와 메모리
* CPU는 명령어를 해석하는 장치로 인간으로 치면 두뇌이다.
* 메모리는 필요한 프로그램과 데이터를 저장하는 장소로 바이트 단위로 분할되어 있으며 분할 공간마다 주소로 구분한다.

#### 1.2 입출력장치
* 입력장치는 외부의 데이터를 컴퓨터에 입력하는 장치 예로 키보드, 마우스 ,스캐너가 있다.
* 출력장치는 컴퓨터에서 처리한 결과를 사용자가 원하는 형태로 출력하는 장치로 프린터, 모니터, 스피커가 있다.
* 모니터는 그래픽 카드와 연결되고, 스피커는 사운드카드와 연결된다. 최근 3D 게임과 같이 많은 계싼을 필요로 하는 프로그램이 늘어남에 따라 그래픽 카드에 GPU를 달아서 직접 계산한다. GPU는 그래픽용 CPU이다.

#### 1.3 저장장치
* 저장장치는 자성을 이용하는 장치, 레이저를 이용하는 장치, 메모리를 이용하는 장치로 구분할 수 있다.
* 자성을 이용하는 장치는 카세트테이프, 플로피디스크, 하드디스크 등이 있다.
* 레이저를 이용하는 장치는 CD, DVD, 블루레이디스크 등이 있다.
* 메모리를 이용하는 장치는 USB 드라이버, SD 카드, CF 카드, SSD 등이 있다.

#### 1.4 메인보드
* 컴퓨터의 다양한 부품은 버스로 연결된다. 교통수단인 버스는 정해진 경로로 다니는데 컴퓨터의 버스도 일정한 규칙에 따라 각 장치에 데이터를 전송하는 역할을 한다. 버스는 각 장치를 연결하는 선의 집합이자 데이터가 지나다니는 통로이다.
* 메인보드는 CPU와 메모리 등 다양한 부품을 연결하는 커다란 판이다.
* 각 부품은 버스로 연결되어 있고 전력이 공급될 시 동작한다.
* 메인보드에는 각종 부품을 꽂을 수 있는 단자가 있고 이 단자에 그래픽카드, 사운드 카드, 랜카드 등이 기보능로 장착되어 있기도 하고, 성능을 위해 추가로 장착하기도 한다.

### 2 폰노이만 구조
* 오늘날의 컴퓨터는 대부분 폰노이만 구조를 따른다.
* 폰노이만 구조는 CPU, 메모리, 입출력장치, 저장장치가 버스로 연결된 구조를 말한다.
* 메모리를 이용하여 프로그래밍이 가능한 컴퓨터 구조이다. 하드웨어의 구조를 바꾸지 않고 작업을 위한 프로그램만 교체하여 메모리에 올리는 방식이다.
* 폰노이만 구조에서 가장 중요한 특징은 모든 프로그램은 메모리에 올라와야 실행할 수 있다는 것이다.
* 예를 들어 워드로 보고서를 작성했다고 가정해보자. 워드와 보고서 파일은 저장장치에 저장되지만 이것들이 저장장치에서 바로 실행되지 않는다.
* 저장장치에 있는 프로그램을 실행하려면 프로그램이 메모리에 올라와야 하며, OS도 프로그램이기에 메모리에 올라와야 실행이 가능하다.

### 3. 요리사 모형
* OS의 여러 가지 현상에 대한 이해를 돕기 위함이다.
* 요리사 = CPU, 도마 = 메모리, 보관 창고 = 저장장치, 주방 보조 = 보관 창고에 있는 재료를 도마로 옮김, 보조 요리사 = 채소를 다듬거나 고기를 손질
* 요리사가 보관창고에 있는 재료를 도마로 가져온다. 도마가 핵심적인 작업 공간이고 보관 창고는 보조적인 공간이다.
* 요리 방법을 결정하는 것은 CPU가 작업을 진행하는 것(프로세스 관리), 도마 위의 재료를 정리하는 것은 여러 프로그램이 사용하는 메모리를 관리하는 것(메모리 관리), 보관 창고의 재료를 정리하는 것은 저장장치 내의 데이터를 관리하는 것(저장장치 관리)에 비유된다.
* 모든 조건이 동일하다면 메모리가 1GB인 컴퓨터는 4GB인 컴퓨터보다 느리다. 이는 요리속도도 중요하지만 도마의 크기도 중요하다는 것이다. 도마가 작으면 올라올 수 있는 재료가 적어지고 그럼 재료를 자주 가지고 와야하는데 그때도 시간이 걸린다. 그러면 작업 속도가 느려진다.
* 만약 도마의 크기가 전체 재료를 놓을 수 있을 정도로 충분히 크다면 작업 속도에 영향을 끼치지 않는다.
* 예를 들어 메모리가 20GB인 컴터와 40GB인 컴터는 크게 속도가 차이 나지 않는다. 그 이유는 이미 재료를 전부 다 올렸으니까 속도차이가 미미하다.
* 또한 보관 창고의 크기는 작업 속도에 영향을 미치지 않는다.

### 4. 하드웨어 사양 관련 용어
1. 클록
  * 클록은 CPU의 속도와 관련된 단위
  * 밴드가 연주 시 박자가 맞아야 연주가 되듯이 CPU도 작업 시 일정 박자가 있다. 이것을 만들어 내는 것이 클록이다.
  * 클록이 일정 간격으로 틱을 민들면 거기에 맞춰 CPU안의 모든 구성 부붐이 일을 한다.
  * 틱은 펄스 or 클록틱이라고도 부른다. 버스에는 여러 개의 부품이 연결되어 있는데, 메인보드의 클록이 틱을 보낼 때마다 데이터를 보내거나 받는다.
2. 헤르츠
  * 헤르츠는 클록틱이 발생하는 속도를 나타내는 단위
  * 1초에 클록틱이 몇번 발생했는가를 나타낸다. 1초에 1번이면 1Hz, 1000번이면 1000Hz
<img src="https://user-images.githubusercontent.com/78334910/147907531-7fff7073-cb2f-4815-ade7-eacdf536deb1.PNG">
  * 위 사진을 보면 내 노트북의 사양이다. CPU의 제품명이 나와있고 2.1GHz라고 적혀있는데 이것은 1초에 2.1 x 10^9번 클록틱이 발생한다는 말이다. 그럼 1초에 최대 21억번의 연산(작업)을 할 수 있음을 의미한다.
  * 버스도 클록틱에 맞춰 데이터를 전송해서 메인보드의 성능도 클록으로 표시한다.( 찾아봤는데 어디 표시되는 지는 잘모르겠음. 일반적으로 메모리와 속도가 같은 것 같다.)
3. 시스템 버스와 CPU 내부 버스
  * 시스템 버스는 메모리와 주변 장치를 연결하는 버스로 FSB(Front-Side Bus)라고 부르며 1,333MHz의 시스템 버스를 가진 메인보드에는 1,333MHz의 버스를 가진 부품을 연결해야 한다. 아니면 병목 현상땜에 느린 그 속도로 작업을 수행한다.
  * CPU 내부 버스는 CPU 내부 장치를 연결하고 BSB(Back-Side Bus)라고 불리며 CPU의 클락 속도랑 같다.
  * CPU는 내부 버스 속도로 작동하고 메모리는 시스템 버스 속도로 작동해서 두 버스의 속도 차이로 인해 작업이 지연되는 문제가 있다.

< 기억 용량 단위 >
> 바이트는 저장 장치의 기억 용량을 나타내는 단위 가운데 하나이고 바이트는 정확히 2^10씩 단위가 올라간다.
* 1B(1바이트) = 1byte
* 1KB(1킬로바이트) = 2^10byte
* 1MB(1메가바이트) = 2^20byte
* 1GB(1기가바이트) = 2^30byte
* 1TB(1테라바이트) = 2^40byte

## 02 CPU와 메모리
### 1 CPU의 구성과 동작
#### 1.1 CPU의 기본 구성
* CPU는 요리사 모형에서 요리사에 해당한다.
* CPU는 산술논리 연산장치, 제어장치, 레지스터로 구성되며, 이것들의 협업으로 작업을 처리한다.
* 요리 = 산술논리 연산장치, 작업 지시 = 제어장치, 재료 임시 보관 = 레지스터 로 비유할 수 있다.

1. 산술논리 연산자
  * CPU에서 데이터를 연산하는 장치
  * 데이터의 덧셈, 뺄셈, 곱셈, 나눈셈 같은 산술 연산과 AND, OR 같은 논리 연산을 수행한다.
2. 제어장치
  * 요리를 할때 요리사는 머리속에서 도마위에 재료를 올려라, 다 된 요리를 접시에 올려라와 같은 지시가 이루어진다.
  * 이처럼 CPU에서 작업 지시를 하는 부분이 제어장치이다.
3. 레지스터
  * 그날 쓸 재료를 미리 손질해놓았다면 요리를 할 때 필요한 만큼 쥐어 냄비에 넣는다. 재료를 필요한 만큼 쥐고 있는 것처럼 CPU 내에 데이터를 임시로 보관하는 곳을 레지스터라고 한다.

#### 1.2 CPU의 명령어 처리 과정
```c
int D2=2, D3=3, sum;
sum = D2+D3;
```
D2, D3, sum은 데이터를 저장할 수 있는 메모리 주소의 다른 이름으로, 메모리 주소를 외우기가 어렵기 때문에 주소 대신 적당한 이름을 만들어 붙인 것이다. ( 이수영 - 010-1234-5678 번호 저장과 같다 )

위의 코드를 어셈블리어로 변환하면
```
LOAD mem(100), register 2;
LOAD mem(120), register 3;
ADD register 5, register 2, register 3;
MOVE register 5, mem(160)
```
메모리는 이렇게 할당되어 있다 가정하자.
CPU가 연산을 하기 위해서는 레지스터에 임시로 필요한 데이터를 보관해야한다.
그래서 100, 120 메모리에 있는 값을 레지스터 2, 3으로 가져오라는 말이다. 이러면 모든 필요한 모든 데이터가 레지스터에 준비되어 있고 산술논리 연산 장치를 이용하여 두 값을 더해서 레지스터 5에 저장하고 그걸 메모리 160으로 옮기면 된다.
제어장치는 명령어를 해석하여 제어 신호를 보내고 CPU 내의 데이터 흐름을 조절하는 역할을 한다.
위의 예에서 제어장치는 '메모리에서 데이터를 가져와라', '덧셈을 실행해라', 덧셈한 결과값을 메모리로 옮겨라'라고 신호를 보낸다.
<img src="https://user-images.githubusercontent.com/78334910/147910282-877bd2ae-d775-4084-8ae8-79f84b0aed3a.PNG">

#### 1.3 레지스터의 종류
위의 과정에서 사용되는 레지스터의 종류는 데이터 레지스터, 주소 레지스터이다.
이 두 레지스터는 사용자 프로그램에 의해 변경되기 때문에 사용자 가시 레지스터라고 부른다.
* 데이터 레지스터(DR) : 메모리에서 가져온 데이터를 임시로 보관할 때 사용한다. CPU에 있는 대부분의 레지스터가 데이터 레지스터이기 때문에 일반 레지스터 또는 범용 레지스터라고 부른다.
* 주소 레지스터(AR) : 데이터 또는 명령어가 저장된 메모리의 주소는 주소 레지스터에 저장된다.

이외에 특별한 용도로 사용되는 레지스터가 있는데 이를 특수 레지스터라고 한다. 이는 사용자가 임의로 변경할 수 없기 때문에 사용자 불가시 레지스터라고 부른다.
* 프로그램 카운터(PC) : CPU는 다음에 어떤 명령어를 처리해야 할지 알아야 한다. PC는 다음에 실행할 명령어의 주소를 기억하고 있다가 제어장치에 알려준다. 다음에 실행할 명령어의 주소를 가리키기 때문에 프로그램 카운터를 명령어 포인터라고도 한다.
* 명령어 레지스터(IR): 현재 실행 중인 명령어를 저장한다. 제어장치는 명령어 레지스터에 있는 명령을 해석한 후 외부 장치에 적절한 제어 신호를 보낸다.
* 메모리 주소 레지스터(MAR): MAR은 메모리에서 데이터를 가져오거나 반대로 메모리에서 데이터를 보낼 때 주소를 지정하기 위해 사용한다. 명령어를 처리하는 과정에서 필요한 메모리 주소를 이 레지스터에 넣으면 메모리 관리자가 이를 인식하여 해당 메모리 위치의 데이터를 가져오거나 해당 메모리 위치에 데이터를 저장한다.
* 메모리 버퍼 레지스터(MBR): MBR은 메모리에서 가져온 데이터나 메모리로 옮겨 갈 데이터를 임시로 저장한다. MBR은 MAR과 항상 함꼐 동작한다.

1. PC에는 현재 실행 중인 코드의 행번호 1이 저장되고 이 번호는 제어장치에 전송된다. IR에는 'LOAD mem(100), register 2;의 LOAD가 탑재된다.
2. 제어장치가 IR에 있는 명령을 해석하여 메모리에 있는 데이터를 가져오라는 제어 신호를 보낸다.
3. MAR에는 100이저장되고 메모리 관리자는 메모리의 100번지에 저장된 값을 MBR로 가져온다.
4. 제어장치는 MBR에 저장된 값을 레지스터 2로 옮긴다.

이외에도 CPU가 사용하는 레지스터는 아주 많다. 그중 프로그램 상태 레지스터(PSR)는 산술논리 연산장치와 연결되어 있으며 연산 결과가 양수인지, 음수인지, 0이 아닌지 또는 자리 올림의 유무 등을 저장한다. 이는 플래그 레지스터, 상태 레지스터, 컨디션 레지스터라고도 불린다.
'''c
if (D2-D3 > 0)
    goto 100;
else
    goto 200;
'''
위 코드에서 D2-D3는 if 문장의 분기 조건이라 다음 연산 순서에 영향을 미친다.
PSR은 D2-D3의 결과를 저장하고 있다가 음수인지 양수인지를 제어장치에 알려주어 몇번 행으로 이동할지를 결정한다.


#### 1.4 버스의 종류
* 버스는 CPU와 메모리, 주변장치 간에 데이터를 주고받을 때 사용한다.
* 다음 작업을 지시하는 제어 신호, 메모리의 위치 정보를 알려주는 주소, 처리할 데이터가 오고 가며 각각 제어 버스, 주소 버스, 데이터 버스에 실린다.
<img src="https://user-images.githubusercontent.com/78334910/147911841-b266adb5-ab16-4872-ad9d-9376c40b2b9d.png">

1. 제어 버스
  * 다음에 어떤 작업을 할지 지시하는 제어 신호가 오고 간다.
  * 메모리에서 데이터를 가져올지(읽기 신호) 아니면 데이터를 옮겨놓을지(쓰기 신호)
  * 주변 장치도 마찬가지로 명령을 내릴 때 제어 버스를 통해 전달된다.
  * 메모리에서 오류가 발생하거나 네트워크 카드에 데이터가 모두 도착했다는 신호는 모두 제어 버스를 통해 CPU로 전달된다.
  * 제어버스의 신호는 CPU, 메모리, 주변장치와 양방향으로 오고 간다.
2. 주소 버스
  * 메모리의 데이터를 읽거나 쓸 때 어느 위치에서 작업할 것인지를 알려주는 위치 정보(주소)가 오고 간다.
  * 메모리 주소 레지스터(MAR)과 연결되어 있으며 단방향이다.
  * CPU에서 메모리나 주변장치로 나가는 주소 정보는 있지만 주소 버스를 통해 CPU로 전달되는 정보는 없다.
3. 데이터 버스
  * 데이터가 이동하는 버스
  * 메모리 버퍼 레지스터와 연결되어 있으며 양방향이다.

버스의 대역폭은 한 번에 전달할 수 있는 데이터의 최대 크기를 말한다.
4차선 도로는 한 번에 4대의 차가 동시에 다닐 수 있듯이 대역폭만큼 데이터가 오고 갈 수 있다.
버스의 대역폭은 CPU가 한 번에 처리할 수 있는 데이터의 크기이고 32bit CPU, 64bit CPU 여기서 bit 수를 말한다.
메모리에서 데이터를 읽거나 쓸 때 한번에 최대 32bit를 처리할 수 있다는 의미이다. 이 경우 레지스터의 크기도 32bit이고 버스의 대역폭도 32bit이다. 버스의 대역폭, 레지스터의 크기, 메모리에 한 번에 저장할 수 있는 데이터의 크기는 항상 같다. CPU가 한 번에 처리할 수 있는 데이터의 최대 크기를 워드 word라고 하며, 버스의 대역폭과 메모리에 한 번에 저장되는 단위도 워드이다. 32bit CPU에서 1워드는 32bit이다.

### 2 메모리의 종류와 부팅
* 모든 프로그램은 메모리에 올라와야 실행될 수 있다.
* 메모리에는 실행에 필요한 프로그램과 데이터가 존재하며, CPU와 협업하여 작업이 이루어진다.
* 메모리를 이루는 소자 하나의 크기는 1bit로 0 또는 1이 저장된다. 그러나 소자 하나만으로 데이터를 표현할 수 없어 메모리 주소는 바이트 단위로 지정되고, 메모리에서 데이터를 읽거나 쓸 때는 워드 단위로 움직인다.

#### 2.1 메모리의 종류
* 읽거나 쓸 수 있는 램 RAM과 읽기만 가능한 ROM으로 구분된다.
* RAM은 무작위로 데이터를 읽어도 저장된 위치와 상관없이 같은 속도로 데이터를 읽을 수 있다는 의미에서 붙은 이름이다.
<img src="https://user-images.githubusercontent.com/78334910/147918003-624cdd89-f527-46c4-8a0d-fbeaaf31927b.png">

* RAM은 전력이 끊기면 데이터가 사라지는 휘발성 메모리와 전력이 끊겨도 데이터를 보관할 수 있는 비휘발성 메모리로 나뉜다.
  * 휘발성 메모리
    * DRAM(Dynamic RAM)과 SRAM(Static RAM)이 있다.
    * DRAM은 저장된 0과 1의데이터가 일정 시간이 지나면 사라지므로 일정 시간마다 다시 재생시켜야 한다. 'Dynamic'은 시간이 지나면 데이터가 사라지기 떄문에 재생이 필요하다는 의미이다.
    * SRAM은 전력이 공급되는 동안에는 데이터를 보관할 수 있어 재생할 필요가 없다.
    * 따라서 속도는 빠르지만 가격이 비싸다.
    * 일반적으로 메인 메모리에는 DRAM을 사용하고, 캐시 같은 고속 메모리에는 SRAM을 사용한다.
    * SDRAM은 DRAM이 발전된 형태로 SRAM과는 완전히 다른 종류의 RAM이다. 클록틱이 발생할 때마다 데이터를 저장하는 동기 DRAM이다.
    * 메인 메모리를 비휘발성 메모리로 만들면 전력이 끊겨도 내용이 남아 편리할 수도 있지만 비휘발성 메모리는 전력이 끊겨도 데이터를 보관해야 하므로 메모리 내부가 복잡하고 속도가 느리며 가격이 비싸다. 
  * 비휘발성 메모리
    * 플래시 메모리, FRAM(Ferroelectric RAM), PRAM(Phase change RAM) 등이 있다.
    * 플래시 메모리는 디지털카메라, MP3 플레이어, USB 드라이버같이 전력이 없어도 데이터를 보관하는 저장장치로 많이 사용된다.
    * 그런데 각 소자의 최대 사용 횟수가 제한되어 많이 사용하면 제 기능을 잃는다. SD 카드나 USB 드라이버를 오래 사용하면 성능이 저하되거나 데이터를 잃어버릴 수 있으니 주의해야한다.
    * SSD는 하드디스크를 대신하도록 만들어졌다. 가격이 비싸지만 빠른 데이터 접근 속도, 저전력, 내구성 때문에 개인용 컴퓨터는 물론 노트북, 스마트폰 등 많은 기기에 사용되고 있다.

* ROM은 전력이 끊겨도 데이터를 보관하지만 데이터를 한 번 저장하면 바꿀 수 없다.
* 예를 들면 CD-ROM과 같다. 이러한 특성 때문에 BIOS를 ROM에 저장한다.
* ROM의 종류에는 데이터를 지우거나 쓸 수 없는 마스크 롬, 전용 기계를 이용하여 데이터를 한 번만 저장할 수 있는 PROM(Programmable ROM), 데이터를 여러 번 쓰고 지울 수 있는 EPROM(Erasable Programmable ROM)이 있다.
* EPROM은 플래시 메모리처럼 사용할 수 있지만 가격이 비싸서 잘 사용하지 않는다.

< DDR SDRAM >
* CPU는 3GHz 이상의 빠른 속도로 동작하는데 SDRAM은 메인보드의 시스템 버스와 같은 속도로 느리게 작동하여 전반적인 작업 속도를 떨어뜨리는 문제가 있다.
* 이러한 속도 차이를 완화하기 위해 SDRAM의 대역폭을 늘려 데이터 입출력 속도를 빠르게 한 것이 DDR(Double Data Rate) SDRAM이다.
* 기존의 SDRAM이 클록틱 한 번에 1개의 워드를 저장하는 반면에 DDR SDRAM은 클록틱 한 번에 2개의 워드를 저장한다.
* 기존 SDRAM은 SDR(Single Data Rate) SDRAM 라고 부를 수 있다.
* DDR2 SDRAM은 DDR SDRAM보다 대역폭이 2배 더 크고 SDR SDRAM보다 4배 더 크다.
* 현재는 DDR4 까지 보급되고 있다.

#### 2.2 메모리 보호
* 일괄 작업 시스템에서는 메모리가 운영체제 영역과 사용자 영역으로 구분되었다.
* 현대의 OS는 시분할 기법을 사용하여 여러 프로그램을 동시에 실행하여 사용자 영역이 여러개의 작업 공간으로 나뉘어 있다.
* 이런 상황에서 메모리 보호는 매우 중요하다.
* 메모리 보호가 되지 않으면 어떤 작업이 다른 작업의 영역을 침범하여 프로그램을 파괴하거나 데이터를 지울 수도 있으며, 최악의 경우 OS 영역을 침범하면 시스템이 멈출 수도 있다.
* 이처럼 OS 영역이나 다른 프로그램 영역으로 침범하려는 악성 소프트웨어를 바이러스라고 한다.
* OS도 소프트웨어 이라서 CPU를 사용하는 작업 중 하나이다. 그래서 사용자 프로세스가 CPU 차지하는 동안에는 OS의 작업이 잠시 중단된다.
* 이때 메모리를 보호하려면 하드웨어의 도움이 필요하다.
* CPU는 현재 진행 중인 작업의 메모리 시작 주소를 경계 레지스터(bound register)에 저장한 후 작업을 한다. 또한 현재 진행 중인 작업이 차지하고 있는 메모리의 크기, 즉 마지막 주소까지의 차이를 한계 레지스터(limit register)에 저장한다.
그리고 사용자의 작업이 진행되는 동안 이 두 레지스터의 주소 범위를 벗어나는지 하드웨어적으로 점검함으로써 메모리를 보호한다.
<img src="https://user-images.githubusercontent.com/78334910/147920912-c2a5a1ec-4b8c-44b4-98a8-6112e7904a6b.PNG">

* B작업이 데이터를 읽거나 쓸 때마다 CPU는 해당 작업이 경계 레지스터와 한계 레지스터 주소값 안에서 이루어지는지 검사한다.
* 만약 두 레지스터의 값을 벗어난다면 메모리 오류와 관련된 인터럽트가 발생한다. 인터럽트가 발생하면 모든 작업이 중단되고 CPU는 OS를 깨워서 인터럽트를 처리하도록 시킨다. 메모리 영역을 벗어나서 발생한 인터럽트의 경우 OS가 해당 프로그램을 강제 종료시킨다. 
* 이처럼 모든 메모리 영역은 하드웨어와 OS의 협업에 의해 보호받는다.

#### 2.3 부팅
* 응용 프로그램은 OS가 메모리에 올려서 실행하는데 OS는 누가 메모리에 올려서 실행시킬까?
* 컴퓨터를 켰을 때 누군가 메모리에 OS를 올린다. 컴퓨터가 켜질 때 OS를 메모리에 올리는 과정을 부팅이라고 한다.
<img src="https://user-images.githubusercontent.com/78334910/147921508-caa06d89-ea24-40e7-9346-2c7b58dde5d2.png">

1. 사용자가 컴퓨터에 전원을 켜면 ROM에 저장된 BIOS가 실행된다. 
2. BIOS는 CPU, 메모리, 하드디스크, 키보드, 마우스와 같은 주요 하드웨어가 제대로 작동하는지 확인한다. 만약 이상이 있으면 경고음과 함께 오류 메시지를 출력하고, 이상이 없으면 하드디스크의 마스터 부트 레코드 (Master Boot Record, MBR)에 저장된 작은 프로그램을 메모리로 가져와 실행한다.
  * Master Boot Record(MBR) : 하드디스크의 첫 번째 섹터를 가리키며, OS를 실행하기 위한 코드인 bootstrap이 이곳에 저장되어 있다.
  * Boostrap 코드는 OS를 메모리로 가져와 실행하는 역할을 하는 작은 프로그램이다.
  * BIOS(Basic Input/Output System) : 운영 체제가 다양한 컴퓨터를 지원하기 쉽게 개량하면서 만들어졌다. 컴퓨터 소프트웨어의 최저층에 존재하며, 부팅 전 하드웨어를 한 번 초기화하여 사용을 준비하게 하고, 소프트웨어가 하드웨어를 제어하고, 하드웨어가 소프트웨어에 변경된 정보를 전달하는 등 소프트웨어와 하드웨어 간의 설정 및 정보 전달의 매개 역할을 하는 컴퓨터의 펌웨어이다.

요즘은 USB 드라이버에도 마스터 부트 레코드를 탑재할 수 있다.
마스터 부트 레코드에 있는 부트스트랩이 메모리에 올라오면 하드디스크에 저장된 OS를 메모리로 불러온다. 따라서 MBR이 손상되면 OS 실행이 불가능하다.
이는 컴퓨터 바이러스의 좋은 공격 대상이 되낟. 일부 바이오스는 사용자 옵션 부분에 OS 보호 항목을 만들어 마스터 부트 레코드를 수정할 수 없게 한다. 만약 새로운 OS를 다시 설치한다면 이 OS 보호 옵션을 해제해야 한다.

한 컴퓨터에 OS 2개를 설치해보면 bootstrap을 확일할 수 있다. 이 경우 바이오스가 하드웨어 점검을 마치고 마스터 부트 레코드에서 부트스트랩을 가져와 실행하면 어떤 OS로 사용할 것인지 물어보는 화면이 나타난다. 이 화면이 부트스트랩 코드가 실행된 화면이다. 하나의 OS가 설치된 컴퓨터의 부트스트랩이라면 이러한 과정 없이 바로 OS를 메모리에 올린다.

< OS의 저장 위치 변화 >
* 최초의 개인용 컴퓨터가 나왔을땐 카세트테이프가 주된 저장장치였다.
* 그다음은 플로피 디스크 그래서 DOS (Disk Operating System)이란 말이 생겼다.
* 이후 하드디스크에 OS가 담기고 ROM에 바이오스를 저장하게 되었다.






    
































# CHAPTER 02 컴퓨터의 구조와 성능 향상
## 01 컴퓨터의 기본 구성
### 1 하드웨어의 구성
> 컴퓨터는 CPU, 메인 메모리, 입출력장치, 저장장치로 구성된다.  
> 컴퓨터로 하는 작업은 대부분 CPU, 메인 메모리의 협업으로 이루어져 필수 장치로 분류된다.
> 나머지는 주변 장치라고 한다.  
> 메인 메모리는 전력이 끊기면 데이터를 잃어버리기 때문에 데이터를 영구히 보관하려면 하드 디스크나 USB 메모리를 사용해야 한다. 그래서 메인 메모리는 제 1저장장치, 하드디스크나 USB 메모리 같은 메모리를 제2저장장치 또는 보조저장장치라고 부른다.

#### 1.1 CPU와 메모리
* CPU는 명령어를 해석하는 장치로 인간으로 치면 두뇌이다.
* 메모리는 필요한 프로그램과 데이터를 저장하는 장소로 바이트 단위로 분할되어 있으며 분할 공간마다 주소로 구분한다.

#### 1.2 입출력장치
* 입력장치는 외부의 데이터를 컴퓨터에 입력하는 장치 예로 키보드, 마우스 ,스캐너가 있다.
* 출력장치는 컴퓨터에서 처리한 결과를 사용자가 원하는 형태로 출력하는 장치로 프린터, 모니터, 스피커가 있다.
* 모니터는 그래픽 카드와 연결되고, 스피커는 사운드카드와 연결된다. 최근 3D 게임과 같이 많은 계싼을 필요로 하는 프로그램이 늘어남에 따라 그래픽 카드에 GPU를 달아서 직접 계산한다. GPU는 그래픽용 CPU이다.

#### 1.3 저장장치
* 저장장치는 자성을 이용하는 장치, 레이저를 이용하는 장치, 메모리를 이용하는 장치로 구분할 수 있다.
* 자성을 이용하는 장치는 카세트테이프, 플로피디스크, 하드디스크 등이 있다.
* 레이저를 이용하는 장치는 CD, DVD, 블루레이디스크 등이 있다.
* 메모리를 이용하는 장치는 USB 드라이버, SD 카드, CF 카드, SSD 등이 있다.

#### 1.4 메인보드
* 컴퓨터의 다양한 부품은 버스로 연결된다. 교통수단인 버스는 정해진 경로로 다니는데 컴퓨터의 버스도 일정한 규칙에 따라 각 장치에 데이터를 전송하는 역할을 한다. 버스는 각 장치를 연결하는 선의 집합이자 데이터가 지나다니는 통로이다.
* 메인보드는 CPU와 메모리 등 다양한 부품을 연결하는 커다란 판이다.
* 각 부품은 버스로 연결되어 있고 전력이 공급될 시 동작한다.
* 메인보드에는 각종 부품을 꽂을 수 있는 단자가 있고 이 단자에 그래픽카드, 사운드 카드, 랜카드 등이 기보능로 장착되어 있기도 하고, 성능을 위해 추가로 장착하기도 한다.

### 2 폰노이만 구조
* 오늘날의 컴퓨터는 대부분 폰노이만 구조를 따른다.
* 폰노이만 구조는 CPU, 메모리, 입출력장치, 저장장치가 버스로 연결된 구조를 말한다.
* 메모리를 이용하여 프로그래밍이 가능한 컴퓨터 구조이다. 하드웨어의 구조를 바꾸지 않고 작업을 위한 프로그램만 교체하여 메모리에 올리는 방식이다.
* 폰노이만 구조에서 가장 중요한 특징은 모든 프로그램은 메모리에 올라와야 실행할 수 있다는 것이다.
* 예를 들어 워드로 보고서를 작성했다고 가정해보자. 워드와 보고서 파일은 저장장치에 저장되지만 이것들이 저장장치에서 바로 실행되지 않는다.
* 저장장치에 있는 프로그램을 실행하려면 프로그램이 메모리에 올라와야 하며, OS도 프로그램이기에 메모리에 올라와야 실행이 가능하다.

### 3. 요리사 모형
* OS의 여러 가지 현상에 대한 이해를 돕기 위함이다.
* 요리사 = CPU, 도마 = 메모리, 보관 창고 = 저장장치, 주방 보조 = 보관 창고에 있는 재료를 도마로 옮김, 보조 요리사 = 채소를 다듬거나 고기를 손질
* 요리사가 보관창고에 있는 재료를 도마로 가져온다. 도마가 핵심적인 작업 공간이고 보관 창고는 보조적인 공간이다.
* 요리 방법을 결정하는 것은 CPU가 작업을 진행하는 것(프로세스 관리), 도마 위의 재료를 정리하는 것은 여러 프로그램이 사용하는 메모리를 관리하는 것(메모리 관리), 보관 창고의 재료를 정리하는 것은 저장장치 내의 데이터를 관리하는 것(저장장치 관리)에 비유된다.
* 모든 조건이 동일하다면 메모리가 1GB인 컴퓨터는 4GB인 컴퓨터보다 느리다. 이는 요리속도도 중요하지만 도마의 크기도 중요하다는 것이다. 도마가 작으면 올라올 수 있는 재료가 적어지고 그럼 재료를 자주 가지고 와야하는데 그때도 시간이 걸린다. 그러면 작업 속도가 느려진다.
* 만약 도마의 크기가 전체 재료를 놓을 수 있을 정도로 충분히 크다면 작업 속도에 영향을 끼치지 않는다.
* 예를 들어 메모리가 20GB인 컴터와 40GB인 컴터는 크게 속도가 차이 나지 않는다. 그 이유는 이미 재료를 전부 다 올렸으니까 속도차이가 미미하다.
* 또한 보관 창고의 크기는 작업 속도에 영향을 미치지 않는다.

### 4. 하드웨어 사양 관련 용어
1. 클록
  * 클록은 CPU의 속도와 관련된 단위
  * 밴드가 연주 시 박자가 맞아야 연주가 되듯이 CPU도 작업 시 일정 박자가 있다. 이것을 만들어 내는 것이 클록이다.
  * 클록이 일정 간격으로 틱을 민들면 거기에 맞춰 CPU안의 모든 구성 부붐이 일을 한다.
  * 틱은 펄스 or 클록틱이라고도 부른다. 버스에는 여러 개의 부품이 연결되어 있는데, 메인보드의 클록이 틱을 보낼 때마다 데이터를 보내거나 받는다.
2. 헤르츠
  * 헤르츠는 클록틱이 발생하는 속도를 나타내는 단위
  * 1초에 클록틱이 몇번 발생했는가를 나타낸다. 1초에 1번이면 1Hz, 1000번이면 1000Hz
<img src="https://user-images.githubusercontent.com/78334910/147907531-7fff7073-cb2f-4815-ade7-eacdf536deb1.PNG">
  * 위 사진을 보면 내 노트북의 사양이다. CPU의 제품명이 나와있고 2.1GHz라고 적혀있는데 이것은 1초에 2.1 x 10^9번 클록틱이 발생한다는 말이다. 그럼 1초에 최대 21억번의 연산(작업)을 할 수 있음을 의미한다.
  * 버스도 클록틱에 맞춰 데이터를 전송해서 메인보드의 성능도 클록으로 표시한다.( 찾아봤는데 어디 표시되는 지는 잘모르겠음. 일반적으로 메모리와 속도가 같은 것 같다.)
3. 시스템 버스와 CPU 내부 버스
  * 시스템 버스는 메모리와 주변 장치를 연결하는 버스로 FSB(Front-Side Bus)라고 부르며 1,333MHz의 시스템 버스를 가진 메인보드에는 1,333MHz의 버스를 가진 부품을 연결해야 한다. 아니면 병목 현상땜에 느린 그 속도로 작업을 수행한다.
  * CPU 내부 버스는 CPU 내부 장치를 연결하고 BSB(Back-Side Bus)라고 불리며 CPU의 클락 속도랑 같다.
  * CPU는 내부 버스 속도로 작동하고 메모리는 시스템 버스 속도로 작동해서 두 버스의 속도 차이로 인해 작업이 지연되는 문제가 있다.

< 기억 용량 단위 >
> 바이트는 저장 장치의 기억 용량을 나타내는 단위 가운데 하나이고 바이트는 정확히 2^10씩 단위가 올라간다.
* 1B(1바이트) = 1byte
* 1KB(1킬로바이트) = 2^10byte
* 1MB(1메가바이트) = 2^20byte
* 1GB(1기가바이트) = 2^30byte
* 1TB(1테라바이트) = 2^40byte

## 02 CPU와 메모리
### 1 CPU의 구성과 동작
#### 1.1 CPU의 기본 구성
* CPU는 요리사 모형에서 요리사에 해당한다.
* CPU는 산술논리 연산장치, 제어장치, 레지스터로 구성되며, 이것들의 협업으로 작업을 처리한다.
* 요리 = 산술논리 연산장치, 작업 지시 = 제어장치, 재료 임시 보관 = 레지스터 로 비유할 수 있다.

1. 산술논리 연산자
  * CPU에서 데이터를 연산하는 장치
  * 데이터의 덧셈, 뺄셈, 곱셈, 나눈셈 같은 산술 연산과 AND, OR 같은 논리 연산을 수행한다.
2. 제어장치
  * 요리를 할때 요리사는 머리속에서 도마위에 재료를 올려라, 다 된 요리를 접시에 올려라와 같은 지시가 이루어진다.
  * 이처럼 CPU에서 작업 지시를 하는 부분이 제어장치이다.
3. 레지스터
  * 그날 쓸 재료를 미리 손질해놓았다면 요리를 할 때 필요한 만큼 쥐어 냄비에 넣는다. 재료를 필요한 만큼 쥐고 있는 것처럼 CPU 내에 데이터를 임시로 보관하는 곳을 레지스터라고 한다.

#### 1.2 CPU의 명령어 처리 과정
```c
int D2=2, D3=3, sum;
sum = D2+D3;
```
D2, D3, sum은 데이터를 저장할 수 있는 메모리 주소의 다른 이름으로, 메모리 주소를 외우기가 어렵기 때문에 주소 대신 적당한 이름을 만들어 붙인 것이다. ( 이수영 - 010-1234-5678 번호 저장과 같다 )

위의 코드를 어셈블리어로 변환하면
```
LOAD mem(100), register 2;
LOAD mem(120), register 3;
ADD register 5, register 2, register 3;
MOVE register 5, mem(160)
```
메모리는 이렇게 할당되어 있다 가정하자.
CPU가 연산을 하기 위해서는 레지스터에 임시로 필요한 데이터를 보관해야한다.
그래서 100, 120 메모리에 있는 값을 레지스터 2, 3으로 가져오라는 말이다. 이러면 모든 필요한 모든 데이터가 레지스터에 준비되어 있고 산술논리 연산 장치를 이용하여 두 값을 더해서 레지스터 5에 저장하고 그걸 메모리 160으로 옮기면 된다.
제어장치는 명령어를 해석하여 제어 신호를 보내고 CPU 내의 데이터 흐름을 조절하는 역할을 한다.
위의 예에서 제어장치는 '메모리에서 데이터를 가져와라', '덧셈을 실행해라', 덧셈한 결과값을 메모리로 옮겨라'라고 신호를 보낸다.
<img src="https://user-images.githubusercontent.com/78334910/147910282-877bd2ae-d775-4084-8ae8-79f84b0aed3a.PNG">

#### 1.3 레지스터의 종류
위의 과정에서 사용되는 레지스터의 종류는 데이터 레지스터, 주소 레지스터이다.
이 두 레지스터는 사용자 프로그램에 의해 변경되기 때문에 사용자 가시 레지스터라고 부른다.
* 데이터 레지스터(DR) : 메모리에서 가져온 데이터를 임시로 보관할 때 사용한다. CPU에 있는 대부분의 레지스터가 데이터 레지스터이기 때문에 일반 레지스터 또는 범용 레지스터라고 부른다.
* 주소 레지스터(AR) : 데이터 또는 명령어가 저장된 메모리의 주소는 주소 레지스터에 저장된다.

이외에 특별한 용도로 사용되는 레지스터가 있는데 이를 특수 레지스터라고 한다. 이는 사용자가 임의로 변경할 수 없기 때문에 사용자 불가시 레지스터라고 부른다.
* 프로그램 카운터(PC) : CPU는 다음에 어떤 명령어를 처리해야 할지 알아야 한다. PC는 다음에 실행할 명령어의 주소를 기억하고 있다가 제어장치에 알려준다. 다음에 실행할 명령어의 주소를 가리키기 때문에 프로그램 카운터를 명령어 포인터라고도 한다.
* 명령어 레지스터(IR): 현재 실행 중인 명령어를 저장한다. 제어장치는 명령어 레지스터에 있는 명령을 해석한 후 외부 장치에 적절한 제어 신호를 보낸다.
* 메모리 주소 레지스터(MAR): MAR은 메모리에서 데이터를 가져오거나 반대로 메모리에서 데이터를 보낼 때 주소를 지정하기 위해 사용한다. 명령어를 처리하는 과정에서 필요한 메모리 주소를 이 레지스터에 넣으면 메모리 관리자가 이를 인식하여 해당 메모리 위치의 데이터를 가져오거나 해당 메모리 위치에 데이터를 저장한다.
* 메모리 버퍼 레지스터(MBR): MBR은 메모리에서 가져온 데이터나 메모리로 옮겨 갈 데이터를 임시로 저장한다. MBR은 MAR과 항상 함꼐 동작한다.

1. PC에는 현재 실행 중인 코드의 행번호 1이 저장되고 이 번호는 제어장치에 전송된다. IR에는 'LOAD mem(100), register 2;의 LOAD가 탑재된다.
2. 제어장치가 IR에 있는 명령을 해석하여 메모리에 있는 데이터를 가져오라는 제어 신호를 보낸다.
3. MAR에는 100이저장되고 메모리 관리자는 메모리의 100번지에 저장된 값을 MBR로 가져온다.
4. 제어장치는 MBR에 저장된 값을 레지스터 2로 옮긴다.

이외에도 CPU가 사용하는 레지스터는 아주 많다. 그중 프로그램 상태 레지스터(PSR)는 산술논리 연산장치와 연결되어 있으며 연산 결과가 양수인지, 음수인지, 0이 아닌지 또는 자리 올림의 유무 등을 저장한다. 이는 플래그 레지스터, 상태 레지스터, 컨디션 레지스터라고도 불린다.
'''c
if (D2-D3 > 0)
    goto 100;
else
    goto 200;
'''
위 코드에서 D2-D3는 if 문장의 분기 조건이라 다음 연산 순서에 영향을 미친다.
PSR은 D2-D3의 결과를 저장하고 있다가 음수인지 양수인지를 제어장치에 알려주어 몇번 행으로 이동할지를 결정한다.


#### 1.4 버스의 종류
* 버스는 CPU와 메모리, 주변장치 간에 데이터를 주고받을 때 사용한다.
* 다음 작업을 지시하는 제어 신호, 메모리의 위치 정보를 알려주는 주소, 처리할 데이터가 오고 가며 각각 제어 버스, 주소 버스, 데이터 버스에 실린다.
<img src="https://user-images.githubusercontent.com/78334910/147911841-b266adb5-ab16-4872-ad9d-9376c40b2b9d.png">

1. 제어 버스
  * 다음에 어떤 작업을 할지 지시하는 제어 신호가 오고 간다.
  * 메모리에서 데이터를 가져올지(읽기 신호) 아니면 데이터를 옮겨놓을지(쓰기 신호)
  * 주변 장치도 마찬가지로 명령을 내릴 때 제어 버스를 통해 전달된다.
  * 메모리에서 오류가 발생하거나 네트워크 카드에 데이터가 모두 도착했다는 신호는 모두 제어 버스를 통해 CPU로 전달된다.
  * 제어버스의 신호는 CPU, 메모리, 주변장치와 양방향으로 오고 간다.
2. 주소 버스
  * 메모리의 데이터를 읽거나 쓸 때 어느 위치에서 작업할 것인지를 알려주는 위치 정보(주소)가 오고 간다.
  * 메모리 주소 레지스터(MAR)과 연결되어 있으며 단방향이다.
  * CPU에서 메모리나 주변장치로 나가는 주소 정보는 있지만 주소 버스를 통해 CPU로 전달되는 정보는 없다.
3. 데이터 버스
  * 데이터가 이동하는 버스
  * 메모리 버퍼 레지스터와 연결되어 있으며 양방향이다.

버스의 대역폭은 한 번에 전달할 수 있는 데이터의 최대 크기를 말한다.
4차선 도로는 한 번에 4대의 차가 동시에 다닐 수 있듯이 대역폭만큼 데이터가 오고 갈 수 있다.
버스의 대역폭은 CPU가 한 번에 처리할 수 있는 데이터의 크기이고 32bit CPU, 64bit CPU 여기서 bit 수를 말한다.
메모리에서 데이터를 읽거나 쓸 때 한번에 최대 32bit를 처리할 수 있다는 의미이다. 이 경우 레지스터의 크기도 32bit이고 버스의 대역폭도 32bit이다. 버스의 대역폭, 레지스터의 크기, 메모리에 한 번에 저장할 수 있는 데이터의 크기는 항상 같다. CPU가 한 번에 처리할 수 있는 데이터의 최대 크기를 워드 word라고 하며, 버스의 대역폭과 메모리에 한 번에 저장되는 단위도 워드이다. 32bit CPU에서 1워드는 32bit이다.

### 2 메모리의 종류와 부팅
* 모든 프로그램은 메모리에 올라와야 실행될 수 있다.
* 메모리에는 실행에 필요한 프로그램과 데이터가 존재하며, CPU와 협업하여 작업이 이루어진다.
* 메모리를 이루는 소자 하나의 크기는 1bit로 0 또는 1이 저장된다. 그러나 소자 하나만으로 데이터를 표현할 수 없어 메모리 주소는 바이트 단위로 지정되고, 메모리에서 데이터를 읽거나 쓸 때는 워드 단위로 움직인다.

#### 2.1 메모리의 종류
* 읽거나 쓸 수 있는 램 RAM과 읽기만 가능한 ROM으로 구분된다.
* RAM은 무작위로 데이터를 읽어도 저장된 위치와 상관없이 같은 속도로 데이터를 읽을 수 있다는 의미에서 붙은 이름이다.
<img src="https://user-images.githubusercontent.com/78334910/147918003-624cdd89-f527-46c4-8a0d-fbeaaf31927b.png">

* RAM은 전력이 끊기면 데이터가 사라지는 휘발성 메모리와 전력이 끊겨도 데이터를 보관할 수 있는 비휘발성 메모리로 나뉜다.
  * 휘발성 메모리
    * DRAM(Dynamic RAM)과 SRAM(Static RAM)이 있다.
    * DRAM은 저장된 0과 1의데이터가 일정 시간이 지나면 사라지므로 일정 시간마다 다시 재생시켜야 한다. 'Dynamic'은 시간이 지나면 데이터가 사라지기 떄문에 재생이 필요하다는 의미이다.
    * SRAM은 전력이 공급되는 동안에는 데이터를 보관할 수 있어 재생할 필요가 없다.
    * 따라서 속도는 빠르지만 가격이 비싸다.
    * 일반적으로 메인 메모리에는 DRAM을 사용하고, 캐시 같은 고속 메모리에는 SRAM을 사용한다.
    * SDRAM은 DRAM이 발전된 형태로 SRAM과는 완전히 다른 종류의 RAM이다. 클록틱이 발생할 때마다 데이터를 저장하는 동기 DRAM이다.
    * 메인 메모리를 비휘발성 메모리로 만들면 전력이 끊겨도 내용이 남아 편리할 수도 있지만 비휘발성 메모리는 전력이 끊겨도 데이터를 보관해야 하므로 메모리 내부가 복잡하고 속도가 느리며 가격이 비싸다. 
  * 비휘발성 메모리
    * 플래시 메모리, FRAM(Ferroelectric RAM), PRAM(Phase change RAM) 등이 있다.
    * 플래시 메모리는 디지털카메라, MP3 플레이어, USB 드라이버같이 전력이 없어도 데이터를 보관하는 저장장치로 많이 사용된다.
    * 그런데 각 소자의 최대 사용 횟수가 제한되어 많이 사용하면 제 기능을 잃는다. SD 카드나 USB 드라이버를 오래 사용하면 성능이 저하되거나 데이터를 잃어버릴 수 있으니 주의해야한다.
    * SSD는 하드디스크를 대신하도록 만들어졌다. 가격이 비싸지만 빠른 데이터 접근 속도, 저전력, 내구성 때문에 개인용 컴퓨터는 물론 노트북, 스마트폰 등 많은 기기에 사용되고 있다.

* ROM은 전력이 끊겨도 데이터를 보관하지만 데이터를 한 번 저장하면 바꿀 수 없다.
* 예를 들면 CD-ROM과 같다. 이러한 특성 때문에 BIOS를 ROM에 저장한다.
* ROM의 종류에는 데이터를 지우거나 쓸 수 없는 마스크 롬, 전용 기계를 이용하여 데이터를 한 번만 저장할 수 있는 PROM(Programmable ROM), 데이터를 여러 번 쓰고 지울 수 있는 EPROM(Erasable Programmable ROM)이 있다.
* EPROM은 플래시 메모리처럼 사용할 수 있지만 가격이 비싸서 잘 사용하지 않는다.

< DDR SDRAM >
* CPU는 3GHz 이상의 빠른 속도로 동작하는데 SDRAM은 메인보드의 시스템 버스와 같은 속도로 느리게 작동하여 전반적인 작업 속도를 떨어뜨리는 문제가 있다.
* 이러한 속도 차이를 완화하기 위해 SDRAM의 대역폭을 늘려 데이터 입출력 속도를 빠르게 한 것이 DDR(Double Data Rate) SDRAM이다.
* 기존의 SDRAM이 클록틱 한 번에 1개의 워드를 저장하는 반면에 DDR SDRAM은 클록틱 한 번에 2개의 워드를 저장한다.
* 기존 SDRAM은 SDR(Single Data Rate) SDRAM 라고 부를 수 있다.
* DDR2 SDRAM은 DDR SDRAM보다 대역폭이 2배 더 크고 SDR SDRAM보다 4배 더 크다.
* 현재는 DDR4 까지 보급되고 있다.

#### 2.2 메모리 보호
* 일괄 작업 시스템에서는 메모리가 운영체제 영역과 사용자 영역으로 구분되었다.
* 현대의 OS는 시분할 기법을 사용하여 여러 프로그램을 동시에 실행하여 사용자 영역이 여러개의 작업 공간으로 나뉘어 있다.
* 이런 상황에서 메모리 보호는 매우 중요하다.
* 메모리 보호가 되지 않으면 어떤 작업이 다른 작업의 영역을 침범하여 프로그램을 파괴하거나 데이터를 지울 수도 있으며, 최악의 경우 OS 영역을 침범하면 시스템이 멈출 수도 있다.
* 이처럼 OS 영역이나 다른 프로그램 영역으로 침범하려는 악성 소프트웨어를 바이러스라고 한다.
* OS도 소프트웨어 이라서 CPU를 사용하는 작업 중 하나이다. 그래서 사용자 프로세스가 CPU 차지하는 동안에는 OS의 작업이 잠시 중단된다.
* 이때 메모리를 보호하려면 하드웨어의 도움이 필요하다.
* CPU는 현재 진행 중인 작업의 메모리 시작 주소를 경계 레지스터(bound register)에 저장한 후 작업을 한다. 또한 현재 진행 중인 작업이 차지하고 있는 메모리의 크기, 즉 마지막 주소까지의 차이를 한계 레지스터(limit register)에 저장한다.
그리고 사용자의 작업이 진행되는 동안 이 두 레지스터의 주소 범위를 벗어나는지 하드웨어적으로 점검함으로써 메모리를 보호한다.
<img src="https://user-images.githubusercontent.com/78334910/147920912-c2a5a1ec-4b8c-44b4-98a8-6112e7904a6b.PNG">

* B작업이 데이터를 읽거나 쓸 때마다 CPU는 해당 작업이 경계 레지스터와 한계 레지스터 주소값 안에서 이루어지는지 검사한다.
* 만약 두 레지스터의 값을 벗어난다면 메모리 오류와 관련된 인터럽트가 발생한다. 인터럽트가 발생하면 모든 작업이 중단되고 CPU는 OS를 깨워서 인터럽트를 처리하도록 시킨다. 메모리 영역을 벗어나서 발생한 인터럽트의 경우 OS가 해당 프로그램을 강제 종료시킨다. 
* 이처럼 모든 메모리 영역은 하드웨어와 OS의 협업에 의해 보호받는다.

#### 2.3 부팅
* 응용 프로그램은 OS가 메모리에 올려서 실행하는데 OS는 누가 메모리에 올려서 실행시킬까?
* 컴퓨터를 켰을 때 누군가 메모리에 OS를 올린다. 컴퓨터가 켜질 때 OS를 메모리에 올리는 과정을 부팅이라고 한다.
<img src="https://user-images.githubusercontent.com/78334910/147921508-caa06d89-ea24-40e7-9346-2c7b58dde5d2.png">

1. 사용자가 컴퓨터에 전원을 켜면 ROM에 저장된 BIOS가 실행된다. 
2. BIOS는 CPU, 메모리, 하드디스크, 키보드, 마우스와 같은 주요 하드웨어가 제대로 작동하는지 확인한다. 만약 이상이 있으면 경고음과 함께 오류 메시지를 출력하고, 이상이 없으면 하드디스크의 마스터 부트 레코드 (Master Boot Record, MBR)에 저장된 작은 프로그램을 메모리로 가져와 실행한다.
  * Master Boot Record(MBR) : 하드디스크의 첫 번째 섹터를 가리키며, OS를 실행하기 위한 코드인 bootstrap이 이곳에 저장되어 있다.
  * Boostrap 코드는 OS를 메모리로 가져와 실행하는 역할을 하는 작은 프로그램이다.
  * BIOS(Basic Input/Output System) : 운영 체제가 다양한 컴퓨터를 지원하기 쉽게 개량하면서 만들어졌다. 컴퓨터 소프트웨어의 최저층에 존재하며, 부팅 전 하드웨어를 한 번 초기화하여 사용을 준비하게 하고, 소프트웨어가 하드웨어를 제어하고, 하드웨어가 소프트웨어에 변경된 정보를 전달하는 등 소프트웨어와 하드웨어 간의 설정 및 정보 전달의 매개 역할을 하는 컴퓨터의 펌웨어이다.

요즘은 USB 드라이버에도 마스터 부트 레코드를 탑재할 수 있다.
마스터 부트 레코드에 있는 부트스트랩이 메모리에 올라오면 하드디스크에 저장된 OS를 메모리로 불러온다. 따라서 MBR이 손상되면 OS 실행이 불가능하다.
이는 컴퓨터 바이러스의 좋은 공격 대상이 되낟. 일부 바이오스는 사용자 옵션 부분에 OS 보호 항목을 만들어 마스터 부트 레코드를 수정할 수 없게 한다. 만약 새로운 OS를 다시 설치한다면 이 OS 보호 옵션을 해제해야 한다.

한 컴퓨터에 OS 2개를 설치해보면 bootstrap을 확일할 수 있다. 이 경우 바이오스가 하드웨어 점검을 마치고 마스터 부트 레코드에서 부트스트랩을 가져와 실행하면 어떤 OS로 사용할 것인지 물어보는 화면이 나타난다. 이 화면이 부트스트랩 코드가 실행된 화면이다. 하나의 OS가 설치된 컴퓨터의 부트스트랩이라면 이러한 과정 없이 바로 OS를 메모리에 올린다.

< OS의 저장 위치 변화 >
* 최초의 개인용 컴퓨터가 나왔을땐 카세트테이프가 주된 저장장치였다.
* 그다음은 플로피 디스크 그래서 DOS (Disk Operating System)이란 말이 생겼다.
* 이후 하드디스크에 OS가 담기고 ROM에 바이오스를 저장하게 되었다.

## 03 컴퓨터 성능 향상 기술
> 현대 컴퓨터 구조의 가장 큰 문제점은 CPU와 메모리, 주변장치의 작업 속도가 다르다는 것이다.  
> 메모리의 속도는 시스템 버스와 CPU의 속도는 CPU 내부 버스와 속도가 같다. 하드디스크는 더 느리다.  
> 장치간 속도 차이를 개선하고 작업 속도를 올리기 위해 개발된 기술 중 OS와 관련된 기술을 알아보자.

### 1 버퍼
#### 1.1 버퍼의 개념
- 버퍼는 속도에 차이가 있는 두 장치 사이에서 그 차이를 완화하는 역할을 한다.
- 귤을 옯긴다고 가정했을때 귤을 하나씩 옮기는 것보다 귤을 바구니에 차곡차곡담아서 한번에 옮기는 것이 효율적이다. 이 경우의 바구니는 버퍼에 비유된다.
- 같은 사양이라면 버퍼의 크기가 큰 놈이 빠르다.
- 버퍼는 하드웨어적으로만 사용되는 개념이 아니라 소프트웨어적으로도 사용되는데 대표적인 예는 동영상 스트리밍이다. 
- 네트워크에서 데이터가 들어오는 시간과 플레이어가 재생되는 시간의 속도 차이가 발생하기도 한다. 플레이어가 재생되는 도중에 도착하지 않으면 동영상이 끊기는데, 이러한 현상을 방지하기 위해 동영상 데이터의 일정 부분을 버퍼에 넣은 후 실행한다.
< 모니터 버퍼 >
- 모니터도 버퍼를 사용한다.
- 화면에 출력할 때 한 줄이 다 차지 않으면 출력이 안되는 경우가 있다.
- C에서 '\n'은 개행을 의미하지만 버퍼에 저장된 내용을 출력하라는 의미도 있다. 따라서 printf를 사용할 때 마지막에 '\n'을 붙이는 습관을 들이는 것이 좋다.

#### 1.2 스풀
- 버퍼와 유사한 용어로 스풀은 CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어적인 버퍼로, 대표적인 예는 프린터에 사용되는 스풀러이다.
- 이는 인쇄할 내용을 순차적으로 출력하는 소프트웨어로, 출력 명령을 내린 프로그램과 독립적으로 동작한다.
- 워드로 작업하고 프린터로 출력하는 경우를 보면 스풀러가 없다면 모든 출력을 워드가 알아서 처리해야 하므로 인쇄가 끝날 때까지 워드를 사용할 수 없다.
- but, 스풀러를 사용하면 인쇄할 내뇬을 하드디스크의 스풀러 공간에 저장하고 워드는 다른 작업을 할 수 있다. 문서 작업과 프린터 출력 작업이 독립적으로 진행되는 것이다.
- 스풀러는 일종의 버퍼지만 기존의 버퍼와 다른 점이 있다.
- 버퍼의 경우 어떤 프로그램이 사용하는 데이터든 버퍼가 차면 이동이 시작된다. 다시 말해 프로그램이 버퍼를 공유한다.
- 반면에 스풀러는 한 인쇄물이 완료될 때까지 다른 인쇄물이 끼어들 수 없으므로 프로그램 간에 배타적이다.
<img src="https://user-images.githubusercontent.com/78334910/148162129-9abf1ec0-2c4f-42f1-bd81-3431e7a49ec2.PNG">

< 하드웨어 안전 제거 >
- 버퍼를 사용하면 버퍼가 다 채워질때까지 저장장치 간에 데이터 전송이 지연된다.
- 저장된 것 같지만 저장되지 않은 부분이 있을 수 있으므로 USB 같은 외부 저장장치에 데이터를 복사한 후 바로 제거하면 안된다.
- 컴퓨터 종료 버튼을 누르지 않고 그냥 전원을 뽑는 경우도 마찬가지다. 갑작스런 전원의 변화로 인해 부품이 망가지고 버퍼가 차지 않아 공들여한 작업이 사라질 수도 있다.
- 이때, 하드웨어 안전 제거를 이용하면 버퍼가 저장장치에 반영되지 않는 문제가 해결된다. 이 기능은 버퍼에 있는 아직 옮겨지지 않은 데이터를 저장장치로 보내고 전원을 차단하여 안전하게 제거할 수 있도록 준비한다.
- 유닉스의 경우 버퍼의 내용을 강제로 전송하는 명령어로 'fflush'를 사용한다.

### 2 캐시
#### 2.1 캐시의 개념
- 캐시는 메모리와 CPU 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해두는 임시 장소이다.
- 캐시는 버퍼의 일종으로 CPU가 앞으로 사용할 것으로 예상되는 데이터를 미리 가져다놓는다. 이 작업을 미리 가져오기 ( prefetch )라고 한다.
- 요리할 때 간장 10cc가 필요한 경우 10cc만 가져오면 또 가야하잖아 근데 50cc를 가져다놓으면 다음 간장일 필요할 때 시간을 단축할 수 있다. 이처럼 필요하다고 생각되는 일정량의 데이터를 미리 가져와 저장해두는 곳이 캐시다.
- 캐시는 CPU 안에 있으며 CPU 내부 버스의속도로 작동한다. 캐시는 CPU와 메모리 사이에서 두 장치의 속도 차이를 완화해준다.
- 캐시는 메모리의 일부 데이터를 미리 가져오고, CPU는 메모리에 접근해야 하면 먼저 캐시에서 찾아보고 있으면 캐시 히트라고 하며 그 데이터를 바로 사용한다. 

- 반면에 없으면 메모리로 가서 데이터를 찾는데 이것을 캐시 미스라고 한다.
- 캐시 히트가 되는 비율을 캐시 적중률 (cache hit ratio)라고 하며, 일반적으로 약 90%이다.
- 컴퓨터 성능이 좋아지려면 역시 캐시 hit ratio가 높아야한다. hit ratio를 높이기 위한 방안 중 하나는 캐시의 크기를 늘리는 것이다.
- 캐시로 가져오는게 많아지니까 hit ratio가 올라간다.
- 그래서 CPU가 클록이 같아도 저가형, 고가형은 캐시의 크기가 다르다. 저가형 i7은 캐시가 4MB인데 고가형은 8MB 이상이다.
- 캐시는 가격이 비싸서 크기를 늘리는데 한계가 있다. 그래서 몇 메가바이트 정도만 사용한다.
- hit ratio를 늘리는 또 다른 방법은 앞으로 많이 사용될 데이터를 가져오는 것이다.
- 이와 관련된 이론으로는 현재 위치에 가까운 데이터가 멀리 있는 데이터보다 사용될 확률이 더 높다는 지역성 (locality) 이론이 있다. 예컨데 프로그램의 10번 행이 실행되고 있다면 101번보다 11번이 다음 사용될 확률이 높다는 것이다. 따라서 지역성 이론에 따라 11~20번 행을 미리 가져오면 된다.

< 지역성 이론에 따르면 프로그래밍시 goto문을 사용하지 않는 것이 좋다. 미리 가져운 데이터가 쓸모 없어져서 그렇다. >

#### 2.2 즉시 쓰기와 지연 쓰기
- 캐시에 있는 데이터가 변경되는 경우 이를 반영해야 하는 문제에 대해 알아보자.
- 캐시에 있는 데이터가 변경되면 메모리에 데이터도 변경되어야 한다. 캐시의 변경된 데이터를 메모리에 반영하는 두 가지 방식이 있다.

  1. 즉시 쓰기
    + 캐시에 있는 데이터가 변경되면 이를 __즉시__ 메모리에 반영하는 방식
    + 빈번한 데이터 전송으로 성능이 느려진다는 단점이지만, 메모리에 최신 값이 항상 유지되어 급작스러운 정전에도 데이터 손실 X
  2. 지연 쓰기
    + 캐시에서 변경된 내용을 모아 __주기적__ 으로 반영하는 방식, '카피백' 이라고도 한다.
    + 데이터 전송이 줄어들어 시스템의 성능을 향상시키지만 메모리와 캐시된 데이터 사이의 불일치가 발생할 수 있다.

#### 2.3 L1 캐시와 L2 캐시
- 프로그램 명령어는 크게 어떤 작업을 할지 나타내는 명령어 부분과 작업 대상인 데이터 부분으로 나눌 수 있다.
- 그리고 캐시는 명령어와 데이터의 구분 없이 모든 자료를 가져오는 일반 캐시, 명령어와 데이터를 구분하여 가져오는 특수 캐시라는 두 가지 레벨로 구분된다.
- 레벨별 캐시의 구조를 보여준다.
< img src="https://user-images.githubusercontent.com/78334910/148164735-0a184edd-6dde-411b-a23b-98936d88444c.PNG">

- 명령어 캐시는 명령어 레지스터와 연결되어 있고, 데이터 캐시는 데이터 레지스터와 연결되어 있다.
- 명령어 캐시나 데이터 캐시는 CPU 레지스터에 직접 연결되기 때문에 Level 1 캐시라고 부르며, 일반 캐시는 메모리와 연결되기 때문에 Level 2 캐시라고 부른다.

< 웹 브라우저 캐시 >
- 캐시가 소프트웨어적으로 사용되는 대표적인 예이다.
- 웹에서 사용하는 캐시는 '앞으로 다시 방문할 것을 예상하여 지우지 않은 데이터'라고 정의할 수 있다.
- 다음이나 네이버와 같이 자주 방문하는 사이트의 경우 로고나 버튼 등의 작은 그림이 자주 바뀌지 않는데, 로고나 버튼 등의 데이터를 캐시에 보관하고 있다가 사이트를 방문하면 캐시에 있는 데이터를 사용하여 속도를 높인다.
- 이처럼 웹 브라우저의 캐시는 방문했던 사이터의 데이터를 보관하여 재방문 시 속도를 높이는 역할을 하는데 너무 많은 데이터가 캐시에 보관되어 있으면 웹 브라우저의 속도를 떨어뜨릴 수 있으므로 가끔 청소를 하는 것이 좋다.

### 3 저장장치의 계층 구조
> 최고의 성능을 내는 컴퓨터를 구성하고 싶다면 다음과 같은 방법을 시도해볼 수 있다.
  - 저장장치로 느린 하드디스크 대신 SSD 같은 빠른 플래시 메모리를 사용한다.
  - 메모리를 하드디스크 크기만큼 확장한다.
  - 캐시를 크기 늘려 cache hit ratio를 높인다.
> but 위의 방법은 비용이 많이 든다. 하드디스크 1TB는 약 4만원이지만 SSD 1TB는 약 40만원이다. 1MB에 만 원인 캐시로 메모리 4GB를 구성하려면 약 4,000만원이 든다. 이 정도는 필요가 없다.  
> 따라서 가격과 성능 사이의 타협점으로 저장장치의 계층 구조 (storage hierachy) 가 존재한다. CPU 근처에 비싸고 빠른 저장장치를 두고 값 싸고 용량이 큰 저장장치를 반대쪽에 배치하여 적당한 가격으로 빠른 속도와 큰 용량을 동시에 얻는 방법이다.
<img src="https://user-images.githubusercontent.com/78334910/148166904-57b538d2-8731-4254-888c-d8d5faad98f9.png">

> 컴퓨터는 CPU와 메모리 협업으로 작업을 하지만 메모리가 너무 느리다. 그래서 캐시나 레지스터를 CPU와 가깝게 배치하여 CPU가 작업을 빠르게 할 수 있게 한다. 또한 메모리에서 작업한 내용을 용량이 큰 저장장치에 영구적으로 저장할 수 있게 한다.  
> 계층 구조는 작업 속도는 레즈스터처럼 빠르도록 만들어 주고 용량은 하드디스크처럼 사용하도록 저렴하게 만들 수 있다.  
> 한편 저장장치의 계층 구조는 중복되는 데이터의 일관성을 유지하는 것이 문제이다. 앞서 설명했듯이 CPU가 캐시에 저장된 데이터를 변경하면 메모리도 같이 변경이 되어야하는데 즉시 반영하지 않고 주기적으로 반영하는 지연 쓰기의 경우 문제가 된다.  
> 또한 협업 중인다른 작업에서 해당 데이터를 읽으려 한다면 일관성이 깨질 수 있다. 게다가 전원이 꺼지기라도 한다면 데이터를 잃어버릴수도 있다.  
> 버퍼를 사용하는 하드디스크 같은 저장장치에서도 데이터의 일관성이 깨질 수 있다. 버퍼를 비우지 않았는데 하드웨어를 제거하면 일관성이 깨진다.  
> 데이터의 일관성 문제는 분산된 DB에 같은 데이터가 저장되어 있는 경우, CPU를 여러 개 사용하는 병렬 컴퓨터의 분산된 메모리 등에서도 발생한다.

### 4 인터럽트
#### 4.1 인터럽트의 개념
- 초기의 컴퓨터 시스템에는 주변장치가 많지 않았다. 당시엔 CPU가 직접 입출력장치에서 데이터를 가져오거나 내보냈는데, 이런 방식을 폴링(polling)이라고 한다.
- 요리사 모형으로 생각하면 요리사가 요리하다가 자기가 직접 재료를 필요하면 가져오는 것과 같다.
- 폴링 방식에서는 CPU가 입출력장치의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 데이터를 처리한다. CPU가 명령어 해석과 실행이라는 본래 역할 외에 모든 입출력까지 관여해야 하므로 작업 효율이 떨어진다.
- but 오늘날에는 주변장치가 많다. CPU가 모든 입출력에 관여하면 작업 효율이 떨어진다. 그래서 인터럽트 (interrupt) 방식이 나왔다.
- 인터럽트 방식은 주방 보조를 두는 것과 같다. 필요한 재료를 가져오게 주방 보조를 시키고 자신은 요리를 곘고하는 것이다. 지시받은 주방 보조는 재료를 가져다 도마에 올리고 재료가 준비되었다는 것을 요리사에게 알린다.
- CPU의 작업과 저장장치의 데이터 이동을 독립적으로 처리함으로써 효율을 높인다. 즉, 데이터가 입출력될 때, CPU는 다른 작업을 할 수 있다.

#### 4.2 인터럽트 방식의 동작 과정
1. CPU가 입출력 관리자에게 입출력 명령을 보낸다.
2. 입출력 관리자는 명령받은 데이터를 메모리에 가져다놓거나 메모리에 있는 데이터를 저장장치로 옮긴다.
3. 데이터 전송이 완료되면 입출력 관리자는 완료 신호를 CPU에 보낸다.

- 입출력 관리자가 CPU에게 보내는 신호를 인터럽트라고 한다.
- 그 이유는 CPU가 신호를 받으면 하던 작업을 중단하고 옮겨진 데이터를처리한다. 이처럼 하던 작업을 중단하고 처리해야 하는 신호라는 의미에서 인터럽트라고 불리게 되었다.
- 컴퓨터에는 입출력장치가 되게 많다. 하드디스크가 여러 개 장착된 경우도 있고 외부 저장장치를 이용하는 경우도 있다. 인터럽트에서는 어떤 장치가 끝났는지를 알리기 위해 인터럽트 넘버를 사용한다.
- 장치 이름 대신 사용하는 장치의 고유 번호로서 운영체제마다 다르다.
- 윈도우의 경우 인터럽트 번호를 IRQ(Interrupt ReQuest)라고 부르며, 키보드의 IRQ = 1번, 마우스 IRQ = 2번 첫 번째 하드디스크의 IRQ는 14번과 같이 구분해서 사용한다.
- CPU는 동시에 여러 개의 입출력 작업을 시킬 수 있다. 여러작업이 동시에 완료되고 그때마다 인터럽트를 하기에는 매우 비효율적이다.
- 그래서 여러 개의 인터럽트를 하나의 배열로 만든 인터럽트 벡터를 사용한다.
<img src="https://user-images.githubusercontent.com/78334910/148169158-18dee62e-e1a2-499a-9a45-f70630813cd1.PNG">

1. 입출력 요청
2. 데이터 전송
3. 인터럽트 발생
순으로 진행되는데 0번과 3번의 인터럽트가 동시에 발생했는데 그럼 CPU가 인터럽트 벡터를 받고 0번과 3번의 작업을 동시에 처리한다.

- 외에도 다양한 종류의 인터럽트가 있다.
- 사용자가 전원 버튼을 눌러 강제로 종료하면 CPU는 하던 일을 모두 멈추고 처리 중인 데이터를 안전하게 보관한 뒤 시스템을 종료해야 한다.
- 또한 메모리에서 실행 중인 어떤 작업이 자신에게 주어진 메모리 영역을 넘어서 작업을 하려 하거나 0으로 숫자를 나누면 인터럽트가 발생한다.

#### 4.3 직접 메모리 접근
- 효율성을 높이기 위해 인터럽트 방식을 사용하면서 입출력 관리자가 데이터의 입출력을 맡게 되었다.
- 메모리의 접근 권한은 CPU만 가져서 입출력 관리자가 접근할 수 없다는 문제점이 생긴다.
- 따라서 입출력 관리자는 CPU의 허락없이 메모리에 접근할 수 있는 권한이 필요한데, 이러한 권한을 직접 메모리 접근(DMA)라고 한다. 입출력 관리자는 직접 메모리 접근 권한이 있어야 CPU 관여없이 작업을 완료할 수 있다.
< img src="https://user-images.githubusercontent.com/78334910/148169830-e9899ce5-d2f6-4ecd-9929-a55849ac4e36.PNG" >

#### 4.4 메모리 매핑 입출력
- 직접 메모리 접근은 인터럽트 방식의 시스템을 구성하는데 필수 요수이지만 이걸 사용하면 메모리가 복잡해진다.
- 직접 메모리 접근을 통해 들어온 데이터를 메모리에 아무렇게나 둔다면 CPU가 사용하는 데이터와 섞여서 관리하기 어려울 것이므로이를 막기 위해 메모리를 나누어 사용하는 방법이 도입되었다. 
- CPU가 사용하는 메모리 공간과 직접 메모리 접근을 통해 들어오거나 나가는 데이터를 위한 공간을 분리하는 것이다. 이렇게 메모리으 일정 공간을 입출력에 할당하는 기법을 메모리 매핑 입출력( Memory Mapped I/O, MMIO )라고 한다.

#### 4.5 사이클 훔치기
- CPU와 직접 메모리 접근이 동시에 메모리에 접근하려 한다면 어떤 일이 발생할까?    
- 두 장치가 동시에 메모리에 접근하면 누군가는 양보를 해야 하는데 보통은 CPU가 메모리 사용 권한을 양보한다.
- CPU의 작업 속도보다 입출력 장치의 속도가 느리기에 양보하는 것으로, 이상황을 사이클 훔치기 ( cycle stealing )이라고 부른다. CPU 입장에서는 직접 메모리 접근이 사이클(순서)를 훔쳐 간 것이기 때문에 이렇게 일컫는 것이다.






























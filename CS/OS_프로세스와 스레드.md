> 프로세스 관리는 운영체제의 핵심적인 역할이다. 그래서 프로세스 생성 후 작업을 마칠 때까지 어떤 상태를 거치고 각 상태에서 고려할 사항이 무엇인지 프로세스 제어 블록은 어떻게 구성되고  
> 활용되는지 스레드가 어떤 역할을 하는지 프로세스와 비교해봄으로써 스레드 사용의 이점을 알아보자.
---
# 01 프로세스의 개요
> 프로세스는 하나의 작업 단위이다.  
> OS의 프로세스 처리 과정을 알아보자.  

## 1 프로세스의 개념
- 프로그램과 프로세스의 차이점 : 프로그램 = 저장장치에 저장된 정적인 상태, 프로세스 = 실행을 위해 메모리에 올라온 동적인 상태  
  + 요리로 비교하면 프로그램 = 레시피, 프로세스 = 요리  

## 2 요리사 모형에의 비유
> 프로세스가 어떻게 동작하는지 이해하기 위해 요리를 주문하여 나오기까지의 과정을 보자.  
### 2.1 주문서의 역할
- 요리를 시작하기 위해선 종업원이 손님에게 주문을 받아 주문서를 요리사에게 줘야한다.
- 주문서에는 여러 가지 내용이 있는데 주문 순서를 위한 일련번호와 어떤 테이블에서 주문했는지 알기 위한 테이블 번호, 한 테이블에 몇명인지 등 표시되어있다.
- 주문서에는 어떤 요리를 선택했는지와 각 손님의 특별사항( ex) 피클뺴주세요, 고기 굽기 등 )이 나타나 있다.
- 주문서는 요리의 전반적인 조리 방법과 요리가 나가는 순서를 결정하는 중요한 자료이다.  
### 2.2 일괄 작업 방식의 요리
- 가장 간단한 요리 제공 방식이고 한 번에 하나의 작업만 처리하기에 식당에 하나의 테이블이 존재하는 것과 같다.
- 요리사는 주문서를 받은 순서대로 요리를 하고 테이블이 하나라서 주문서에 테이블 번호가 없다.
- 또한 한 번에 한 가지의 요리만 만들면 되기 때문에 요리가 제공되는 순서가 단순하고, 손님이 식사하는 동안 쉬는 시간이 생기고 작업효율이 떨어진다.
- 기다리는 손님에게 미리 주문을 받는다면 주문 목록을사용하게 되는데 큐로 처리되고 먼저 들어온 주문서가 먼저 처리된다.  
### 2.3 시분할 방식의 요리
- 테이블이 많은 식당에서 일괄 작업 방식으로 요리를 하면 비효율적이다.
- 요리사는 1명이지만 시간을 배분해서 여러 요리를 동시에 하는 시분할 방식이 효율적이다. 손님이 식사하는 시간을 활용하면 요리사가 여러 명 있는 것처럼 지체없이 요리핤 수 있다.
- CPU가 1개인 컴퓨터에서 여러 프로세스를 동시에 실행하는 것도 같은 원리이다. CPU가 시간을 쪼개 여러 프로세스에 배분하여 동시에 실행하는 것처럼 느껴진다.
- 손님이 주문을 하면 주문서를 주문 목록에 넣고 요리사는 그 중 제일 앞에 있는 주문서를 가져다 주문받은 코스요리 중 단품 요리 하나를 만들고 주문 목록 맨 뒤로 옮긴다. 이걸 반복한다.
- 모든 요리가 제공되면 주문서는 주문 목록에서 삭제한다.
- 주문서가 주문 목록에 올라온다는 것은 요리의 시작을 의미하고 요리하는 동안 주문서는 주문 목록에서 대기하거나 요리하는 상태를 왕복한다.  
### 2.4 시분할 방식에서의 예상치 못한 상황 처리
- 주문 처리 시 예상치 못한 상황에 처할 수 있다.
- 예를 들면, 새우 튀김을 해야 하는데 아직 새우가 손질되지 않았다고 가정해보자. 보조 요리사에게 새우 손질을 맡기고 요리사는 해당 주문서를 대기 목록으로 옮기고 
주문 목록의 다른 주문서를 가져와 요리를 한다. 작업의 효율성이 높아진다.
- 새우 손질이 끝났다고 가정해보자. 원래 순서대로 새우튀김을 시작해야한다. 요리사가 다른 요리를 하고 있는데 작업순서를 위해서 해당 요리를 멈추고 새우 튀김을 하는 것은 비효율적이다.
- 따라서 새우 손질이 완료된 주문서는 대기 목록에서 주문 목록으로 이동하여 다음 순서를 기다린다.
- 손님이 천천히 달라했을때 지연 요청이 언제 끝날 지를 모르고 또한 손님이 식사를 포기할 수 있다.
- 이와 같이 언제 다시 시작될지 모르는 주문서는 보류목록으로 옮기고 , 손님이 달라고 하면 주문 목록으로 옮긴다. 만약 손님이 식사를 중단하면 주문서를 폐기한다.
- 보류 목록의 작업은 언제 다시 시작될지 모르거나 중간에 그만둘지 모르는 것으로, 대기 목록에 있는 작업과 구분된다.
- 운영체제에서 프로세스 처리도 이와 유사하다. 현대의 운영체제는 시분할 방식을 기본으로 사용하기에 프로세스가 여러 상태를 오가며 실행된다.  

## 3 프로그램에서 프로세스로의 전환
- 프로세스는 컴퓨터 시스템의 작업 단위로 task라고도 부른다.
- 운영체제는 프로그램을 메모리로 가져오면서 주문서에 해당하는 Process Control Block, PCB를 만든다.
- 어떤 프로그램이 프로세스가 되었다는 것은 운영체제로부터 PCB를 받았다는 의미이다.
- PCB에 들어있는 다양한 정보 중 대표적인 세 가지는 다음과 같다.
  1. 프로세스 구분자 : 레스토랑의 주문서에 일련번호가 있듯 각 프로세스를 구분하기 위해 프로세스 구분자가 있다.
  2. 메모리 관련 정보 : CPU는 실행하려는 프로세스가 메모리의 어디에 위치하는지 알아야 작업이 가능하다. 그래서 메모리 위치 정보와 메모리 보호를 위한 경계 레지스터, 한계 레지스터도 존재한다.
  3. 각종 중간값 : PCB에는 프로세스가 사용했던 중간값이 저장되는데 이는 현재 어떤 단품 요리까지 손님에게 제공되었는지를 주문서에 표시하는 것과 유사하다. 프로그램 카운터가
다음 행의 코드를 저장하고. 또한 중간값을 보관중인 다른 레지스터도 같이 저장된다.  
> 결론적으로 하나의 프로세스를 실행하려면 프로세스 구분자, 메모리 관련 정보, 각종 중간값을 관리해야 하고 이런 정보를 보관하는 데이터 구조가 PCB이다.  
> PCB는 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에 운영체제 영역에 만들어진다. 또한 프로세스 종료 시 PCB도 폐기된다.
> 즉 프로그램 -> 프로세스 = OS로부터 PCB를 얻는다, 프로세스 종료 = 해당 PCB가 폐기
![image](https://user-images.githubusercontent.com/78334910/153108393-1fb172ab-78aa-4de5-bc96-abd54059d14b.png)  
> 강조하고 싶은 부분은 컴퓨터 내엔 사용자가 실행한 프로세스만 있는 것이 아니다라는 사실이다.  
> 부트스트랩이 많은 OS 관련 프로세스를 실행한 후 일반 프로세스가 실행되어 사용자 프로세스와 커널 프로세스가 섞여서 실행된다.
  
## 4 프로세스의 상태
- 앞서 식당에서의 주문서가 다양한 목록을 옮겨 다니는 상황을 보았다.
- 운영체제도 여러 이유로 process status가 변화된다.
  + 먼저 일괄 작업 시스템은 프로세스가 생성되고 CPU를 얻어 실행 후 작업을 마치면 종료된다. 따라서 create, run, terminate 세 가지 상태를 가진다.
  + 시분할시스템는 CPU를 얻어 실행 중인 프로세스가 중간에 다른 프로세스로 CPU를 넘겨주는 일이 허다하다. 이는 여러 코스의 단품요리를 번갈아가며 만드는 것이다.
어떤 주문서의 단품 요리를 막 만들었다면 그 주문서는 주문 목록으로 다시 이동하고 OS에서도 이제 막 프로세스가 되었거나 CPU를 사용하다가 쫒겨난 프로세스는 준비 상태에서 자기 순서를 기다린다.  
### 4.1 프로세스의 네 가지 상태
![image](https://user-images.githubusercontent.com/78334910/153112389-87ef5d0c-64ea-496a-a2db-cd8a60593caa.png)  
- create - ready - run - terminate  
  가. 생성 상태 (create) : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태. (PCB가 생성된 상태)  
  나. 준비 상태 (ready) : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태.  
  다. 실행 상태 (run) : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태.  
  라. 완료 상태 (terminate) : 주어진 시간 동안 프로세스가 작업을 마치면 변환되는 상태. (PCB가 사라진 상태)  
- CPU scheduler : 준비 상태의 프로세스 중 다음 실행될 프로세스 선정.
  + 준비 상태의 맨 앞의 PCB를 CPU에 전달 
  + dispatch : 준비 상태의 프로세스 -> 실행 상태
  + 프로세스의 전 상태에 관여하여 모든 프로세스의 작업이 원할하게 이루어지도록 관리.
  + Time slice or Quantum : 프로세스에 배당된 작업 시간.
    - Time out : 프로세스가 자신에게 주어진 하나의 퀀텀 동안 작업을 끝내지 못하여 다시 준비 상태로 돌아가는 경우.
    - 프로세스가 실행 상태가 되면 CPU는 퀀텀이 흐른 후 알려달라고 클록에 요청 : "클록으로부터의 인터럽트 "  
### 4.2 프로세스의 다섯 가지 상태
- 효율성을 위해 오늘날 한 가지 상태를 추가.
- CPU가 입출력 관리자에게 작업 요청 -> 요청된 작업이 끝날 때까지 대기 : 효율성이 떨어짐.
- 대기 상태 (block) : 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태
  + 대기 상태에 있는 동안 다른 프로세스 실행
  + 요청한 입출력이 완료되면 인터럽트
  + 대기 상태에서 입출력이 끝난 프로세스는 준비 상태로 돌아감.
![image](https://user-images.githubusercontent.com/78334910/153112348-eaf135cb-dfde-4a4b-9bad-a1cb6bab4e24.png)  
- 생성 상태 (create) : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태. (PCB가 생성된 상태)
    + 메모리 할당. PCB 생성  
- 준비 상태 (ready) : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태.
    + dispatch(PID: 준비 -> 실행  
- 실행 상태 (run) : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태.
    + timeout(PID): 실행 -> 준비  
    + exit(PID): 실행 -> 완료  
    + block(PID): 실행 -> 대기  
- 대기 상태 (block) : 실행 상태에 있는 프로세스가 입출력 요청 시 완료될 때까지 기다리는 상태. (wait이라고도 함.)
    + wakeup(PID): 대기 -> 준비  
- 완료 상태 (terminate) : 주어진 시간 동안 프로세스가 작업을 마치면 변환되는 상태. (PCB가 사라진 상태)
    + 메모리 삭제. PCB 삭제  
### 4.3 휴식 상태와 보류 상태.
- 활성 상태 : 위 다섯 가지 상태. ( 생성, 준비, 실행, 대기, 완료)
- 아래는 또 다른 상태, 조금 특별한 경우.
  + 휴식 상태 : 프로세스가 작업을 일시적으로 쉬고 있는 상태
    - 유닉스에서 ctrl + z를 누른 경우
    - jobs를 통한 프로세스의 상태를 확인하면 정지(stop)임을 확인 가능
    - 사용하던 데이터, PCB 유지 -> 재시작 가능
  + 보류 상태 : 프로세스가 메모리에서 잠시 쫒겨난 상태
    - 휴식 상태와 차이 존재
    - 다음과 같은 경우 보류 상태로 전환
      + 메모리가 꽉 차서 일부 프로세스를 내보내야 하는 경우
      + 프로그램에 오류가 있어 실행을 미루어야 하는 경우
      + 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단되는 경우
      + 매우 긴 주기로 반복되어 메모리 밖으로 내보내도 큰 문제가 없는 프로세스로 판단되는 경우
      + 입출력을 기다리는 프로세스의 입출력이 계속 지연되는 경우
      + 이 경우 외에도 보류 상태로 들어감, but 대부분이 컴퓨터의 성능 저하 or 실행을 미루어도 지장없는 경우  
  ![image](https://user-images.githubusercontent.com/78334910/153114069-4d75da7c-b1f7-4b95-b025-134dbba6ccab.png)  
    - 메모리 밖으로 내보내는 경우 스왑 영역에 보관
      + 스왑 영역 : 메모리에서 쫒겨난 데이터를 임시 보관하는 영역
    - 2 가지 보류 상태
      + 보류 대기 상태 : 대기 상태에서 옮겨진 보류 상태
        - 입출력이 완료되는 경우 보류 준비 상태로 전환
      + 보류 준비 상태 : 준비 상태에서 옮겨지 보류 상태  

# 02 프로세스 제어 블록과 문맥 교환
## 1 프로세스 제어 블록
- TCB(Task Control Block, 프로세스 제어 블록(PCB)): 프로세스를 실행하는데 필요한 중요한 정보를 보관하는 자료 구조.
- 모든 프로세스는 이를 가짐
- 프로세스 생성 시 생성, 실행 완료 시 폐기  
### 1.1 프로세스 제어 블록의 구성
![image](https://user-images.githubusercontent.com/78334910/153324904-75ac5662-e17a-46d9-b1ea-84b60c110e5d.png)  
- 포인터 : 첫번쨰 블록에 위치하고 준비 상태나 대기 상태의 큐를 구현할 때 사용.
- 프로세스 상태 : 두번째 블록에 위치하고 현재 프로세스가 어떤 상태에 있는지를 나타냄
- 프로세스 구분자 : 운영체제 내에 있는 여러 프로세스를 구별하기 위해 구분자를 저장
- 프로그램 카운터 : 다음 실행될 명령어의 위치를 가르키는 프로그램 카운터의 값을 저장.
- 프로세스 우선순위 : 실제로는 앞선 설명과 다르게 프로세스의 중요도에 따라 우선순위가 나뉜다. ( 커널 프로세스 > 사용자 프로세스, 사용자 프로세스끼리도 우선순위 다름.)
우선 순위에 따라 프로세스 제어 블록들이 여러 줄로 서있다. 높은 우선순위의 프로세스가 낮은 우선순위보다 먼저 실행되고 더 자주 실행된다.
- 각종 레지스터 정보 : 자신이 사용하던 레지스터의 중간값을 보관한다.
- 메모리 관리 정보 : 메모리 위치 정보, 메모리 보호를 위한 경계 레지스터 값과 한계 레지스터 값 등 저장.
- 할당된 자원 정보 : 프로세스 실행을 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보.
- 계정 정보 : 계정번호, CPU 할당 시간, CPU 사용 시간 등
- 부모 프로세스 구분자와 자식 프로세스 구분자 : PPID(Parent PID), CPID(Child PID)
### 1.2 포인터의 역할
- 일반적으로 대기 상태에는 같은 입출력을 요구한 프로세스끼리 모음. -> 대기 큐  

## 2 문맥 교환
### 2.1 문맥 교환의 의미
- 식당의 예로써 보면 주문서를 받고 새우튀김을 만들고 다음 요리를 준비하려고 주문서를 바꿔든다. 즉 교환을 한다.
- 이때 주문서를 단순히 교환한다고 끝나는 것이 아니라 새우튀김을 만들 때 사용했던 재료와 도구를 치우고 다음 요리를 위한 재료와 도구를 바꿔야한다.
- 즉, 요리 작업의 전환 과정은 주문서를 바꾸는 것과 동시에 작업 환경을 바꾸는 것이다.
- 문맥 교환 : CPU를 차지하던 프로세스를 나가고 새로운 프로세스를 받아들이는 작업, 두 프로세스의 프로세스 제어 블록을 교환하는 작업.
### 2.2 문맥 교환의 절차
1. 프로세스 P1 실행 상태 -> 타임아웃 : 프로세스 제어 블록에 현재까지의 작업 결과가 저장되고 준비 상태로 쫒겨남.
2. 프로세스 P2 준비 상태 -> 실행 상태 : CPU의 레지스터가 P2의 프로세스 제어 블록 값으로 채워짐.  
![image](https://user-images.githubusercontent.com/78334910/153327010-80520489-2aec-4728-8535-5210254f74f5.png)  
- 문맥 교환이 일어나는 경우는 매우 다양함.
  + 타임아웃
  + 인터럽트 -> ex) 프로세스에서 주어진 메모리 공간을 넘어가려 한다면 인터럽트 발생 -> 현재 실행중인 프로세스의 제어 블록 저장 후 인터럽트 관리 프로세스를 실행 상태로 만듬.
  + 인터럽트 관리 프로세스는 해당 프로세스를 강제 종료하고 인터럽트 처리를 마침 -> 이와 같이 인터럽트 처리시에도 문맥 교환이 일어남.  

# 03 프로세스의 연산
> 프로세스가 어떻게 생성되고 복사되는지 알기 위해 먼저 시스템 프로그래밍을 이해해야한다.
먼저 프로세스의 구조를 파악하자.
## 1 프로세스의 구조
- 코드 영역, 데이터 영역, 스택 영역으로 구성
- 스파게티를 만드는 과정에 비유
  + 코드 영역 : 요리책
    - 스파게티를 만들기 위해 레시피가 적힌 요리책을 봐야하는데 요리책은 코드 영역에 해당. 요리책에 레시피가 있듯 코드 영역에 프로세스의 본문이 기술.
  + 데이터 영역 : 재료
    - 요리를 완성하기 위해선 재료가 필요. 이러한 재료는 프로세스 데이터 영역에 해당.
    - 일반 데이터 영역과 힙 영역으로 나뉨.
  + 스택 영역 : 조리 도구
    - 스택 영역은 코드를 작동하기 위해 운영체제가 부수적으로 관리하는 데이터 영역. 어떤 조리 도구를 사용하여 요리하는지 손님이 알 수 없듯 사용자에게 내용이 보이지 않음.
- 예를 들어 워드 프로그램 실행
  + 코드 영역 : 프로그램 탑재
  + 데이터 영역 : 워드로 편집 중인 문서 탑재
  + 스택 영역 : 워드 작동을 위해 사용하는 각종 부가 데이터
- 코드 영역 : 프로그램의 본문 기술 탑재된 코드는 읽기 전용으로 처리 자기 자신을 수정하는 프로그램은 존재 X, 텍스트 영역
- 데이터 영역 : 변수, 파일 등의 각종 데이터를 모아놓는 영역 데이터는 변하는 값이기에 읽기&쓰기가 가능
- 스택 영역 : 부수적으로 필요한 데이터를 모아놓은 영역 운영체제가 프로세스를 작동하기 위해 유지하는 영역이므로 불가시 
  + ex) 프로세스 내에서 함수 호출 -> 함수 수행 후 원래 프로그램으로 되돌아올 위치를 이 영역에 저장.  
## 2 프로세스의 생성과 복사
> 주문이 들어올 때마다 새로 요리를 만들면 많은 시간과 노력이 든다. 같은 요리라면 요리를 복제하여 제공하면 된다.
### 2.1 시스템 호출의 개념
- fork() : 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수.
  + 일종의 시스템 호출
  + 기존 프로세스와 복사된 프로세스 간의 부모-자식 관계 형성 
  + fork() 시스템 호출을 접하는 경우가 많음  
    - ex1) 워드 문서 작업 시 새로운 워드 프로그램을 하나 더 실행하면 OS는 fork()를 사용하여 기존의 워드를 복사. -> 처음 워드 실행하는 속도보다 훨씬 빠름.
    - ex2) 크롬에서 ctrl + N을 누르면 크롬이 하나 더 실행. 이는 현재의 크롬 프로세스를 복사한것 -> 기존 프로세스는 부모 프로세스가 되고 새로 생긴 프로세스는 자식 프로세스가 됨.
### 2.2 fork() 시스템 호출의 동작 과정
> 프로세스 제어 블록을 포함한 부모 프로세스 영역의 대부분이 복사되어 똑같은 프로세스 생성
- 일부 변경되는 부분
  + PID(프로세스 구분자)가 바뀜. 다른 프로세스니까 당연하다.
  + 메모리의 위치가 다르므로 메모리 관련 정보가 바뀜.
  + PPID와 CPID가 바뀜. 자식 프로세스가 없는 경우 -1
### 2.3 fork() 시스템 호출의 장점
- 프로세스의 생성 속도가 빠르다.
  + 하드디스크로부터 가져오지 않고 메모리에서 복사를 하여 굉장히 빠르다. -> 워드 두개를 띄울때 첫번째꺼 보다 두번째꺼다 더 빠른 이유
- 추가 작업 없이 자원을 상속할 수 있다.
  + 예를 들어 부모 프로세스가 파일 A를 사용했다면 자식도 바로 사용 가능
- 시스템 관리를 효율적으로 할 수 있다.
  + 자식 프로세스가 종류 시 부모가 정리할 수 있다. 메모리 영역, 파일, 하드웨어를 잘 정리해야 하는데 부모에게 맡김으로써 시스템이 효율적으로 관리됨.

## 3 프로세스의 전환
> 운영체제는 주문하는 요리가 달라도 간단하게 처리하는 기능을 제공. fork()로 복사 후, 복사된 요리를 새로운 요리로 바꾸는 exec()를 사용.
### 3.1 exec() 시스템 호출의 개념
- exec() : 기존의 프로세스를 새로운 프로세스로 전환하는 함수.
- 이는 스파게티를 우동으로 바꾸는 역할.
  + fork(): 새로운 프로세스를 복사하는 시스템 함수, 스파게티를 하나 더 만듬.
  + exec() : 프로세스는 그대로 둔 채 내용만 바꾸는 시스템 함수, 스파게티를 우동으로 바꿈.
- exec() 시스템 호출을 사용하는 목적
  + 프로세스의 구조체를 재활용하기 위함.
  + exec()를 사용하면 이미 만들어진 프로세스 제어 블록, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있어 편함.
    - 새로운 코드 영역만 가져오면 된다.
### 3.2 exec() 시스템 호출의 동작 과정
- 기존의 코드 영역의 내용을 지우고 새로운 코드로바꿈.
- 데이터 영역 또한 새로운 변수로 채워지고 스택 영역이 리셋됨.
- PID, PPID, CPID, 메모리 관련 사항은 바뀌지 않지만 각종 레지스터와 사용한 파일 정보가 모두 리셋  

## 프로세스의 계층 구조
> 프로세스의 복사와 전환은 프로세스의 생성 과정과 계층 구조를 이해하는 데 중요한 열쇠.
### 4.1 유닉스의 프로세스 계층 구조
- 유닉스 부팅 시 커널 관련 프로세스를 여러 개 생성, 그중 init 프로세스는 전체 프로세스의 출발점.
- 나머지 프로세스를 init 프로세스의 자식으로 만듬, 효율적인 시스템 관리를 위함.
### 4.2 프로세스 계층 구조의 장점.
- 여러 작업의 동시 처리
  + ex) 사용자 3명이 동시에 접속 시 login 프로세스는 한 번에 1명만 처리가능 -> fork()를 이용하여 여러 login 프로세스 생성 -> 여러 사용자를 동시 처리 가능
  + login 프로세스 후 shell 프로세스가 필요
    - shell 프로세스 : 사용자가 OS에 명령을 내리고 결과를 받을 수 있음.
  + login 프로세스가 종료되고 exec()를 이용하여 shell 프로세스로 활용 -> 자원을 효율적으로 관리 가능, 부모 자식 관계 유지 가능
- 용이한 자원 회수
  + 프로세스 간의 책임 관계가 분명해져 시스템 관리 수월.
  + 사용하던 자원 회수 시 특히 편리
    - 만약 독립적이라면 프로세스 종료마다 OS가 직접 자원을 회수
    - but, 부모 자식 관계에서는 부모 프로세스가 회수 가능
### 4.3 고아 프로세스
- 부모 프로세스가 먼저 종료 or 자식 프로세스가 비정상적으로 종료되어 부모 프로세스에 연락이 안되는 경우
- 자식이 종료되지 않거나 종료되어도 자원이 남음.
- 고아 프로세스 : 프로세스 종료 후에도 비정상적으로 남은 프로세스. ( 부모가 자식보다 먼저 죽은 경우 )
- 좀비 프로세스 : 자식 프로세스 종료 후 부모가 뒤처지 하지 않은 경우의 프로세스
  + 자원이 낭비됨으로써 효율적인 운영에 방해
- 따라서 주기적인 자원 회수 필요.
  + 일반적으로 C 언어를 배울 때 마지막에 exit() or return()을 사용 -> 자식 프로세스가 종료되었음을 알리는 함수
  + 위 함수를 사용하지 않는다고 무조건 좀비 프로세스가 되는 것은 아니지만 종료를 알림으로써 자원 정리나 자식 프로세스와의 동기화 가능














> 프로세스 관리는 운영체제의 핵심적인 역할이다. 그래서 프로세스 생성 후 작업을 마칠 때까지 어떤 상태를 거치고 각 상태에서 고려할 사항이 무엇인지 프로세스 제어 블록은 어떻게 구성되고  
> 활용되는지 스레드가 어떤 역할을 하는지 프로세스와 비교해봄으로써 스레드 사용의 이점을 알아보자.
---
# 프로세스의 개요
> 프로세스는 하나의 작업 단위이다.  
> OS의 프로세스 처리 과정을 알아보자.  

## 1 프로세스의 개념
- 프로그램과 프로세스의 차이점 : 프로그램 = 저장장치에 저장된 정적인 상태, 프로세스 = 실행을 위해 메모리에 올라온 동적인 상태  
  + 요리로 비교하면 프로그램 = 레시피, 프로세스 = 요리  

## 2 요리사 모형에의 비유
> 프로세스가 어떻게 동작하는지 이해하기 위해 요리를 주문하여 나오기까지의 과정을 보자.  
### 2.1 주문서의 역할
- 요리를 시작하기 위해선 종업원이 손님에게 주문을 받아 주문서를 요리사에게 줘야한다.
- 주문서에는 여러 가지 내용이 있는데 주문 순서를 위한 일련번호와 어떤 테이블에서 주문했는지 알기 위한 테이블 번호, 한 테이블에 몇명인지 등 표시되어있다.
- 주문서에는 어떤 요리를 선택했는지와 각 손님의 특별사항( ex) 피클뺴주세요, 고기 굽기 등 )이 나타나 있다.
- 주문서는 요리의 전반적인 조리 방법과 요리가 나가는 순서를 결정하는 중요한 자료이다.  
### 2.2 일괄 작업 방식의 요리
- 가장 간단한 요리 제공 방식이고 한 번에 하나의 작업만 처리하기에 식당에 하나의 테이블이 존재하는 것과 같다.
- 요리사는 주문서를 받은 순서대로 요리를 하고 테이블이 하나라서 주문서에 테이블 번호가 없다.
- 또한 한 번에 한 가지의 요리만 만들면 되기 때문에 요리가 제공되는 순서가 단순하고, 손님이 식사하는 동안 쉬는 시간이 생기고 작업효율이 떨어진다.
- 기다리는 손님에게 미리 주문을 받는다면 주문 목록을사용하게 되는데 큐로 처리되고 먼저 들어온 주문서가 먼저 처리된다.  
### 2.3 시분할 방식의 요리
- 테이블이 많은 식당에서 일괄 작업 방식으로 요리를 하면 비효율적이다.
- 요리사는 1명이지만 시간을 배분해서 여러 요리를 동시에 하는 시분할 방식이 효율적이다. 손님이 식사하는 시간을 활용하면 요리사가 여러 명 있는 것처럼 지체없이 요리핤 수 있다.
- CPU가 1개인 컴퓨터에서 여러 프로세스를 동시에 실행하는 것도 같은 원리이다. CPU가 시간을 쪼개 여러 프로세스에 배분하여 동시에 실행하는 것처럼 느껴진다.
- 손님이 주문을 하면 주문서를 주문 목록에 넣고 요리사는 그 중 제일 앞에 있는 주문서를 가져다 주문받은 코스요리 중 단품 요리 하나를 만들고 주문 목록 맨 뒤로 옮긴다. 이걸 반복한다.
- 모든 요리가 제공되면 주문서는 주문 목록에서 삭제한다.
- 주문서가 주문 목록에 올라온다는 것은 요리의 시작을 의미하고 요리하는 동안 주문서는 주문 목록에서 대기하거나 요리하는 상태를 왕복한다.  
### 2.4 시분할 방식에서의 예상치 못한 상황 처리
- 주문 처리 시 예상치 못한 상황에 처할 수 있다.
- 예를 들면, 새우 튀김을 해야 하는데 아직 새우가 손질되지 않았다고 가정해보자. 보조 요리사에게 새우 손질을 맡기고 요리사는 해당 주문서를 대기 목록으로 옮기고 
주문 목록의 다른 주문서를 가져와 요리를 한다. 작업의 효율성이 높아진다.
- 새우 손질이 끝났다고 가정해보자. 원래 순서대로 새우튀김을 시작해야한다. 요리사가 다른 요리를 하고 있는데 작업순서를 위해서 해당 요리를 멈추고 새우 튀김을 하는 것은 비효율적이다.
- 따라서 새우 손질이 완료된 주문서는 대기 목록에서 주문 목록으로 이동하여 다음 순서를 기다린다.
- 손님이 천천히 달라했을때 지연 요청이 언제 끝날 지를 모르고 또한 손님이 식사를 포기할 수 있다.
- 이와 같이 언제 다시 시작될지 모르는 주문서는 보류목록으로 옮기고 , 손님이 달라고 하면 주문 목록으로 옮긴다. 만약 손님이 식사를 중단하면 주문서를 폐기한다.
- 보류 목록의 작업은 언제 다시 시작될지 모르거나 중간에 그만둘지 모르는 것으로, 대기 목록에 있는 작업과 구분된다.
- 운영체제에서 프로세스 처리도 이와 유사하다. 현대의 운영체제는 시분할 방식을 기본으로 사용하기에 프로세스가 여러 상태를 오가며 실행된다.  

## 3 프로그램에서 프로세스로의 전환
- 프로세스는 컴퓨터 시스템의 작업 단위로 task라고도 부른다.
- 운영체제는 프로그램을 메모리로 가져오면서 주문서에 해당하는 Process Control Block, PCB를 만든다.
- 어떤 프로그램이 프로세스가 되었다는 것은 운영체제로부터 PCB를 받았다는 의미이다.
- PCB에 들어있는 다양한 정보 중 대표적인 세 가지는 다음과 같다.
  1. 프로세스 구분자 : 레스토랑의 주문서에 일련번호가 있듯 각 프로세스를 구분하기 위해 프로세스 구분자가 있다.
  2. 메모리 관련 정보 : CPU는 실행하려는 프로세스가 메모리의 어디에 위치하는지 알아야 작업이 가능하다. 그래서 메모리 위치 정보와 메모리 보호를 위한 경계 레지스터, 한계 레지스터도 존재한다.
  3. 각종 중간값 : PCB에는 프로세스가 사용했던 중간값이 저장되는데 이는 현재 어떤 단품 요리까지 손님에게 제공되었는지를 주문서에 표시하는 것과 유사하다. 프로그램 카운터가
다음 행의 코드를 저장하고. 또한 중간값을 보관중인 다른 레지스터도 같이 저장된다.  
> 결론적으로 하나의 프로세스를 실행하려면 프로세스 구분자, 메모리 관련 정보, 각종 중간값을 관리해야 하고 이런 정보를 보관하는 데이터 구조가 PCB이다.  
> PCB는 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에 운영체제 영역에 만들어진다. 또한 프로세스 종료 시 PCB도 폐기된다.
> 즉 프로그램 -> 프로세스 = OS로부터 PCB를 얻는다, 프로세스 종료 = 해당 PCB가 폐기
![image](https://user-images.githubusercontent.com/78334910/153108393-1fb172ab-78aa-4de5-bc96-abd54059d14b.png)  
> 강조하고 싶은 부분은 컴퓨터 내엔 사용자가 실행한 프로세스만 있는 것이 아니다라는 사실이다.  
> 부트스트랩이 많은 OS 관련 프로세스를 실행한 후 일반 프로세스가 실행되어 사용자 프로세스와 커널 프로세스가 섞여서 실행된다.
  
## 4 프로세스의 상태
- 앞서 식당에서의 주문서가 다양한 목록을 옮겨 다니는 상황을 보았다.
- 운영체제도 여러 이유로 process status가 변화된다.
  + 먼저 일괄 작업 시스템은 프로세스가 생성되고 CPU를 얻어 실행 후 작업을 마치면 종료된다. 따라서 create, run, terminate 세 가지 상태를 가진다.
  + 시분할시스템는 CPU를 얻어 실행 중인 프로세스가 중간에 다른 프로세스로 CPU를 넘겨주는 일이 허다하다. 이는 여러 코스의 단품요리를 번갈아가며 만드는 것이다.
어떤 주문서의 단품 요리를 막 만들었다면 그 주문서는 주문 목록으로 다시 이동하고 OS에서도 이제 막 프로세스가 되었거나 CPU를 사용하다가 쫒겨난 프로세스는 준비 상태에서 자기 순서를 기다린다.  
### 4.1 프로세스의 네 가지 상태
![image](https://user-images.githubusercontent.com/78334910/153112389-87ef5d0c-64ea-496a-a2db-cd8a60593caa.png)  
- create - ready - run - terminate  
  가. 생성 상태 (create) : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태. (PCB가 생성된 상태)  
  나. 준비 상태 (ready) : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태.  
  다. 실행 상태 (run) : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태.  
  라. 완료 상태 (terminate) : 주어진 시간 동안 프로세스가 작업을 마치면 변환되는 상태. (PCB가 사라진 상태)  
- CPU scheduler : 준비 상태의 프로세스 중 다음 실행될 프로세스 선정.
  + 준비 상태의 맨 앞의 PCB를 CPU에 전달 
  + dispatch : 준비 상태의 프로세스 -> 실행 상태
  + 프로세스의 전 상태에 관여하여 모든 프로세스의 작업이 원할하게 이루어지도록 관리.
  + Time slice or Quantum : 프로세스에 배당된 작업 시간.
    - Time out : 프로세스가 자신에게 주어진 하나의 퀀텀 동안 작업을 끝내지 못하여 다시 준비 상태로 돌아가는 경우.
    - 프로세스가 실행 상태가 되면 CPU는 퀀텀이 흐른 후 알려달라고 클록에 요청 : "클록으로부터의 인터럽트 "  
### 4.2 프로세스의 다섯 가지 상태
- 효율성을 위해 오늘날 한 가지 상태를 추가.
- CPU가 입출력 관리자에게 작업 요청 -> 요청된 작업이 끝날 때까지 대기 : 효율성이 떨어짐.
- 대기 상태 (block) : 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태
  + 대기 상태에 있는 동안 다른 프로세스 실행
  + 요청한 입출력이 완료되면 인터럽트
  + 대기 상태에서 입출력이 끝난 프로세스는 준비 상태로 돌아감.
![image](https://user-images.githubusercontent.com/78334910/153112348-eaf135cb-dfde-4a4b-9bad-a1cb6bab4e24.png)  
- 생성 상태 (create) : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태. (PCB가 생성된 상태)
    + 메모리 할당. PCB 생성  
- 준비 상태 (ready) : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태.
    + dispatch(PID: 준비 -> 실행  
- 실행 상태 (run) : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태.
    + timeout(PID): 실행 -> 준비  
    + exit(PID): 실행 -> 완료  
    + block(PID): 실행 -> 대기  
- 대기 상태 (block) : 실행 상태에 있는 프로세스가 입출력 요청 시 완료될 때까지 기다리는 상태. (wait이라고도 함.)
    + wakeup(PID): 대기 -> 준비  
- 완료 상태 (terminate) : 주어진 시간 동안 프로세스가 작업을 마치면 변환되는 상태. (PCB가 사라진 상태)
    + 메모리 삭제. PCB 삭제  
### 4.3 휴식 상태와 보류 상태.
- 활성 상태 : 위 다섯 가지 상태. ( 생성, 준비, 실행, 대기, 완료)
- 아래는 또 다른 상태, 조금 특별한 경우.
  + 휴식 상태 : 프로세스가 작업을 일시적으로 쉬고 있는 상태
    - 유닉스에서 ctrl + z를 누른 경우
    - jobs를 통한 프로세스의 상태를 확인하면 정지(stop)임을 확인 가능
    - 사용하던 데이터, PCB 유지 -> 재시작 가능
  + 보류 상태 : 프로세스가 메모리에서 잠시 쫒겨난 상태
    - 휴식 상태와 차이 존재
    - 다음과 같은 경우 보류 상태로 전환
      + 메모리가 꽉 차서 일부 프로세스를 내보내야 하는 경우
      + 프로그램에 오류가 있어 실행을 미루어야 하는 경우
      + 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단되는 경우
      + 매우 긴 주기로 반복되어 메모리 밖으로 내보내도 큰 문제가 없는 프로세스로 판단되는 경우
      + 입출력을 기다리는 프로세스의 입출력이 계속 지연되는 경우
      + 이 경우 외에도 보류 상태로 들어감, but 대부분이 컴퓨터의 성능 저하 or 실행을 미루어도 지장없는 경우  
  ![image](https://user-images.githubusercontent.com/78334910/153114069-4d75da7c-b1f7-4b95-b025-134dbba6ccab.png)  
    - 메모리 밖으로 내보내는 경우 스왑 영역에 보관
      + 스왑 영역 : 메모리에서 쫒겨난 데이터를 임시 보관하는 영역
    - 2 가지 보류 상태
      + 보류 대기 상태 : 대기 상태에서 옮겨진 보류 상태
        - 입출력이 완료되는 경우 보류 준비 상태로 전환
      + 보류 준비 상태 : 준비 상태에서 옮겨지 보류 상태













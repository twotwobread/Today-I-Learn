# 01 프로세스 간 통신
## 1 프로세스 간 통신의 개념
> 프로세스 간 통신에는 같은 컴퓨터 내 프로세스 뿐만 아니라 네트워크로 연결된 다른 컴퓨터의 프로세스와의 통신도 포함.  
> 운영체제의 도움 없이 진행되는 통신 방식 : 전역 변수, 파일을 이용하여 통신  
> 운영체제가 제공하는 통신 방식 : 파이프, 소켓, 원격 프로시저 호출
- 프로세스 내부 데이터 통신 : 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신, 전역변수 or 파일 이용.
- 프로세스 간 데이터 통신 : 같은 컴퓨터 내의 여러 프로세스끼리의 통신, 공용 파일 or 운영체제가 제공하는 파이프 이용.
- 네트워크를 이용한 데이터 통신 : 여러 컴퓨터가 네트워크로 연결되어 이를 이용한 통신, 소켓 이용 -> 네트워킹이라 함.
 + 다른 컴퓨터에 있는 함수를 호출하여 통신하는 원격 프로시저 호출도 여기에 해당.
- 어떤 통신 방식을 이용할지 결정 시 오버헤드 고려.
  + ex) 같은 컴퓨터 상에서도 소켓을 이용하여 통신 가능. but, 소켓을 사용하기 위해 많은 전처리가 필요 -> 다른 프로세스 간 통신 방법보다 느림. -> 같은 컴퓨터 상의 프로세스 상에서 거의 소켓을 사용하지 않음.  
## 2 프로세스 간 통신의 분류
### 2.1 통신 방향에 따른 분류
> 프로세스 간 통신은 동시에 실행되는 프로세스끼리 데이터를 주고받는 작업을 의미.
- 양방향 통신 : 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조, 일반적인 통신은 모두 양방향.
- 반양방향 통신 : 데이터를 양쪽 방향으로 전송 가능 but, 동시 전송 불가능.(특정 시점에 한쪽 방향으로만 전송할 수 있는 구조)
  + 대표적인 예 : 무전기.
- 단방향 통신 : 한쪽 방향으로만 데이터를 전송할 수 있는 구조, 전역변수와 파이프가 이에 속함.
  + 대표적인 예 : 모스 부호.
### 2.2 통신 구현 방식에 따른 분류
> 전역 변수 사용 시 가장 큰 문제 : 언제 데이터를 보낼지 데이터를 받는 쪽에서 알 수 없음.  
> so, 받는 쪽에서 반복적으로 전역 변수 값을 점검해야함. (busy waiting : 상태 변화를 보기 위해 반복문을 무한 실행하며 기다리는 상태)  
> 굉장히 자원 낭비가 심하여 안 좋은 프로그램의 전형적인 예.  
> 위 문제를 해결하기 위해 동기화를 사용 ( ex. 메신저에서 메시지가 도착했다는 알림. )
- 대기가 있는 통신 : 동기화를 지원하는 통신 방식, 데이터를 받는 쪽은 데이터가 도착하기 전까지 대기 상태.
- 대기가 없는 통신 : 동기화를 지원하지 않는 통신 방식, 데이터를 받는 쪽은 busy waiting을 이용하여 데이터 도착 여부 확인.
  + 통신 오버헤드는 적지만 사용자가 직접 처리해야 하는 작업이 많음.  
## 3 프로세스 간 통신의 종류
> 전역 변수, 파일, 파이프, 소켓을 이용한 프로세스 간 통신과 각 통신에서 프로세스 동기화가 어떻게 이루어지는지 알아보자.
### 3.1 전역 변수를 이용한 통신
- 공동으로 관리하는 메모리를 사용하여 데이터를 주고받는 것.
- 주로 직접적으로 관련이 있는 프로세스 간에 사용. ( ex. 부모 프로세스가 전역 변수 선언 후 자식 프로세스 생성하여 두 프로세스 간 통신)
- 관련이 없는 프로세스도 extern 전역 변수를 사용 가능.
- busy waiting을 이용하여 계속 주시해야 함.
### 3.2 파일을 이용한 통신
- 프로세스가 입출력 관리 프로세스에 쓰기를 요구하면 데이터가 저장, 읽기를 요구하면 입출력 관리 프로세스로부터 데이터를 가져옴.
- 이는 부모-자식 관계 프로세스 간 통신에 많이 사용되며 OS가 동기화 제공 X.
- 주로 부모 프로세스가 wait() 함수를 이용하여 자식 프로세스의 작업 종료를 기다렷다가 작업 시작.
### 3.3 파이프를 이용한 통신
- OS가 제공하는 동기화 통신 방식, 파일 입출력 같이 open() 함수로 기술자를 얻고 작업 후 close()로 마무리.
- 전역 변수와 마찬가지로 단방향 통신, 양방향을 위해선 파이프 2개 사용.
- 이름 없는 파이프 : 일반적으로 파이프라 하면 이름없는 파이프, 부모 자식 프로세스 혹은 같은 부모를 가진 자식 프로세스와 같이 서로 연관성이 있는 프로세스 간 통신에 사용.
- 이름 있는 파이프 : FIFO라 불리는 특수 파일을 이용하며 서로 관련 없는 프로세스 간 통신에 사용.
### 3.4 소켓을 이용한 통신
- 여러 컴퓨터에 있는 프로세스 간 통신 : 네트워킹.
- 이는 원격 프로시저 호출이나 소켓을 이용.
- 일반적으로 원격 프로시저 호출은 소켓을 이용하여 구현.
- 동기화 지원 -> 바쁜 대기 X, 소켓 하나로 양방향 통신 가능.
### 3.5 정리
- 프로세스 간 데이터를 주고받는 행위는 읽기와 쓰기로 단순화 가능.
- 부모 자식 관계로 연결되어 있는 프로세스 : 전역 변수, 파일, 이름 없는 파이프 등.
- 서로 독립적인 프로세스 : 이름 있는 파이프.
- 서로 다른 시스템에 있는 프로세스 : 소켓.
- open-read/write-close 구조는 파일, 파이프, 소켓 동일하게 적용.
# 02 공유 자원과 임계구역
## 1 공유 자원의 접근
- 공유 자원 : 여러 프로세스가 공동으로 이용하는 변수, 메모리 파일 등을 의미.
- 공유 자원 접근 순서를 정하여 예상치 못한 문제 예방.
- 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황을 경쟁 조건(race condition)이 발생했다고 함
- 경쟁 조건 발생 -> 공유 자원 접근 순서에 따라 실행 결과가 달라질 수 있음.
## 2 임계구역
- 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램 영역 : 임계 구역.
- 어떤 프로세스가 임계구역에 들어가면 다른 프로세스는 프로세스가 나올 때까지 임계구역 밖에서 기다려야함.
## 3 생산자-소비자 문제
- 임계구역과 관련된 전통적인 문제.
- 생산자, 소비자 프로세스가 서로 독립적으로 작업.
- 생산자는 물건을 계속 버퍼에 넣고 소비자는 버퍼에서 물건을 가져옴.
- 생산자 코드와 소비자 코드가 동시에 실행 시 문제 발생.
## 임계구역 해결 조건
- 상호 배제 (mutual exclusion) : 한 프로세스가 cs에 들어가면 다른 프로세스는 cs에 들어갈 수 없음.
- 한정 대기 (bounded waiting) : 어떤 프로세스도 무한 대기하지 않아야 함.
- 진행의 융통성 (progress flexibility) : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안됨.
# 03 임계구역 해결 방법
> 단순한 해결 방법은 잠금(lock) 이용.  
> 임계구역을 해결하기 위한 세 가지 조건인 상호 배제, 한정 대기, 진행의 융통성을 모두 만족하는 잠금, 잠금 해제, 동기화 구현 방법을 알아보자.
## 2 임계구역 해결 조건을 고려한 코드 설계
### 2.1 상호배제 문제
- boolean 타입의 lock이란 변수를 선언하여 임계구역을 사용할 땐 true, 사용하지 않으면 false 로 표현.
- 만약 true라면 while(lock==true);를 이용하여 무한 루프 설정.
- 근데 이 경우 가끔 제대로 작동하지 않는 경우 발생.
  1. P1은 cs에 진입한 프로세스가 없다고 판단하여 무한 루프를 빠져나오고 다음 문장을 실행하려는 순간 타임아웃(주어진 CPU 시간을 다 사용) 발생 -> 준비 상태로 이동 -> P2로 스위칭.
  2. P2는 cs에 진입한 프로세스가 있는지 확인 -> P1이 lock을 걸지 못해서 P2 cs 진입 가능.
  3. P1은 lock을 true로 바꾸고 cs 진입
  4. P2도 lock을 true로 바꾸고 cs 진입
  + 결국 둘다 cs 진입. -> 상호 배제를 보장 X
  + 또 다른 문제는 잠금 풀리기를 기다리면서 바쁜 대기 -> 시스템 자원 낭비
### 2.2 한정 대기 문제
- 상호 배제를 보장못하는 부분을 보완하여 lock1, lock2 변수를 선언하여 사용.
- P1은 lock1을 먼저 잠금하고 cs 진입전 P2가 잠금 설정을 했는지 보기 위해 lock2를 확인.
- P2도 lock2를 먼저 잠금하고 lock1을 확인.
- 이전과 다르게 먼저 잠금을 하기 때문에 잠금하지 못하여 상호배제를 보장하지 않는 문제 발생 X
- but, 이 코드에서는 두 프로세스 모두 cs 진입하지 못하는 무한 대기 현상 발생.
  1. P1은 lock1을 잠금하고 타임아웃 -> 컨텍트 스위칭, P2 실행 상태.
  2. P2는 lock2를 잠금하고 타임아웃 -> 컨텍트 스위칭, P1 실행 상태.
  3. P1, P2 모두 lock1, lock2가 잠금되어 있는 상태이기에 무한 루프 상태.
  + 한정 대기 조건을 보장 X -> deadlock(교착) 상태
- 그리고 확장성 문제도 존재
  + 만약 프로세스를 여러개를 쓴다고 가정하면 하나의 프로세스마다 lock이 따로 필요하고 다른 프로세스에서는 lock이 생길때마다 검사를 해야함.
  + 확장성 측면에서 매우 비효율적.
### 2.3 진행의 융통성 문제
- 상호 배제와 한정 대기 조건을 충족시키기 위해 보완.
- 하나의 공유변수 int 타입 lock을 두고 값이 1이면 P1, 2면 P2가 사용하는 중임을 의미.
- 잠금 확인 문장이 하나이므로 상호 배제와 한정 대기를 모두 보장.
- but, 서로 번갈아가면서 실행된다는 것이 문제. -> 한 프로세스가 두 번 연달아 임계구역에 진입 불가능.
  + 프로세스의 우선순위에 상관없이 무조건 번갈아가면서 cs에 진입.
  + 이는 하나의 프로세스가 다른 프로세스의 진행을 방해하는 구조.
  + 위와 같은 현상을 경직된 동기화(lockstep synchronization)이라 함.
  + 즉 진행의 융통성 조건을 보장 X
### 2.4 하드웨어적인 해결 방법
- 맨 처음 상호 배제를 언급하며 사용했던 코드를 이용.
- 무한 루프(검사문장)를 하고 나서 바로 lock(잠금문장)을 걸어야 하는데 그 도중 타임아웃이 발생하면 문제 발생.
- 이 경우 하드웨어적으로 검사문장, 잠금문장을 동시에 실행하면 cs 문제 쉽게 해결 가능.
  + 원래 while(lock==true); , lock=true; 이 두 문장이었는데 이것을 바꾸면 while(testandset(&lock)==true); 로 바꿀 수 있음.
    - 검사와 지정(test-and-set)이라는 코드 -> 위 두문장을 한번에 실행.
    - 이를 이용하면 명령어 실행 중간에 타임아웃이 걸려 cs를 보호하지 못하는 문제 발생 X
  + 이처럼 하드웨어적으로 해결하는 방법은 편리하지만 바쁜 대기를 이용하여 검사하여 자원 낭비 발생.
  + 일부 하드웨어에서는 바쁜 대기없이 잠금을 동기화하지만 이는 성능 좋은 하드웨어에서나 가능.
  
## 3 피터슨 알고리즘.
- 한정 대기 조건을 보장하지 못하는 코드와 유사하지만 turn이라는 공유 변수를 더 사용.
1. cs 진입 전 먼저 lock1 = true를 한 후 turn = 2로 설정, 이는 두 프로세스가 동시에 lock을 설정하여 cs에 못들어가는 상황을 대비하기 위한 장치.
2. 이어서 while(lock2==true && turn==2);문을 실행.                                                     
3. 만약 P2가 잠금을 설정하지 않았거나 잠금을 설정했더라도 turn=1로 바꾸어 P1은 cs에 진입하여 작업을 마친 후 잠금을 해제하고 cs를 나옴.
- 임계구역 해결의 세 가지 조건을 모두 만족하지만 2개의 프로세스만 사용가능하다는 한계 존재. -> 프로세스를 추가하기 위해선 프로세스마다 공유변수를 추가해야함.
## 4 데커 알고리즘
- 지금까지 피터슨을 제외하고 소개한 모든 알고리즘은 검사와 지정 같은 하드웨어적 도움이 필요.
- 이는 하드웨어의 도움 없이도 해결 가능.
- 데커 알고리즘의 동작을 P1의 입장에서 접근.
  1. P1은 우선 잠금을 검 ( lock1=true; )
  2. P2의 잠금을 검사 ( while(lock2==true); )
  3. 만약 P2도 잠금을 걸었다면 누가 먼저인지 확인 ( if(turn==2) )
  4. 만약 P1의 차례라면 cs로 진입, 만약 P2의 차례라면 5번으로 이동.
  5. P1은 잠금을 풀고 ( lock1=false ) P2가 마칠때까지 기다림 ( while(turn==2); ) -> 마치면 잠금을 걸고 ( lock1 = true; ) cs 진입.
- 피터슨이나 데커는 cs 해결의 세 가지 조건을 모두 만족하지만 매우 복잡. -> 프로세스가 늘어나면 변수도 많아지고 전체적인 알고리즘도 복잡해짐.
- cs를 보호하기 위해 복잡한 알고리즘을 구현하는 것은 바람직한 접근 방법 X
## 5 세마포어
- 자원 낭비와 복잡함을 보완하기 위해 세마포어 제안.
- cs 진입 전 스위치를 사용 중으로 놓고 cs 진입.
- 이후 프로세스들은 작업을 마치기 전까지 대기. -> 작업을 마치면 세마포어는 다음 프로세스에 cs를 사용하라는 동기화 신호 전송.
- 다른 알고리즘과 달리 cs가 잠겼는지 점검하거나 바쁜 대기, 다른 프로세스에 동기화 메시지 전송이 필요없음.
- Semaphore(n); n은 공유 가능한 자원의 수를 나타냄. ( ex. 프린터가 1대면 1, 2대면 2 )
  + Semaphore(n) : 전역 변수 RS를 n으로 초기화, RS에는 현재 사용 가능한 자원의 수 저장.
- cs 진입 전 P(); 를 하면 사용 중을 표시
  + P() : 잠금을 수행하는 코드, RS가 0보다 크면 1만큼 감소시키고 cs 진입 / 만약 0보다 작으면 0보다 커질 때까지 대기.
  + 대기시에는 block() 코드 사용.
- 작업을 마치고 V(); 를 하면 임계구역이 비었다고 표시
  + V() : 잠금 해제와 동기화를 같이 수행하는 코드, RS 값을 1 증가시키고 세마포어에서 기다리는 프로세스에게 cs 진입해도 좋다는 wake_up 신호 전송.
- 세마포어에서 잠금이 해제되기를 기다리는 프로세스는 세마포어 큐에 저장되어 있다가 신호를 받으면 큐에서 나와 cs 진입.
  + so, 바쁜 대기를 하는 프로세스 X
- P(), V()의 내부 코드는 검사와 지정을 이용하여 분리 실행되지 않고 완전히 실행.
1. P1은 cs 진입, 현재 RS 값 1이어서 1감소 -> 0
2. P2 cs 진입 시도, RS == 0 이어서 큐에서 대기.
3. P1은 예금이 현재 10만원인 것을 확인후 10 만원을 더해 20만원으로 바꾼 후 작업 종료.
4. P1은 V()를 실행하여 RS값 증가시키고 wake_up 신호 전송.
5. wake_up 신호를 받은 P2가 작업을 시작. 20만원을 25만원으로 변경.
- 세마포어는 공유 자원이 여러 개인 경우도 사용 가능.
## 6 모니터
- 세마포어는 피터슨이나 데커 보다 단순하고 사용하기 편리하지만 문제가 존재.
  + 잘못된 사용으로 cs가 보호받지 못한다는 문제 존재.
  1. 프로세스가 세마포어를 사용하지 않고 cs 진입한 경우 cs 보호 불가.
  2. P()를 두 번 사용하여 wake_up이 발생하지 않는 경우, 프로세스 간 동기가 이루어지지 않아 세마포어 큐에 존재하는 프로세스 무한 대기.
  3. P()와 V()를 반대로 사용하여 상호 배제 보장 X
- 공유 자원 사용 시 모든 프로세스가 세마포어 알고리즘을 따른다면 P(), V()를 굳지 사용하지 않고 자동으로 처리 가능. -> 이를 구현한 것이 모니터.
- 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제종함으로써 자원 보호, 프로세스 간에 동기화.
1. cs로 지정된 변수나 자원에 접근하고자 하는 프로세스는 직업 P(), V()를 사용하지 않고 모니터에 작업 요청.
2. 모니터는 요청받은 작업을 모니터 큐에 저장 후 순서대로 처리하고 결과를 해당 프로세스에 알려줌.
- cs 보호와 동기화를 위해 내부적으로 상태 변수 (condition variable)을 사용.
  + wait() : 모니터 큐에서 자신의 차례가 올 떄까지 대기. ( P()에 해당 )
  + signal() : 모니터 큐에서 기다리는 다음 프로세스에 순서를 넘김. ( V()에 해당 )
- 불필요한 정보를 숨기고 공유 자원에 대한 인터페이스만 제공하는 모니터는 오늘날의 객체지향 언어와 매우 닮음.

 







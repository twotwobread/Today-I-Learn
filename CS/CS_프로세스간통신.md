# 01 프로세스 간 통신
## 1 프로세스 간 통신의 개념
> 프로세스 간 통신에는 같은 컴퓨터 내 프로세스 뿐만 아니라 네트워크로 연결된 다른 컴퓨터의 프로세스와의 통신도 포함.  
> 운영체제의 도움 없이 진행되는 통신 방식 : 전역 변수, 파일을 이용하여 통신  
> 운영체제가 제공하는 통신 방식 : 파이프, 소켓, 원격 프로시저 호출
- 프로세스 내부 데이터 통신 : 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신, 전역변수 or 파일 이용.
- 프로세스 간 데이터 통신 : 같은 컴퓨터 내의 여러 프로세스끼리의 통신, 공용 파일 or 운영체제가 제공하는 파이프 이용.
- 네트워크를 이용한 데이터 통신 : 여러 컴퓨터가 네트워크로 연결되어 이를 이용한 통신, 소켓 이용 -> 네트워킹이라 함.
 + 다른 컴퓨터에 있는 함수를 호출하여 통신하는 원격 프로시저 호출도 여기에 해당.
- 어떤 통신 방식을 이용할지 결정 시 오버헤드 고려.
  + ex) 같은 컴퓨터 상에서도 소켓을 이용하여 통신 가능. but, 소켓을 사용하기 위해 많은 전처리가 필요 -> 다른 프로세스 간 통신 방법보다 느림. -> 같은 컴퓨터 상의 프로세스 상에서 거의 소켓을 사용하지 않음.  
## 2 프로세스 간 통신의 분류
### 2.1 통신 방향에 따른 분류
> 프로세스 간 통신은 동시에 실행되는 프로세스끼리 데이터를 주고받는 작업을 의미.
- 양방향 통신 : 데이터를 동시에 양쪽 방향으로 전송할 수 있는 구조, 일반적인 통신은 모두 양방향.
- 반양방향 통신 : 데이터를 양쪽 방향으로 전송 가능 but, 동시 전송 불가능.(특정 시점에 한쪽 방향으로만 전송할 수 있는 구조)
  + 대표적인 예 : 무전기.
- 단방향 통신 : 한쪽 방향으로만 데이터를 전송할 수 있는 구조, 전역변수와 파이프가 이에 속함.
  + 대표적인 예 : 모스 부호.
### 2.2 통신 구현 방식에 따른 분류
> 전역 변수 사용 시 가장 큰 문제 : 언제 데이터를 보낼지 데이터를 받는 쪽에서 알 수 없음.  
> so, 받는 쪽에서 반복적으로 전역 변수 값을 점검해야함. (busy waiting : 상태 변화를 보기 위해 반복문을 무한 실행하며 기다리는 상태)  
> 굉장히 자원 낭비가 심하여 안 좋은 프로그램의 전형적인 예.  
> 위 문제를 해결하기 위해 동기화를 사용 ( ex. 메신저에서 메시지가 도착했다는 알림. )
- 대기가 있는 통신 : 동기화를 지원하는 통신 방식, 데이터를 받는 쪽은 데이터가 도착하기 전까지 대기 상태.
- 대기가 없는 통신 : 동기화를 지원하지 않는 통신 방식, 데이터를 받는 쪽은 busy waiting을 이용하여 데이터 도착 여부 확인.
  + 통신 오버헤드는 적지만 사용자가 직접 처리해야 하는 작업이 많음.  
## 3 프로세스 간 통신의 종류
> 전역 변수, 파일, 파이프, 소켓을 이용한 프로세스 간 통신과 각 통신에서 프로세스 동기화가 어떻게 이루어지는지 알아보자.
### 3.1 전역 변수를 이용한 통신
- 공동으로 관리하는 메모리를 사용하여 데이터를 주고받는 것.
- 주로 직접적으로 관련이 있는 프로세스 간에 사용. ( ex. 부모 프로세스가 전역 변수 선언 후 자식 프로세스 생성하여 두 프로세스 간 통신)
- 관련이 없는 프로세스도 extern 전역 변수를 사용 가능.
- busy waiting을 이용하여 계속 주시해야 함.
### 3.2 파일을 이용한 통신
- 프로세스가 입출력 관리 프로세스에 쓰기를 요구하면 데이터가 저장, 읽기를 요구하면 입출력 관리 프로세스로부터 데이터를 가져옴.
- 이는 부모-자식 관계 프로세스 간 통신에 많이 사용되며 OS가 동기화 제공 X.
- 주로 부모 프로세스가 wait() 함수를 이용하여 자식 프로세스의 작업 종료를 기다렷다가 작업 시작.
### 3.3 파이프를 이용한 통신
- OS가 제공하는 동기화 통신 방식, 파일 입출력 같이 open() 함수로 기술자를 얻고 작업 후 close()로 마무리.
- 전역 변수와 마찬가지로 단방향 통신, 양방향을 위해선 파이프 2개 사용.
- 이름 없는 파이프 : 일반적으로 파이프라 하면 이름없는 파이프, 부모 자식 프로세스 혹은 같은 부모를 가진 자식 프로세스와 같이 서로 연관성이 있는 프로세스 간 통신에 사용.
- 이름 있는 파이프 : FIFO라 불리는 특수 파일을 이용하며 서로 관련 없는 프로세스 간 통신에 사용.
### 3.4 소켓을 이용한 통신
- 여러 컴퓨터에 있는 프로세스 간 통신 : 네트워킹.
- 이는 원격 프로시저 호출이나 소켓을 이용.
- 일반적으로 원격 프로시저 호출은 소켓을 이용하여 구현.
- 동기화 지원 -> 바쁜 대기 X, 소켓 하나로 양방향 통신 가능.
### 3.5 정리
- 프로세스 간 데이터를 주고받는 행위는 읽기와 쓰기로 단순화 가능.
- 부모 자식 관계로 연결되어 있는 프로세스 : 전역 변수, 파일, 이름 없는 파이프 등.
- 서로 독립적인 프로세스 : 이름 있는 파이프.
- 서로 다른 시스템에 있는 프로세스 : 소켓.
- open-read/write-close 구조는 파일, 파이프, 소켓 동일하게 적용.
# 02 공유 자원과 임계구역
## 1 공유 자원의 접근
- 공유 자원 : 여러 프로세스가 공동으로 이용하는 변수, 메모리 파일 등을 의미.
- 공유 자원 접근 순서를 정하여 예상치 못한 문제 예방.
- 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황을 경쟁 조건(race condition)이 발생했다고 함
- 경쟁 조건 발생 -> 공유 자원 접근 순서에 따라 실행 결과가 달라질 수 있음.
## 2 임계구역
- 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램 영역 : 임계 구역.
- 어떤 프로세스가 임계구역에 들어가면 다른 프로세스는 프로세스가 나올 때까지 임계구역 밖에서 기다려야함.
## 3 생산자-소비자 문제
- 임계구역과 관련된 전통적인 문제.
- 생산자, 소비자 프로세스가 서로 독립적으로 작업.
- 생산자는 물건을 계속 버퍼에 넣고 소비자는 버퍼에서 물건을 가져옴.
- 생산자 코드와 소비자 코드가 동시에 실행 시 문제 발생.
## 임계구역 해결 조건
- 상호 배제 (mutual exclusion) : 한 프로세스가 cs에 들어가면 다른 프로세스는 cs에 들어갈 수 없음.
- 한정 대기 (bounded waiting) : 어떤 프로세스도 무한 대기하지 않아야 함.
- 진행의 융통성 (progress flexibility) : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안됨.
                                                                                                                                                                                                                                                                                       








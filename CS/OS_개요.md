<!--
(2021.12.31) 23p-33p
-->

# CHAPTER01 운영체제의 개요

## 01 운영체제 소개
* 일반 컴퓨터나 노트북의 전원을 켜면 가장 먼저 만나게 되는 소프트웨어
* 운영체제는 스마트폰, mp3, 내비게이션 등 많은 기기들에도 있다.
* 위의 예와 같이 CPU의 성능이 낮고 메모리 크기도 작은 시스템에 내장하도록 만든 운영체제를 임베디드 운영체제 혹은 임베디드 시스템 이라고 한다.
* 대게 임베디드 운영체제는 CPU의 성능이 낮고 메모리 크기가 작은 기계에 설치되어 일반 OS에 비해 몇가지 기능이 빠져있다.
* OS를 가진 기기와 가지지 않은 기기에는 큰 차이가 있다.
  + OS가 없는 mp3 플레이어는 처음 만들 당시에 구현한 기능 외에는 다른 기능을 추가할 수 없었다.
  + OS가 있는 기기의 경우 음질을 향상하거나 mp3이외의 형식의 음악 파일을 지원하도록 기능을 추가할 수 있다.
  + 또한 통신을 이용해서 인터넷에서 mp3 파일을 다운받거나 공유할 수 있다.
  + 즉, __임베디드 OS를 가진 기기는 기능을 향상시킬 수 있다.__

### 02 운영체제의 필요성
* 초기의 컴퓨터는 정해진 계산만 수행했기 때문에 특별한 규칙이 없었다.
* 그러나 메모리, CPU 등의 성능이 향상되고 여러 작업을 동시에 처리할 수 있는 컴퓨팅 환경이 조성되면서 __규칙이 필요__해졌다.
* 복잡한 작업환경에서 규칙이 없다면 기기를 망가뜨릴수 있으니까!! -> 그래서 OS가 등장했다.

#### * 컴퓨터는 운영체제가 없어도 작동하는가?
* __작동한다.__
* 세계 최초의 컴퓨터로 알려진 에니악은 커다란 기계 덩어리였다. 진공관으로 만들어졌고 미사일 탄도를 계산하기 위해 만들어졌다.
* 운영체제 x, 입/출력장치 x -> 그래도 정상적으로 작동했다.
* 에니악이 컴퓨터인 이유는 프로그래밍이 가능했기 때문이다. 진공관의 연결을 변경함으로써 프로그래밍 효과를 냈다.
* 어떤 변화에 의해 기능을 바꿀 수 있는 것을 컴퓨터라 한다면 에니악은 컴퓨터다.

#### * 운영체제가 있는 기계와 없는 기계는 어떤 차이가 있는가?
* 앞에서도 말했듯이 OS가 없다면 처음 만들 당시에 구현한 기능이외의 기능을 추가하지 못한다.
* 반면 OS가 있다면 기능의 추가나 성능 변경이 가능하여 성능 및 효율성의 향상을 기대할 수 있다.
* 이러한 기계를 __프로그래밍이 가능한(Programmable) 기계__라고 부른다.

#### * 운영체제는 성능을 향상하는 데에만 필요한가?
* 운영체제는 성능 향상뿐 아니라 '자원 관리(resource management)'라는 중요한 역할도 한다. 
* 우리는 컴퓨터를 사용할 때 워드프로세서, 웹 브라우저, 미디어 플레이어 등을 동시에 사용하며 이러한 소프트웨어를 __application program__이라고 한다.
* 이런 많은 application의 개수에 비해 우리가 가진 장치는 키보드, 모니터, CPU 등 제한적이다.
* 대부분 하나의 장치를 가지고 있고 application program은 이 장치를 서로 독차지하려고 한다.
* 예를 들어서 내가 워드와 카카오톡을 함께 하고 있다고 가정하면 이 application program들은 키보드, 모니터와 같은 장치들을 서로 사용하려고 한다.
* 그러다 보면 다른 application program에 손상을 일으킬 수 있고 이것을 해결하기 위해서는 자원을 관리하는 강력한 중재자가 필요하다.
* 이 중재자는 누구에게 먼저 키보드를 주어야하고 누구에게 먼저 모니터를 주어야 할지 등을 결정하고 악의적인 application program으로부터 컴퓨팅 자원을 보호하는 역할도 담당한다.

#### * 사용자는 숨어있는 자원을 어떻게 이용할 수 있는가?
* OS는 사용자가 자원에 직접적으로 접근할 수 없도록 하는 대신 자원을 이용할 수 있는 여러 방법을 제공한다.
* 예로써 사용자가 저장하려는 데이터를 OS에게 주면 OS는 하드디스크의 적당한 장소에 데이터를 저장하고 번호표를 사용자에게 돌려준다.
* 사용자는 자신의 데이터가 하드디스크 어디에 저장되었는지는 모르지만 번호표를 이용해서 데이터를 꺼내거나 수정할 수 있다.
* 이와 같이 사용자가 컴퓨터를 사용할 수 있도록 해주고 그 결과를 알려주는 것은 __interface__라고 한다.
* OS는 사용자가 컴퓨터를 보다 쉽게 사용할 수 있도록 다양한 interface를 제공함으로써 컴퓨터 자원을 보호함과 동시에 사용자의 편의를 도모한다.

#### < 운영체제와 관련된 질문의 답의 요약 >
* OS는 사용자에게 interface를 제공하고 application program에게 컴퓨팅 자원을 골고루 배분해준다.
 또한 적당한 시점에 application program으로부터 자원을 회수하고 악의적인 application program으로부터 컴퓨터를 보호한다.
> 즉, 운영체제는 각각의 application program이 활동할 수 있는 환경을 제공하고 application program이 필요로 하는 컴퓨팅 자원을 나누어주며 컴퓨터 자원을 보호하는 통치자 역할을 한다.

- 펌웨어
> 운영체제는 우리가 사용하는 각종 소프트웨어 중 하나다. 게임이나 문서 편집기 같은 소프트웨어가 특정 목적을 위해 존재한다면, 운영체제는 컴퓨터에 있는 하드웨어(자원)을 
> 조정하고 관리하는 역할을 하므로 하드웨어의 도움 없이 작동하기가 어렵기 때문에 운영체제를 소프트웨어와 하드웨어의 결합 형태인 펌웨어라고 부르기도 한다.

### 03 운영체제의 정의
* OS는 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어이다.
* 레스토랑에 빗대어 본다면 음식을 주문하면 웨이터가 그 음식을 주방에 알려주고 손님은 주문한 음식을 제공받는다.
* 만약 손님이 주방에 들어가서 직접 조리를 하려고 하거나 주방 도구를 만지려고 한다면 관리자가 이를 저지할 것이다. ( 손님이 주방을 맘대로 이용하면 주방이 난장판이 되니까 )
* OS도 마찬가지로 만약 사용자가 하드디스크의 특정 위치에 저장하려고 하면 기존 데이터와 섞여서 엉망이 될 것이므로, OS가 사용자의 요청에 따라 대신 하드디스크에 데이터를 저장하거나 꺼내준다.
* OS는 응용 프로그램이나 사용자에게 컴퓨터 자원을 이용할 수 있는 인터페이스를 제공하고 그 결과를 돌려준다.
* 그리고 응용 프로그램이나 사용자에게 모든 컴퓨터 자원을 숨기고 정해진 방법으로만 컴퓨터 자원을 사용할 수 있도록 제한한다.  
* 하드웨어에 대한 모든 책임을 맡고 있는 OS를 거치지 않고는 하드웨어에 접근할 수 없다.
* 한편 어떤 사람은 직접 자원을 관리하는 것이 편하다고 느낄 수 있는데 이는 집에서 자신의 조리 도구와 재료로 요리하는 것과 같다.
* 그러나 요리를 하기 위해 공동의 작업 공간을 사용하는 경우는 이야기가 달라진다.
* 요리를 하는 것보다 공동의 작업 공간을 관리하고 조리 도구와 재료를 배분하는 것이 더 중요한 문제이기 때문이다.
* 함께 사용하는 조리 도구와 재료를 여러 사람에게 배분하는 일은 관리자가 있어야 원만하게 처리할 수 있고 이를 OS(관리자)가 수행한다.
 
- 인터페이스
> 쉽게 설명하면 자동차의 핸들 및 계기판과 같다. 자동차는 엔진과 바퀴로 움직이지만 운전자가 핸들로 조종하고 계기판을 통해 현재 주행 상황을 인지한다. 마찬가지로 컴퓨터는 CPU와 
> 메모리로 명령을 처리하지만 사용자가 키보드나 마우스로 자료를 입력하고 출력을 얻는다. 즉 OS 인터페이스를 통해서만 컴퓨터 자원을 사용할 수 있다.


### 04 운영체제의 역할
> 지금까지 설명한 운영체제의 필요성과 정의를 바탕으로 운영체제가 어떤 역할을 하는지 좀 더 자세히 알아보자.
#### * 자원 관리
* 우리는 컴퓨터로 문서를 작성하고 음악을 듣고 인터넷 서핑을 한다.
* 이때 키보드, 네트워크카드, 사운드카드 등의 컴퓨터 자원을 사용하는데 OS는 이러한 자원을 응용 프로그램에 나누어 주어 사용자가 원활하게 작업할 수 있도록 돕는다.
* 만약 자원을 요청한 프로그램이 여러 개라면 적당한 순서로 자원을 배분하고 적절한 시점에 자원을 회수하여 다른 응용 프로그램에 나누어준다.

#### * 자원 보호
* 컴퓨터 내의 많은 자원을 관리하는 것뿐만 아니라 악의적인 사용자나 미숙한 사용자로부터 자원을 보호하는 것도 매우 중요하다.
* 고의가 아니라도 어떤 응용 프로그램이 남의 영역을 침범한다면 작업을 망치거나 데이터를 지울 수 있기 때문이다.
* 이러한 비정상적인 작업으로부터 컴퓨터 자원을 지키는 것도 OS의 역할 중 하나다.

#### * 하드웨어 인터페이스 제공
* 우리는 다양한 종류의 하드웨어를 사용한다. 어떤 것은 버튼이 3개인 마우스, 어떤 것은 2개이고 어떤 것은 더 많을 수 있다.
* 이런 제품들을 사용할 때마다 별도의 소프트웨어를 설치해야 한다면 아주 골아프다. OS는 복잡한 과정 없이 다양한 장치를 사용할 수 있도록 다양한 하드웨어를 일관적인 방법으로 사용할 수 있게 해준다
* 하드웨어 인터페이스 지원은 드라이버를 컴퓨터에 설치해야 가능하다. 드라이버는 하드웨어 장치와 상호작용하기 위해 만들어진 컴퓨터 프로그램으로 장치 드라이버, 디바이스 드라이버 등으로 부른다.
* 드라이버는 운영체제를 설치할 때 자동으로 설치되지만 일부의 경우 따로 설치해야하는데 이러한 드라이버를 __하드웨어 인터페이스__ 라고 한다.
* OS는 하드웨어 인터페이스가 자동으로 설치되게 함으로써 하드웨어의 종류에 상관없이 사용할 수 있게 해준다.

#### * 사용자 인터페이스 제공
* 하드웨어 인터페이스가 다양한 부품을 편리하게 사용하기 위한 것이라면, 사용자 인터페이스는 사용자가 OS를 편리하게 사용하기 위함이다.
* 과거에 MS-DOS와 같은 OS로 작업할 때는 마우스 없이 키보드만 사용했기에 여로모로 불편했고 일반인이 사용하기 어려웠다.
* 그러나 지금은 OS가 GUI를 제공하므로 대부분의 작업을 마우스로 수행한다. 더 나아가 스마트폰은 터치스크린을 적용해서 더욱 편리한 인터페이스를 제공한다.
* 손가락을 좌우로 움직이면 넘어가고 손가락 2개를 오므렸다 펼쳤다하면 줌인, 줌아웃이 되는 등 'OS를 편리하게 사용할 수 있도록 제공된 기능이 사용자 인터페이스'다.

- 백신 유틸리티
> 컴퓨터 바이러스는 OS의 영역에 침범하여 시스템을 망치는 프로그램으로 OS는 이러한 악성 프로그램으로부터 컴퓨터 자원과 다른 프로그램을 보호하는 역할도 한다. 
> 사용자의 정보를 빼내어 악용하려는 스파이웨어도 OS가 막아야 하는 바이러스 중 하나이다. 그러나 OS의 기능이 많아지고 구조가 복잡해진 데다 
> 바이러스의 침투 수법이 지능적으로 발전하여 이를 막는 데 한계가 있다. 이로 인해 바이러스 검사, 디스크 조각 모음, 압축 프로그램과 같이 OS의 작업을 보조하는 소프트웨어가
> 등장했는데 이를 유틸리티(utility)라고 부른다.


### 05 운영체제의 목표
> 운영체제가 지향하는 목표는 여러 가지인데 여기서는 운영체제의 역할과 연결지어 목표를 살펴보자
- 자원 관리 <--> 효율성
- 자원 보호 <--> 안정성
- 하드웨어 인터페이스 제공 <--> 확장성
- 사용자 인터페이스 제공 <-- > 편리성
#### * 효율성
* 운영체제의 목표는 자원을 효율적으로 관리하는 것이다.
* 이는 자원 관리와 연결성이 있고 같은 자원을 관리해도 효율적으로 관리해야 한다는 것이다.
* 같은 자원을 사용하여 더 많은 작업량을 처리하거나, 같은 작업량을 처리하는 데 보다 적은 자원을 사용하는 것이다.
* 효율적인 자원 관리는 다양한 방법으로 이루어 질 수 있는데, 일반적으로 OS의 크기를 최소화하고 OS가 사용하는 코드를 최적화한다.
* OS가 필수적으로 사용하는 기본 기능과 효율성을 위해 변형된 기능을 앞으로 구분하여 볼 것이다.

#### * 안정성
* OS는 하드웨어 전체를 관리하는 소프트웨어로 사용자와 응용 프로그램은 OS위에서 작업한다고 볼 수 있다.
* 따라서 OS가 불안정하면 모든 작업이 불안할 수 밖에 없다. OS가 불안하면 피해는 사용자에게 가기 때문에 OS는 안정성이 담보되어야 한다.
* 한 예로 밤을 새가며 문서 작업을 하는데 컴퓨터가 갑자기 꺼져버린다거나 OS가 먹통이 되는 일이 있으면 안된다.
* 안정성은 자원 보호와 연관된다. OS가 안정적이려면 사용자와 응용 프로그램의 안전 문제와 하드웨어적인 보안 문제를 처리할 수 있어야 하며, 시스템에 문제가 발생했을 때 이전으로 복구하는 결함 포용기능을 수행하여야 한다.

#### * 확장성
* OS는 다양한 시스템 자원을 추가하거나 제거하기가 편리해야 한다.
* 이는 OS의 역할 중 하드웨어 인터페이스 제공과 연관되며 OS는 하드웨어 종류 상관없이 꽂으면 바로 실행할 수 있는 플러그 앤드 플레이(plug & play) 기능을 제공해야 한다.
* 또한 확장성을 보장하려면 사용자의 편리성뿐만 아니라 하드웨어 제작자의 편리성도 고려해야 한다.

#### * 편리성
* 사용자가 편리하게 작업하는 것이 OS의 묙표다.
* 이는 OS의 역할 중 사용자 인터페이스 제공과 연관된다. 사실 OS의 입장에서는 효율성을 높이려면 사용자에게 제약을 걸면 된다.
* 예를 들어 GUI를 제공하지 않고 텍스트만 사용하면 OS의 효율성이 높아진다. 그러나 사용자는 마우스를 사용할 수 없어 불편하다.
* 또 다른 예로, 응용 프로그램의 효율성을 높이기 위해 메모리를 100MB 이상 사용하지 못하게 하거나 하드디스크의 사용 공간을 제약하면 시스템의 효율성이 높아질 것이다.
* 그러나 이런 제약은 사용자를 불편하게 할 뿐 아니라 다양한 응용 프로그램 개발을 방해한다.
* 따라서 응용 프로그램과 사용자에게 다양한 편리성을 제공하면서도 자원의 낭비 요소를 막아야한다.
---
## 02 운영체제의 역사
> 운영체제의 역사를 훑어보는 것은 운영체제를 이해하는 좋은 방법이며, 나아가 오늘날의 IT 환경을 이해하는 밑거름이 된다. 이절에서는 현재 쓰이는 운영체제의 기능이 어떻게 만들어지게 되었는지,
> 그리고 P2P, 클라우드 컴퓨팅과 같은 컴퓨팅 환경이 왜 등장하게 되었는지를 운영체제의 발전 과정을 통해 살펴본다.
### 1 개요
>> 운영체제의 역사를 시대순이나 중요한 사건순으로 정리할 수도 있지만 여기서는 주변장치의 개발과 연관지어 설명하겠다.
>> 주변장치의 개발은 운영체제의 발전사를 이해하는 데 중요한 단서가 되기 때문이다. 운영체제의 역사를 간략하게 요약한 표를 보고 깊이있는 내용은 심화에서 다룰 것이다.

| 구분 | 시기 | 주요 기술 | 특징 |
|:---|:---|:---|:---|
| 0기 | 1940년대 | 없음 | * 진공관(0과 1) 사용 |
| 1기 | 1950년대 | 카드 리더, 라인 프린터 | * 일괄 작업 시스템  * 운영체제의 등장 |
| 2기 | 1960년대 초반 | 키보드, 모니터 | * 대화형 시스템 |
| 3기 | 1960년대 후반 | C언어 | * 다중 프로그래밍 기술 개발  * 시분할 시스템 |
| 4기 | 1970년대 | PC | * 개인용 컴퓨터의 등장  * 분산 시스템 |
| 5기 | 1990년대 | 웹 | * 클라이언트/서버 시스템 |
| 6기 | 2000년대 | 스마트폰 | * P2P 시스템(메신저, 파일 공유)  * 그리드 컴퓨팅  * 클라우드 컴퓨팅  * 사물 인터넷 |

### 2 초창기 컴퓨터(1940년대)
> 최초의 컴퓨터인 에니악은 미사일 탄도 계산을 위해 만들어졌다.
> 사람이 주판으로 7시간 동안 계산했던 것을 단 3초 만에 끝냈다.
> 백열전구 같은 모양의 진공관이라는 소자를 사용하여 진공관이 켜지면 1, 꺼지면 0이라고 판단했는데, 이는 컴퓨터가 2진법을 사용하는 계기가 되었다.
> 초기의 컴퓨터는 입출력 장치가 없고 진공관으로 프로그램을 대신했는데, 이렇게 전선을 연결하여 논리회로를 구성하는 것을 __하드와이어링 방식__ 이라고 한다.

### 3 일괄 작업 시스템(1950년대)
> 이제는 IC라는 칩으로 만들어지게 되었다.
> 이 칩은 진공관과 전선으로 만들어진 논리회로를 아주 작은 크기로 구현한 것으로, 이를 이용함으로써 현대적ㅇ니 모습의 컴퓨터가 탄생했다.
> 이때의 컴퓨터에는 미약하지잠 CPU와 메인메모리가 있었지만 입출력 장치가 없었다.
> 대신 천공카드 리드를 입력장치로, 라인프린터를 출력장치로 사용했다.
  - 천공카드 : 카드에 구멍을 뚫어 문자나 숫자를 표현했다.
  - 라인 프린터: 문자만 출력하는 프린터로 한 번에 한 줄씩 출력하기 때문에 라인 프린터라는 이름이 붙었다.
> 이것은 매우 불편하지만 현대적인 프로그래밍을 가능하게 해주었다.
> 천공카드 리더를 사용하는 경우 프로그램만 바꾸면 다른 작업이 가능했다.
> 요즘은 음악을 들으면서 문서 작업을 하는 등 동시에 여러 작업이 가능하지만 당시는 한번에 한가지만 가능했다.
> 천공카드 리더로 하나의 작업을 읽어들여 실행하고 결과를 출력한 후 다음 작업을 읽어들여 실행했다. 
> 이러한 시스템에서는 작업에 필요한 프로그램과 데이터를 동시에 입력해야 작업이 가능하다.
> 지금의 프로그래밍 환경과 달리 모든 작업을 한꺼번에 처리해야 하고 프로그램 실행 중간에 사용자가 데이터를 입력하거나 수정하는 것이 불가능한데, 이러한 시스템을 일괄 작업 시스템 또는 일괄 처리 시스템이라고 부른다.
> 이는 OS 전반에 걸쳐 자주 인용되는 시스템이니 꼭 기억하자.
> 일괄 작업 시스템은 비록 작기는 하지만 OS가 사용되었기 때문에 메인메모리가 OS의 상주 영역과 사용자의 사용 영역으로 나뉘어 있으며, 현재 거의 사용되지 않지만 그 흔적이 남아 있다.
> 윈도우 os가 사용하는 파일 중 부팅 시 읽는 config.sys, autoexec.bat 파일이 있는데 autoexec.bat의 확장자 bats는 'batch job'을 의미한다.
> autoexec.bat 파일은 OS가 시작할 때 한꺼번에 처리해야 할 작업을 모아놓은 것이다.

### 4 대화형 시스템(1960년대 초반)
> 이 시기에 입출력 장치가 등장했다. (모니터, 키보드)
> 키보드는 타자기의 쿼티 자판에 다양한 키를 추가하여 만들었고 브라운고나 기반의 TV와 유사했던 초기의 모니터는 컬러가 아니라 단색(초록색 또는 오랜지색)이었다.
> 이러한 키보드와 모니터는 매우 비효율적인 일괄 작업 시스템의 방식을 획기적으로 바꾸었다.
> 원래는 결과값만 볼 수 있고 작업 중간 수정이 불가했지만 중간 결과값을 출력할 수 있고 수정이 가능하게 되었다.
> 이러한 시스템을 __대화형 시스템__ 이라고 하고 이것의 등장으로 문서 편집기, 게임과 같은 다양한 종류의 응용 프로그램을 만들 수 있게 되었다.
> 한 가지 문제점은 일괄 작업 시스템은 작업 시간 예측이 가능했지만 대화형 시스템은 작업 시간을 예측하기 어려웠다.

< CPU 집중 작업과 입출력 집중 작업 >
- CPU 집중 작업: 일괄 작업 시스템에서는 프로그램이 실행되는 동안에 입출력이 불가능하기 때문에 대부부의 작업이 CPU만 사용하는 계산 작업이었다. 이를 CPU 집중 작업, CPU 편향 작업, 컴퓨터 집중 작업이라고 부른다. 수학 계산과 같은 프로그램은 CPU 집중 작업의 대표적 예다.
- 입출력 집중 작업: 대화형 시스템에서는 프로그램이 실행되는 동안에 입출력이 가능하기 때문에 입출력 집중 작업이 생겨났다. 입출력 집중 작업 또는 입출력 편향 적업은 대부분의 작업 시간을 주변장치의 입력과 출력에 사용하며, 동영상 플레이어와 데이터 베이스 같은 프로그램을 예로 들 수 있다.

### 5 시분할 시스템(1960년대 후반)
#### 5.1 시분할 시스템의 개념
> 1960년도 후반에는 컴퓨터가 작아지고 성능은 우수해졌는데 이게 엄청 비쌌다.
> 이런 비싼 기계로 하나의 프로그램만 돌리기는 너무 아깝다 보니까 다중 프로그래밍이 개발되었다.
> 다중 프로그래밍은 하나의 CPU가 여러 작업을 동시에 실행하는 기술로, 한 번에 하나의 작업만 가능한 일괄 작업 시스템에 비해 효율성이 뛰어났다.  
> 여러 작업이 하나의 CPU를 공동으로 사용하면 작업이 끊겨 보일 텐데 다중 프로그래밍 시스템에서는 여러 작업이 동시에 실행되는 것처럼 보인다. 이는 시간을 분할하는 방법 때문이다.
> 영화 필름도 한장 한장의 사진이지만 빠르게 보여줌으로써 동영상이 된다.
> 다중 프로그래밍은 CPU 사용 시간을 잘게 쪼개 여러작업을 한다. 
> 예를 들어 A, B, C 작업을 동시에 실행한다고 가정하면 CPU가 각 작업에 1초를 할당하면 끊기지만 0.1초를 할당하면 안끊긴다.
> 이러면 A,B,C가 전부 동시에 실행되는 것처럼 보인다.
> 이처럼 여러 작업을 조금씩 처리해서 동시에 실행되는 것처럼 보이게 하는 것을 시분할 시스템이라고 한다.
> 이때 잘게 나뉜 시간 한 조각을 타임 슬라이스 또는 퀀텀이라고 한다.
> 시분할 시스템의 단점은 여러 작업을 동시에 처리하기 위한 추가 작업이 필요하다는 것이다.
> 또한 시스템 내에 많은 양의 작업이 공존할 경우, 중요한 작업이 일정 시간 안에 끝나는 것을 보장하지 못한다.
> 예를 들어 원자력, 미사일을 제어하는 시스템은 매우 중요해서 일정 시간안에 끝나지 않으면 심각한 문제가 발생한다.
> 그래서 이럴 경우 시분할 시스템을 사용하지 않고 특정 시스템에서 일정 시간 안에 작업이 처리되도록 보장하는 실시간 시스템을 사용한다.

< 경성 실시간 시스템과 연성 실시간 시스템 >
* 경성 실시간 시스템(hard real-time system): 지정한 응답 시간을 정확히 지키는 시스템으로 원자력 발전소의 원자로 온도 제어, 미사일 요격과 같은 작업에 이용된다.
* 연성 실시간 시스템(soft real-time system): 지정한 응답 시간을 최대한 지키지만 융통성이 어느 정도 허용된 시스템이다.
한 예로 동영상 재생기는 응답 시간 안에 작업이 처리되지 않으면 끊김 현상이 발생하지만 치명적인 결과를 낳지는 않는다.

#### 5.2 다중 사용자 시스템
> 시분할 시스템에서 동시에 실행되는 작업의 개수를 멀티 프로그램이 수준(level) 또는 멀티프로그램 정도(degree)라고 한다.
> 시분할 시스템에서 여러 작업을 동시에 한다는 것은 한 사람이 여러 작업을 한다는 의미와 여러 사람이 작업을 한다는 의미를 가진다.
> 즉, 시분할 시스템은 하나의 컴퓨터에서 여러 명이 작업하는 다중 사용자 시스템을 가능하게 했다.
> 이 시기에 AT&T 벨 연구소에서 C 언어로 유닉스를 개발했고 유닉스는 멀티프로그래밍과 다중 사용자를 지원하는 OS로서, 소스코드를 공개하고 다양한 업체 및 프로그래머와 공동 작업 끝에 탄생한 작고 안정적인 OS이다. 

### 6 분산시스템(1970년대 후반)
> 1977년 스티브 잡스가 최초의 개인용 컴퓨터인 '__애플 IT__ '를 발표했다.
> 이제는 개인이 컴퓨터를 소유하는 시대가 온 것이다. 이 시기에 소프트웨어, OS가 급속도로 발전했다.
> 개인용 컴터의 OS로 애플의 매킨토시와 마이크로소프트의 MS-DOS가 많이 사용되었다.
> 또 인터넷이 등장한 시기이다.1960년도 미국은 서로 호환되지 않는 LAN들을 하나로 묶기 위한 연구를 했는데, 그 결과 아르파넷이 만들어졌다.
> 이후 아르파넷이 대중들에게 개방되고 컴퓨터 간의 네트워킹을 위한 TCP/IP 프로토콜이 정의되었다.
> 개인용 컴퓨터와 인터넷 덕에 새로운 컴퓨팅 환경이 조성되었고 당시 복잡한 계산을 위해 큰 메인프레임이라는 비싼 컴퓨터를 사용했는데 개인용 컴퓨터와 인터넷이 보급되면서 싸고 작은 컴퓨터들을 하나로 묶어서 대형 컴퓨터에 버금가는 시스템을 만들게 되었는데 이를 __분산 시스템__ 이라고 한다.
> 분산 시스템은 네트워크 상에 분산된 여러 컴퓨터로 작업을 처리하고 결과를 상호 교환하는 방식이다.

<img src="https://user-images.githubusercontent.com/78334910/147842788-455b5aea-d237-4884-b22f-fa7a33bc2c0f.jpg">

### 7 클라이언트/서버 시스템(1990년대~현재)
> 분산 시스템은 모든 컴퓨터가 동일한 지위이기 때문에 컴퓨터가 고장 나거나 추가되면 작업을 분배하고 결과를 모으기가 쉽지 않다.
> 클라이언트/서버 구조는 이러한 문제점을 해결하는 기술로 모든 컴퓨터의 지위가 동일한 분산 시스템과 달리 작업을 요청하는 클라이언트와 거기에 응답하여 요청받은 작업을 처리하는 서버의 이중 구조로 나뉜다.
> 이 구조가 일반인들에게 알려진 것은 웹 시스템이 보급된 이후이다.
> 웹 시스템의 등장으로 그림이나 링크를 통한 다양한 응용 서버스가 가능해지자 인터넷을 사용하는 일반인이 급속도로 늘어나게 되었는데, 웹 시스템은 전형적인 클라이언트/서버 구조이다.
> 이 시스템의 문제점은 서버 과부하이다. 모든 요청이 서버로 들어가서 많은 서버와 큰 용량의 네트워크가 필요하다.

< 데몬 >
* 클라이언트/서버 시스템에서는 서버가 멈추지 않고 계속 작동하여 클라이언트의 요청을 처리해야하는데 이렇게 멈추지 않고 계속 작동하는 프로그램을 데몬이라고 한다. 
* 보통은 데몬을 가진 컴퓨터를 서버라고 부르며, 웹 데몬이 설치된 컴퓨터는 웹 서버, FTP 데몬이 설치된 컴퓨터는 FTP 서버, 이메일 데몬이 설치된 컴퓨터는 이메일 서버라고 한다.
* 웹 데몬의 역할을 하는 프로그램으로는 아파치 톰캣, IIS 등이 있다.

### 8 P2P 시스템(2000년대 초반~현재)
#### 8.1 P2P 시스템의 개념
> 1990년대 말에 전 세계의 MP3 음악 파일을 공유하려는 시도가 있었는데 문제는 서버 과부하였다.
> 서버의 부하를 줄일 수 있는 새로운 시스템으로 P2P 시스템이 만들어졌다.
> peer는 말단 노드, 즉 사용자의 컴퓨터를 가리키며, P2P는 서버를 거치지 않고 사용자와 사용자를 직접 연결한다.
> P2P 시스템에서는 서버가 파일 검색만 맡고 사용자 간에 파일 전송이 이루어지기 때문에 서버의 부하가 적다는 것이 장점.

<img src="https://user-images.githubusercontent.com/78334910/147842755-bb685e8b-c76a-4a11-86e8-6418862e3ae9.png">

#### 8.2 P2P 시스템의 예: 메신저
> P2P 기술은 불법 소프트웨어 기술 규제 때문에 발전하지 못하다가 메신저 프로그램에 도입되어 큰 발전을 이루었다.
> 수만 명이 동시에 채팅을 하고 파일을 주고받는 메신저 시스템은 클라이언트/서버로 구현 불가능하다.
> 메신저에 로그인을 하면 먼저 서버에 접속하여 사용자 인증과 출석 등의 정보를 받고 출석은 친구나 관련자가 어디에 있는지, 어떤 상태인지 확인하는 과정을 말한다.
> 이런 절차가 끝나면 사용자 간에 직접 채팅을 하거나 데이터를 전달할 수 있다.

#### 8.3 P2P 시스템의 예: 파일 공유
> 대용량 파일 공유도 P2P 시스템의 발전에 한몫을 했다.
> 합법, 불법이냐라는 문제가 남아있지만 MP3 파일 공유 시스템의 단점을 보완하며 발전중이다.
> 기존 MP3 파일 공유 시스템은 사용자 간에 MP3 파일 전송 도중 보내는 쪽에서 프로그램을 꺼버리면 전송이 중단되었다.
> MP3 파일은 크기가 작으니 다시 받으면 되나 수백메가의 동영상이라면 당황스러울 것이다.
> 대용량 파일 공유 P2P 시스템은 같은 파일을 가진 여러 사람으로부터 데이터를 나누어 받는다.
> 예를 들면 k.avi라는 동영상을 받는다면 k.avi를 가진 여러 사용자로부터 조금씩 나누어 받아 하나의 파일을 완성하는 것이다.
> 10명에게 데이터를 받는다면 1명에게 받을 때보다 속도가 10배 빠를 뿐 아니라, 데이터를 바든ㄴ 도중 1~2명이 프로그램을 중단해도 다른 사람에게 나머지를 받을 수 있다.

<서버가 없는 P2P, 서버가 있는 P2P>
* 메신저는 사용자 인증과 출석 정보, 과거 데이터 보관 등을 위해 서버가 있는 P2P
* 서버가 없는 P2P의 대표적인 예로는 비트코인의 블록체인을 꼽을 수 있다.
* 비트코인을 사고 팔 때 거래내역을 장부에 기록해야하는데 실물이 없는 가상화폐의 경우 그 기록을 누가 관리할지 정할 수 없다.
* 혹여나 관리자를 뽑아도 장부 조작을 하거나 없애면 화폐의 가치가 사라진다.
* 이에 비트코인 블록체인 기법을 사용하여 서버가 없는 완전한 P2P 방식으로 거래 장부 문제를 해결했다.
* 블록체인 기법은 P2P 시스템 전체에 거래 장부를 분산시킴으로써 하나의 장부가 조작되거나 유실되어도 거래에 영향을 미치지 않는다. 전체 시스템의 50% 이상이 동의했을 경우에만 거래 장부의 변경이 가능하도록 하여 악의적 공격을 막는다.
<img src="https://user-images.githubusercontent.com/78334910/147842929-24911333-1972-4203-8ff4-71c1f53c48f8.png">

### 9 기타 컴퓨팅 환경(2000년대 초반~현재)
> 2000년대 초반에는 P2P 컴퓨팅 환경과 더불어 그리드 컴퓨팅, 클라우드 컴퓨팅, 사물 인터넷 등의 새로운 컴퓨팅 환경이 탄생했다.
#### 9.1 그리드 컴퓨팅
> 토이 스토리와 같은 3D 애니메이션을 제작한다고 가정해보자. 애니메이션 제작자는 고성능 컴퓨터를 다량 구매하여 몇 년에 걸쳐 애니메이션을 제작할 텐데, 컴퓨터의 성능이 급속도로 발전하기 때문에 애니메이션이 오나성되면 컴퓨터가 쓸모없어진다.
> 이런 경우 필요한 기간만 컴퓨터를 사용하고 비용을 지불할 수 있다면 좋을 것이다.
> 이처럼 필요한 컴퓨팅 자원만 구매하여 사용하는 컴퓨팅 환경을 그리드 컴퓨팅이라고 한다.
> 그리드 컴퓨팅은 분산 시스템의 한 분야로 사로 다른 기종의 컴퓨터들을 묶어 대용량 컴퓨터 풀을 구성하고 이를 원격지와 연결하여 대용량 연산을 수행하는 컴퓨팅 환경이다. 대용량 데이터의 연산을 소규모 연산으로 나누어 여러 대의 컴퓨터로 분산시킨다는 점에서 분산 시스템이라고 볼 수 있다.
> 그리드 컴퓨팅은 CPU 관리, 저장소 관리, 보안 조항, 데이터 이동, 모니터링과 같은 서비스를 위한 표준 규약 생서에 기여했다.
> 일반인은 웹 하드 서비스에서 그리드 시스템을 경험할 수 있다.
> 서버에 엄청난 양의 데이터를 보관하고 있는 웹 하드는 사용자에게 데이터를 전송할 때 과부하가 걸리기도 하여 이를 해결하기 위해 대용량 데이터 P2P 시스템 기술을 사용한다.
> K.avi 파일을 웹하드에서 내려받으려고 하면 서버가 주는 것이 아니라 전에 k.avi 파일을 내려받은 컴퓨터로부터 몰래 데이터를 빼와서 전달하는데 이런 기술을 그리드 딜리버리라고 한다.
> 그리드 딜리버리는 사용자의 컴퓨터를 느리가 하는 주범으로,일부 서비스 업체가 무료로 웹 하드 이용권을 나누어 주는 것은 이를 위함이다.
> 그리드 컴퓨팅이 하드웨어적인 컴퓨팅 호나경의 통합이라면 SaaS는 사용자가 필요할 때 소프트웨어 기능을 이용하고 그만큼 비용을 지불하는 개념이다.
> 일반적으로는 소프트웨어를 사용자의 컴퓨터에 설치하고 사용하지만 SaaS는 필요한 기능만을 서버에서 실행하고 사용자는 인터넷을 통해 필요한 서비스만 제공받으며 월별로 혹은 서비스를 이용한 만큼 비용을 지불한다.
> SaaS의 가장 큰 장점은 프로그램을 깔거나 업데이트를 할 필요없이 인터넷에 접속하면 누구나 이용할 수 있다는 것이다.
#### 9.2 클라우드 컴퓨팅
> 클라우드 컴퓨팅은 언제 어디서나 응용 프로그램과 데이터를 자유롭게 사용할 수 있는 컴퓨팅 환경으로 그리드 컴퓨팅과 SaaS를 합쳐놓은 형태이다. 하드웨어를 포한한 시스템이 구름에 가려 보이지 않는 컴퓨팅 환경이라는 의미에서 클라우드이다.
> 회사 홈페이지를 제작하는 경우를 생각해보자. 과거에는 회사에 서버를 설치하거나 IDC에 서버를 두고 서비스를 했는데, 둘 다 홈페이지 관리 외에 서버 관리, 네트워크 관리, 보안 관리 등을 사내 인력으로 소화해서 비용이 많이 들고 복잡했다.
> 그러나 클라우드 컴퓨팅 환경에서는 클라우드 서버에 회사 홈페이지를 올려놓고 사용한 만큼 비용을 지불하면 되며, 서버 관리와 네트워크 관리는 클라우드 서버 제공자가 알아서 해주기 때문에 편리하다.
> 이제는 클라우드 컴퓨팅이 일반인에게도 활용된다. 백업을 클라우드에 해놓고 내려받는 등의 기능을 이용할 수 있다.\
#### 9.3 사물 인터넷
> 사물 인터넷은 사물에 센서와 통신 기능을 내장하여 인터넷에 연결하는 기술이다.
> 인터넷은 연결된 사물들이 데이터를 주고받아 스스로 분석하고 학습한 정보를 사용자에게 제공하거나 새로운 서비스를 창출하는 사물 인터넷은 인공지능, 로봇 공학, 무인 운송 수단, 3D 인쇄, 나노 기술과 더불어 4차 산업혁명을 이끄는 기술이다.
> 지하철과 버스의 도착 예정 시간을 알려주고 각종 전자 제품을 스마트폰으로 제어하는 등 사물 인터넷 기술도 점차 대중화되고 있다. 재난 방지 시스템, 안드로이드 OS를 이용한 커넥트카, 에너지를 제어하는 스마트 그리드, 공공 기물을 관리하는 스마트 시티 등 다양한 분양에서 사물 인터넷이 사용되고 있다.
---
## 03 운영체제의 구조
### 1 커널과 인터페이스
> 커널은 프로세스 관리, 메모리 관리, 저장장치 관리와 같은 OS의 핵심적인 기능을 모아놓은 것으로 자동차에 비유하면 엔진에 해당한다.
> 자동차의 종류는 다양하지만 엔진에 의해 성능이 좌우되는데, 이처럼 OS의 성능은 커널에 의해 좌우된다.
> 안드로이드, IOS 같은 경우도 커널이 존재한다. (안드로이드 공개, IOS 공개 X)
> 자동차가 움직일 땐 엔진 뿐만 아니라 핸들, 브레이크 등이 필요하고 현재 시속, 기어의 상태, 엔진의 온도 등을 알려주는 계기판이 필요한데 이를 인터페이스라고 한다.
> OS에도 인터페이스가 존재하는데 커널에 사용자의 명령을 전달하고 실행 결과를 사용자에게 알려주는 역할을 한다.

<img src="https://user-images.githubusercontent.com/78334910/147851473-65e9565c-0b98-4355-849a-a301fbef07f4.png">
> 위 그림을 보면 OS는 크게 두 부분으로 나뉜다. 사용자와 응용프로그램에 인접하여 커널에 명령을 전달하고 사용자에게 실행결과를 돌려주는 인터페이스와 OS의 핵심 기능을 모아놓은 커널이다.
> OS는 커널과 인터페이스를 분리해서 다른 인터페이스를 가지게 만들 수 있고 같은 커널이라도 다른 인터페이스가 장착되면 사용자에게는 다른 OS처럼 보인다.
> 유닉스를 예로 보면 유닉스의 사용자 인터페이스는 shell이라고 하고 여러 종류의 셸이 있다.
> 유닉스는 CLI로 구성이 되어 사용자에게 어렵지만 같은 계열의 Mac OS X는 인터페이스를 다르게 하여 GUI가 풍부하다.
> 엄밀히 말하면 두 개는 같은 OS에서 출발한 것이다. 근데 인터페이스에 따라 달라진다.

### 2 시스템 호출과 디바이스 드라이버
#### 2.1 시스템 호출
> 시스템 호출은 커널이 자신을 보호하기 위해 만든 인터페이스이다. 커널은 사용자나 응용 프로그램에서 직접 접근하는 것을 막는다. 시스템 콜을 이용하여 접근해야 한다.
> 직접 접근은 사용자가 모든 것을 처리해야 한다. 커피를 만든다면 커피, 설탕과 같은 재료는 어디있는지 커피 머신은 어떻게 사용하는 지 등을 알아야 하고 내 입맛대로 만들 수 있지만 부주의로 커피 머신이 망가질 수 있다.
> 시스템 콜은 카페에 가서 커피를 시키는 과정이다. 종업원에게 아메리카노를 달라고 하고 기다리면 아메리카노가 나온다. 중간 과정에 대해 알아야 하는 부분이 없다.
> 어떤 응용 프로그램이 숫자 14, 다른 응용 프로그램이 숫자 21을 저장한다고 가정하자.
> 직접 접근은 두 프로그램이 자기 마음에 드는 위치에 데이터를 저장하려 할 것이다. 이 경우 다른 사람의 데이터를 지울 수 있고 내 데이터가 지워질 수 있다.
> 시스템 호출은 내가 직접 접근하지 않고 커널이 제공하는 인터페이스 함수 (ex. write())를 이용하여 저장하라고 요청을 하고 어떻게 저장되는지 어디에 저장되는지는 알 수 없다. 만약 내가 저장했던 데이터를 읽고 싶다면 다른 인터페이스 함수 (ex. read())를 이용하여 가져오면 된다.
> 커널이 자원 관리를 책임지기에 훨씬 더 편리하다.
> C언어에서 printf() 또한 시스템 콜 중 하나이다.
> 시스템 콜은 커널이 제공하는 시스템 자원의 사용과 연관된 함수이다.
> 응용 프로그램이 하드웨어 자원에 접근하거나 OS가 제공하는 서비스를 이용하려 할때는 시스템 콜을 이용해야 한다.
> OS는 커널이 제공하는 서비스를 시스템 콜로 제한하고 다른 방법으로의 접근은 막는다. (자원 보호)
> 시스템 콜은 커널이 제공하는 서비스를 이용하기 위한 인터페이스이며, 사용자가 자발적으로 커널 영역에 접근할 수 있는 유일한 수단이다.

< API와 SDK >
1. API
  * 시스템 콜과 유사한 용어로 API가 있다.
  * API는 응용 프로그램이 자신과 연관된 프로그램을 만들 수 있도록 제공하는 인터페이스이다.
  * 카카오 맵 API을 생각하면 된다.
  * API는 시스템 콜보다 더 광범위한 개념이고 OS의 API를 시스템 콜이라고 정의할 수 있다.
2. SDK
  * 프로그램 개발자를 위해 API 및 API 사용 매뉴얼뿐만 아니라 프로그램 개발에 필요한 코드 편집기와 에뮬레이터 같은 각종 개발용 응용 프로그램까지 하나로 묶어서 배포하는 개발 툴을 말한다.
  * 한마디로 개발자를 위한 종합 선물 세트라고 할 수 있으며, 대표적인 예로 안드로이드 스튜디오가 있다.

#### 2.2 드라이버
* 응용 프로그램-커널의 인터페이스가 시스템 콜이라면 커널-하드웨어의 인터페이스는 드라이버다.
* 하드웨어의 종류가 엄청 많은데 OS에서 모든 하드웨어를 다 사용하게 하려면 거기에 맞는 프로그램을 개발해야한다.
* 때문에 하드웨어 제작자가 관련 소프트웨어를 만들어야 한다.
* 커널은 입출력의 기본적인 부분만 제작하고, 하드웨어의 특성을 반영한 소프트웨어를 받아서 커널이 실행될 때 함께 실행해준다.
* 이때 하드웨어 제작자가 만든 소프트웨어를 디바이스 드라이버라고 한다. 마우스, 키보드와 같이 복잡하지 않은 디바이스 드라이버는 커널에 포함되어 있어서 꽂으면 실행이 되지만 그래픽카드, 프린터와 같이 크기가 크고 복잡한 놈은 사용자가 직접 설치해야 한다.
(위에 운영체제 구조를 한번 보고 온나)

### 3 커널의 구성
> 운영체제의 핵심 기능을 모아놓은 커널이 주로 하는 일은 프로세스 관리, 메모리 관리, 파일 시스템 관리, 입출력 관리, 프로세스 간 통신(Inter Process Communication, IPC) 관리 등이다.
> 커널의 핵심 기능은 유기적으로 복잡하게 얽혀있고 이러한 기능을 어떻게 구현하는가에 따라 단일형 구조 커널, 계층형 구조 커널, 마이크로 구조 커널로 구분된다.

| 핵심 기능 | 설명 |
| :--- | :--- |
| 프로세스 관리 | 프로세스에 CPU를 배분하고 작업에 필요한 제반 환경을 제공한다. |
| 메모리 관리 | 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공한다. |
| 파일 시스템 관리 | 데이터를 저장하고 접근할 수 있는 인터페이스를 제공한다. |
| 입출력 관리 | 필요한 입력과 출력 서비스를 제공한다. |
| 프로세스 간 통신 관리 | 공동 작업을 위한 프로세스 간 통신 환경을 지원한다. |

#### 3.1 단일형 구조 커널
* 단일 형 구조 커널은 초창기의 OS 구조로, 커널의 핵심 기능을 구현하는 모듈들이 구분 없이 하나로 구성되어 있다.
* 대표적인 예로는 MS-DOS, VMS, 초기의 유닉스 OS이다.
* 초기엔 기능을 구현하기 바빴기에 모듈을 분리할 여력이 없었다. 프로그램에 비유하면 함수없이 main()에 다 때려넣은 느낌이다.

+ 장점
  * 모듈이 분리되지 않아서 모듈 간 통신 비용이 줄어들어 효과적인 운영이 가능하다. main문에만 넣으면 함수 호출 오버헤드가 줄어드는 그런 느낌
 
+ 단점
  * 모듈이 하나로 묶여있어 버그, 오류 처리가 어렵다.
  * OS의 여러 기능이 서로 연결되어 있어 상호 의존성이 높아 기능상의 작은 결함이 시스템 전체로 확산될 수 있다.
  * 다양한 환경의 시스템에 적용하기 어렵다. 단일형 구조에서는 수정이 어려워 이식성이 낮다.
  * 현대의 OS는 크고 복잡하여 단일형으로 구현이 어렵다.
<img src="https://user-images.githubusercontent.com/78334910/147852848-c238d747-0122-452d-9447-b0b085118906.png">

#### 3.2 계층형 구조 커널
* 계층은 구조 커널은 단일형이 발전한 형태로 비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만들고 계층 간 통신을 통해 OS를 구현하는 방식이다.
* 비슷한 기능, 구조를 묶어 계층화 했기에 버그, 오류의 처리가 좀 더 쉬워졌다.
* 오류가 발생했을 때 전체 커널 수정을 하는게 아니라 해당 계층만을 수정하여 디버깅하기도 쉽다.
* 오늘날의 OS는 대부분 이 구조로 이루어져 있다.
<img src="https://user-images.githubusercontent.com/78334910/147852875-bf1f1d6f-54b0-4e22-a152-6b857f08fefb.png">

#### 3.3 마이크로 구조 커널
* 계층형 구조 커널은 계속 계층과 기능이 추가되면서 커널의 크기가 계속 커지고 필요한 하드웨어의 용량이 늘어갔다.
* 이러한 계층형 구조 커널의 접근 방식과 반대로 개발된 커널이 마이크로 구조 커널이다.
* 프로세스 관리, 메모리 관리, IPC 등 가장 기본적인 기능만 제공한다.
* 커널의 구조를 살펴보면 다른 커널에 비해 OS의 많은 부분이 사용자 영역에 구현되어 있다.
* 커널은 메모리 관리와 프로세스 간 동기화 서비스를 제공하며, 메모리 관리자와 동기화 모듈은 IPC 모듈로 연결된다.
* 각 모듈은 세분화되어 존재하고 모듈 간 정보 교환은 IPC를 이용한다.
* 각 모듈은 독립적으로 작동하여 하나의 모듈이 실패해도 전체 OS가 멈추지 않는다.
* 또한 이식성이 뛰어나고 커널이 작아 CPU 용량이 작은 시스템에도 적용가능하다.
<img src="https://user-images.githubusercontent.com/78334910/147853019-0ab54f35-90e9-4768-a996-abc66cbc4dd0.png">

### 4 가상 머신
* C언어는 윈도우 운영체제와 호환되지 않는다. 그래서 윈도우 OS와 호환하기 위해 수정하는 과정이 필요하다.
* 유닉스에서도 많은 버전이 있고 거기에 따라 조금씩 수정이 필요하다.
* 이것을 해결하기 위한 언어가 자바다. 자바는 OS 위에 가상머신을 만들고 그 위에서 응용 프로그램이 작동하게 하는 것이다.
* 가상 머신은 OS와 응용 프로그램 사이에서 작동하는 프로그램으로 가상머신을 설치하면 응용 프로그램이 모두 동일한 환경에서 작동하는 것처럼 보인다.
* 가상머신은 다양한 곳에서 사용된다. 예로써 윈도우 OS에서 유닉스를 사용하고 싶다하면 원래는 두 개의 OS를 같이 설치하고 부팅시 어떤 OS를 사용할지 선택해야 한다.
* 그러나 윈도우 OS에 유닉스 가상머신을 이용하면 둘 다 쓸 수 있다
* 가상머신을 사용하면 호환성이 높아지지만 응용 프로그램이 가상머신을 통해서만 작동하기에 느려진다는 단점이 있다.













































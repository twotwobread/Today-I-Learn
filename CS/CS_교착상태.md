# 01 교착 상태의 개요
## 1 교착 상태의 정의
> 교착 상태 (deadlock) : 2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태  
- 교착 상태와 아사 현상의 차이점
  + 아사 현상 : OS가 잘못된 정책을 사용하여 특정 프로세스의 작업이 지연되는 문제
  + 교착 상태 : 여러 프로세스가 작업을 진행하다 보니 자연적으로 발생하는 문제
  + 따라서 OS는 감시를 하다가 교착 상태가 발생 시 강압적으로 해결해야 함.
## 2 교착 상태의 발생
- 시스템 자원
  + 다른 프로세스와 공유할 수 없는 자원 사용 시 발생.
    - ex. P1은 프린터를 할당받고 CD 레코더를 기다리고 P2는 CD 레코더를 할당받고 프린터를 기다리는 상황.
- 공유 변수
  + 무한 대기를 막지 못하는 경우 교착 상태 발생.
    - ex. P1과 P2가 같이 cs에 접근시도를 하면서 lock1, lock2가 모두 true가 되는 경우 무한 대기가 발생하고 한 변 수를 할당받은 상태에서 다른 변수를 기다리면서 교착 상태 발생.
- 응용 프로그램
  + 데이터베이스 같은 응용 프로그램에서도 교착 상태 발생.
  + 여러 프로세스가 데이터 베이스에 저장된 데이터를 사용하는 경우 일관성을 유지해야 함.
    - ex. 프로세스가 데이터 베이스에 동시에 접근을 하면서 일관성이 깨지는 경우 발생 -> 이걸 막기 위해 lock을 이용하는데 이 경우 교착 상태 발생 가능.
## 3 자원 할당 그래프
- 프로세스가 어떤 자원을 사용 중이고 어떤 자원을 기다리고 있는지를 방향성이 있는 그래프로 표현한 것.
- 프로세스는 원, 자원은 네모로 표시하고 자원을 할당받고 있는 경우는 실선으로 자원 -> 프로세스, 자원을 기다리고 있는 경우 실선으로 프로세스 -> 자원
- 2개 이상의 프로세스를 할당 받을 수 있는 자원 존재
  + 여러 프로세스가 하나의 자원을 동시에 이용하는 경우 : 다중자원, 사각형안에 점의 갯수로 사용가능한 자원의 갯수 표현.
- 예로 식사하는 철학자 문제를 살펴보자.
  + 철학자 4명이 둥근 식탁에 둘러앉아 식사를 하는데, 왼쪽의 포크를 잡고 오른쪽의 포크를 잡아야만 식사가 가능하다는 조건이 존재.
  + 이 경우 철학자들은 왼쪽 포크를 집고 오른쪽을 보지만 이미 다른 철학자가 왼손으로 포크를 집고 있을 것.
  + 그럼 오른쪽 포크를 모두 집지 못해 굶어 죽는다는 문제.
  + 교착 상태로 생각하면 P1~P4가 자원 R1~R4를 할당받고 다른 자원을 계속 기다리는 경우 교착 상태 발생.
  + 해당 문제에서 교착 상태가 발생하는 조건
    1. 철학자들은 서로 포크를 공유할 수 없음. -> 자원을 공유하지 못하면 교착 상태가 발생.
    2. 각 철학자는 다른 철학자의 포크를 빼앗을 수 없음. -> 자원을 빼앗을 수 없기에 자원 할당 해제까지 대기해야 하여 교착 상태 발생.
    3. 각 철학자는 왼쪽 포크를 잡을 채 오른쪽 포크를 기다림. -> 자원 하나를 잡은 상태에서 다른 자원을 기다리면 교착 상태 발생.
    4. 자원 할당 그래프가 원형임. -> 자원을 요구하는 방향이 원을 이루면 양보를 하지 않기 때문에 교착 상태 발생.
# 02 교착 상태 필요 조건
## 1 교착 상태 필요조건
> 교착상태는 아래의 조건을 모두 충족할 시 발생 -> 하나라도 충족하지 않으면 발생 X  
- 상호 배제( mutual exclusion ) : 배타적 자원은 cs로 보호되어 다른 프로세스가 동시에 사용 불가 -> 배타적 자원을 사용하면 교착 상태 발생.
  + 배타적 자원 : 한 프로세스가 사용하는 자원 ( 다른 프로세스와 공유 불가 )
- 비선점( non-preemption ) : 자원을 빼앗을 수 없는 경우 공유할 수 없어서 교착 상태 발생.
- 점유와 대기( hold and wait ) : 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태.
  + 다른 프로세스를 방해하려면 다른 프로세스가 원하는 자원을 할당받은 상태에서 다른 자원을 기다려야 함.
- 원형 대기( circular wait ) : 점유와 대기 중인 프로세스 간의 관계가 원을 이루어야 함.
  + 점유와 대기 중인 프로세스들이 서로 방해하는 방향이 원을 이뤄야 서로 양보하지 않기에 교착 상태 발생.
## 2 식사하는 철학자 문제와 교착 상태 필요조건
- 상호 배제 : 포크는 한 사람이 이용하면 다른 사람이 이용할 수 없는 배타적 자원.
- 비선점 : 자원을 빼앗을 수 있다면 교착 상태 발생 X, 포크를 못빼앗는 경우 발생.
  + 상호 배제와 비선점은 cs와 관련 -> lock을 사용하면 위 두 조건이 보장됨.
- 점유와 대기 : 한 철학자가 왼쪽, 오른쪽 포크를 모두 점유하거나, 반대로 두 자원 모두 기다리면 교착 상태 발생 X
- 원형 대기 : 점유와 대기가 원을 이뤄야함 -> 그래야 다른 프로세스를 방해하고 그것이 모든 프로세스에 적용이 됨.
- 위에서도 얘기했듯 아사와 교착은 다름.
  + 아사 현상: 최단 작업 우선 스케줄링 알고리즘에서 작업 시간이 긴 프로세스가 작업 시간이 짧은 프로세스 때문에 작업이 진행되지 못하는 경우 발생.
    - 이는 몇 번 이상 양보하면 더 이상 양보하지 않도록 조정하는 에이징으로 해결 가능.
  + 교착 상태 : 정책상 잘못이나 오류가 없어도 자연적으로 발생 -> 에이징으로 해결 불가하고 정책을 바꿔도 해결 불가.
    - 아사 현상보다 처리하기가 복잡.
  
# 03 교착 상태 해결방법
## 1 교착 상태 해결방법
- 교착 상태 예방 (prevention) : 교착 상태를 유발하는 4가지 조건이 발생하지 않도록 무력화하는 방식, 그러나 실효성이 적어 잘 사용되지 않음.
- 교착 상태 회피 (avoidance) : 자원 할당량을 조절하여 교착 상태를 해결하는 방식( 자원을 할당하다가 교착 상태를 유발할 가능성이 있다고 판단되면 자원 할당을 중단하고 지켜봄), 얼마만큼의 자원을 할당해야 교착 상태가 발생하지 않는다는 보장이 없어 실효성이 적음.
- 교착 상태 검출과 회복 (detection and recovery) : 어떤 제약을 가하지 않고 자원 할당 그래프를 모니터링하면서 교착 상태가 발생하는지 살펴보는 방식, 교착 상태를 해결하는 현실적인 접근 방식.
  + 교착 상태가 만약 발생하면 교착 상태 회복 단계가 진행 -> 교착 상태 검출 후 회복
## 2 교착 상태 예방
### 2.1 상호 배제 예방
- 상호 배타적인 즉 독점적으로 사용할 수 있는 자원을 없애버리는 방법. -> 현실적으로 상호 배제를 없애는 것은 두 사람에게 하나의 포크를 같이 사용하라는 것과 같음.
  + 시스템 내에는 공유불가한 자원이 존재. -> 사실상 어려움.
### 2.2 비선점 예방
- 모든 자원을 빼앗을 수 있도록 만드는 방법. -> cs를 보호하기 위해 잠금을 사용하면 불가능
  + 만약 빼앗을 수 있더라도 어떤 자원을 뺏을 지 어떤 기준으로 뺏을지, 얼마나 사용할지 결정하기 어려움.
  + 게다가 아사 현상을 유발. -> 우선순위가 낮은 프로세스가 몇번 양보 해서 무조건 자원을 사용한다고 가정하면 프로세스가 점유하고 있는 자원은 비선점 자원이 됨.
### 2.3 점유와 대기 예방
- 프로세스가 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 하는 방법.
- 즉, 전부 할당하거나 아예 할당하지 않는 방식 -> 왼쪽 포크를 잡은 상태에서 오른쪽 포크를 잡지 못하도록 막는 것, 시작할 때 둘다 잡거나 그렇게 못하면 이미 잡은 포크는 내려놓아야함.
- 동작이 빠른 철학자가 먼저 식사를 할 것
- 이 방법은 자원이 아닌 프로세스의 자원 사용 방식을 변화시켜 교착 상태를 처리한다는 점에서 의미
- 점유와 대기 예방의 단점
  + 프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어려움.
    - 필요한 자원을 모두 확보 후 실행했는데 추가로 필요한 자원이 생기면 확보하기가 어려움.
  + 자원의 활용성이 떨어짐.
    - 앞으로 사용할 자원까지 미리 선점하기에 그 자원을 필요로 하는 다른 프로세스의 작업이 진행되지 않음, 자원 낭비가 심함.
  + 많은 자원을 사용하는 프로세스가 적은 자원을 사용하는 프로세스보다 불리.
  + 결국 일괄 작업 방식으로 동작.
    - 자원을 확보한 순서대로 실행하면 그 자원을 획득한 프로세스가 작업을 끝내야 다른 프로세스가 작업 가능.
### 2.4 원형 대기 예방
- 점유와 대기를 하는 프로세스들이 원형을 이루지 못하게 막는 방법.
  + 모든 작업에 숫자를 부여하고 숫자가 더 큰 숫자를 잡는 것은 허용하지만 숫자가 큰 자원을 잡은 상태에 작은 숫자를 잡는 것은 허용 X
- 점유와 대기를 완화한 방식이고 아래는 단점
  + 프로세스 작업 진행에 유연성이 떨어짐.
  + 자원의 번호를 어떻게 부여할 것인지가 문제.
  
## 3 교착 상태 회피
### 3.1 교착 상태 회피의 개념
- 프로세스의 자원을 할당 시 어느 수준 이상의 자원을 나누어주면 교착 상태가 발생하는지 파악하여 그 수준 이하로 자원을 나누어주는 방법.
  + 교착상태가 발생하지 않는 범위 내에서만 자원을 할당하고, 교착상태가 발생하는 범위에 있으면 프로세스를 대기 시킴.
  + 즉, 할당되는 자원의 수를 조절해서 교착 상태를 회피. -> 예방과는 달리 시스템의 운영방식에 변경을 가하지 않아 좀 더 유연.
- 자원을 많이 할당할수록 교착 상태가 발생할 확률 증가.
- 자원의 총수와 현재 할당된 자원의 수를 기준으로 시스템을 안정 상태 (safe state), 불안정 상태(unsafe state)로 나누고 안정 상태를 유지하도록 자원을 할당.
- 교착 상태는 불안정 상태의일부분이며, 불안정 상태가 커질수록 교착 상태가 발생할 가능성이 높아짐.
### 3.2 은행원 알고리즘
- 다익스트라가 제안, 은행이 대출을 해주는 방식.
- 대출 금액이 대출 가능한 범위 내이면 (안정 상태면) 허용되지만 그렇지 않으면 거부되는 것과 유사.
  + ex. 레스토랑에 10인분 우동, 20인분 스파게티의 재료가 있다고 가정.
  + 이 경우 30명을 기준으로 예약 받지 않고 10명 이내로 예약을 받음, 12명이 예약했는데 모두 우동을 주문하면 문제 발생.
  + 최악의 경우를 기준으로 문제 상황을 철저히 피하여 교착 상태를 막음.
- 각 프로세스는 자신이 사용할 자원의 최대 수를 OS에 알림, 할당된 자원의 수는 할당 자원에 표시.
- 최대 자원 - 현재 할당된 자원의 수 = 기대 자원, 전체 자원 - 모든 프로세스의 할당 자원 = 가용 자원.
- 자원 할당 시 다음 기준을 따름.
  + 각 프로세스의 기대 자원과 비교하여 가용 자원이 하나라도 크거나 같으면 자원을 할당.
    - 가용 자원 >= 모든 프로세스의 기대 자원 -> 그 자원을 사용하여 작업을 끝낼 수 있는 프로세스가 있다는 의미, 안정 상태.
  + 가용 자원이 어떤 기대 자원보다 크지 않으면 할당 X 
    - 가용 자원 < 모든 프로세스의 기대 자원 -> 가용 자원을 사용하여 작업을 마칠 수 있는 프로세스가 없다는 의미, 불안정 상태.
### 3.3 교착 상태 회피의 문제점
- 프로세스가 자신이 사용할 모든 자원을 미리 선언해야함.
  + 이는 쉬운 일이 아니고 선언한 자원이 정확하지 않으면 교착 상태 발생할 수 있음.
- 시스템의 전체 자원 수가 고정적이어야 함.
  + 일시적인 고장이나 새로운 자원이 추가되는 일이 빈번하므로 시스템의 자원 수가 유동적.
- 자원 낭비.
  + 레스토랑 예처럼 스파게티 재료가 충분한데 10명만 예약을 받는 것도 자원 낭비.
  + 실제로 교착 상태가 발생하지 않았는데도 발생할 것이라고 예상함으로써 프로세스에 자원을 할당하는데 제약을 둠.
  
## 4 교착 상태 검출
### 4.1 교착 상태 검출의 개념
- 가장 현실적인 교착 상태 해결 방법.
- OS가 프로세스의 작업을 관찰하면서 교착 상태 발생 여부를 주시하는 방법. -> 발견시 회복 단계
### 4.2 타임아웃을 이용한 교착 상태 검출
- 일정 시간 동안 작업이 진행되지 않은 프로세스를 교착 상태가 발생한 것으로 간주하여 처리.
- 교착 상태가 자주 발생하지 않을 것이라 가정하여 사용, 특별한 알고리즘없이 구현 가능
  + 엉뚱한 프로세스가 강제 종료될 수 있음.
    - 타임아웃 시간 동안 작업이 진행되지 않은 모든 프로세스가 교착 상태 때문이 아님.
    - 다른 이유의 프로세스가 강제 종료될 수 있음.
  + 모든 시스템에 적용할 수 없음.
    - 하나의 OS내에서 동작하는 프로세스는 가능하지만 분산 데이터베이스의 경우 적용이 어려움.
    - 여러 시스템에 데이터가 나뉘어 있고 네트워크로 연결되어 있어 교착 상태 때문인지, 네트워크 문제인지, 단순 처리가 늦는 건지 알 수 없음.
- 이런 문제에도 불구하고 타임아웃은 대부분의 데이터베이스와 OS에서 많이 선호
  + 다른 방법들은 작업이 너무 많아 구현이 힘듬.
  + 자주 발생하지 않는 교착 상태를 찾기 위해 자원 할당 그래프를 유지하며 모든 자원을 감시하는 것은 어려움
- 타임아웃 : 가벼운 교착 상태 검출, 자원 할당 그래프 : 무거운 교착 상태 검출.
- ex. '윈도우에서 프로그램이 응답이 없어 종료합니다' -> 타임아웃을 이용한 방법의 대표적 예.
- DB에서의 교착 상태 처리는 OS보다 복잡함. -> DB에서는 데이터의 일관성이 꺠지면 안됨.
  + so, 체크포인트, 롤백을 이용
  + 체크포인트 : 작업 중 문제 발생 시 저장된 상태로 돌아오기 위한 표시.
    - 스냅숏 : 저장된 데이터
  + 롤백 : 문제가 발생하여 체크포인트로 되돌아가는 것.
    - 롤백 발생 시 저장된 스냅숏을 복원하여 시스템을 체크포인트로 되돌림.
  + OS에서도 '특정 시점으로 복원'은 스냅숏과 롤백을 이용하여 복원.
### 4.3 자원 할당 그래프를 이용한 교착 상태 검출
- 자원 할당 그래프를 보면 시스템 내의 프로세스가 어떤 자원을 사용하고 있는지 혹은 기다리고 있는지를 알 수 있음.
- 교착 상태가 없는 자원 할당 그래프
  + 사이클이 존재하지 않음.
- 교착 상태가 있는 자원 할당 그래프
  + 사이클이 존재함.
- but, 다중 자원을 사용하는 경우, 사이클 존재 유무가 교착 상태로 이어지지 않음. -> 심화에서 다룰 예정.
- 장점 : 프로세스의 작업 방식을 제한하지 않으면서 교착 상태를 정확하게 파악할 수 있음.
- 단점 : 자원 할당 그래프 유지, 갱신, 사이클 검사하는 추가 작업으로 오버헤드 발생.
## 5 교착 상태 회복
- 교착 상태를 유발한 프로세스를 강제 종료.
- 교착 상태를 일으킨 모든 프로세스를 동시에 종료
  + 종료된 프로세스들이 동시에 실행되면서 다시 교착 상태 발생 가능성이 큼.
  + 실행 시에는 순차적으로 실행해야하고 어떤 프로세스를 먼저 실행시킬지의 기준이 필요.
- 교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료
  + 순서대로 종료하며 나머지 프로세스의 상태를 파악.
  + 우선순위가 낮은 프로세스를 먼저 종료.
  + 우선순위가 같은 경우 작업 시간이 짧은 프로세스를 먼저 종료.
  + 위의 두 조건이 같은 경우 자원을 많이 사용하는 프로세스를 먼저 종료.
- 프로세스 강제 종료뿐만 아니라 강제 종료된 프로세스가 실행되기 전에 시스템을 보구
- 명령어 실행 시 마다 체크포인트를 만들어 가장 최근의 검사 시점으로 돌아가는 식으로 함.
- 이 방법은 작업량이 상당하여 시스템에 부하를 주므로 체크포인트를 무분별하게 사용하지 말고 선택적으로 사용해야함.
# 4 다중 자원과 교착 상태 검출
## 1 다중 자원과 사이클
- 다중 자원의 경우 사이클이 있다고 모두 교착 상태가 아님.
- 다중 자원이 포함된 자원 할당 그래프에선 대기 그래프와 그래프 감소 방법을 이용
## 2 대기 그래프와 그래프 감소
- 대기 그래프( wait for graph ) : 자원 할당 그래프에서 프로세스와 프로세스 간 기다리는 관계만 나타낸 그래프
- 그래프 감소( graph reduction ) : 대기 그래프에서 작업이 끝날 가능성이 있는 프로세스의 화살표와 관련 프로세스의 화살표를 연속적으로 지워가는 작업.
  + 작업이 끝날 가능성이 있는 프로세스 : 기다리는 자원이 없는 프로세스.
- 그래프 감소를 완료한 후에도 사이클이 남아 있다면 교착 상태 발생한 것으로 판단. 




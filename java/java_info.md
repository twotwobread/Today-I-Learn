## 자바의 태동
- 원래 임베디드에 올릴려고 만들어짐 -> 확장성을 좋게 만들어서 프로세서가 달라져도 동작할 수 있게 하기 위해 만들어짐 ( 플랫폼 독립적인 언어가 필요 )
  + ABI ( application binary interface ) = 프로그램이 만들어진 cpu와 os에 따라서 호환이 되는지 안되는지에 대한 이유.
  + CPU마다 기계어가 다르고 os마다 실행파일 형식이 다르고 api가 달라서 프로그램의 플랫폼 호환성이 없다. ( 플랫폼 = 하드웨어 + os )
- but 현재는 임베디드에 쓰이지 않음. ( 내가 추정할땐 가상머신을 만들어 이 위에서 프로그램이 실행되기에 무겁고 느려서 해당 언어를 쓰지않는다고 추정 )
- 자바가 나옴으로써 동적인 웹을 만들 수 있었음. 자바가 인기가 많아진 이유가 웹브라우저에서 실행 가능해서 웹의 발전과 함께 확산되었음.
- 자바(draw.java)는 소스코드에서 컴파일러를 거치면 바이트 코드(draw.class)가 되고 이 바이트 코드가 실행될때 해당 클래스와 바인딩되어 실행됨.
  + 바이트코드는 가상의 cpu에 맞는 중립적인 코드이다.
  + JVM은 플랫폼 종속적이고 실행전 미리 설치해야함.
- 링크 과정 없이 컴파일러가 바로 바이트 코드 생성을 하고 이것은 JVM에서만 실행 가능하고 필요한 클래스들을 프로그램 실행 중에 동적으로 로딩

## 소스 파일과 클래스
- 하나의 소스 파일에 여러 클래스 코드 작성 가능. 단, public 클래스는 파일당 최대 하나 소스파일 이름과 같아야함.

## 배열에 대해서
- c는 무조건 배열이 사각형이지만 자바는 비정방형이 있다.
- 그래서 배열을 생성하는 구문이 필요하다.
```java
int intArray[][]; // 2차원 배열을 선언하는 부분
int[][] intArray = new int[2][5]; // 2차원 배열을 생성한다. ( 2행에 5열의 크기로 생성한다. , 즉 얘는 정방형!!)
//c랑 그럼 같은가? 완전같지는 않다 그이유는 행안의 인덱스들은 주소가 연속되지만 다른 행간의 주소는 연속될 수도 있고 아닐 수도 있기 때문이다.

int[][] intArray = new int[4][]; // 이렇게도 배열을 만들수있다. 배열의 시작주소를 가르치는 레퍼런스를 만들었다.
intArray[0] = new int[0]; // 비정방형으로 만들기 위해선 각 행을 가르치는 레퍼런스도 필요하기 때문에 생성을 해주는 부분이다.
intArray[1] = new int[1];
intArray[2] = new int[2];
intArray[3] = new int[3];
```
- 같은 타입의 데이터들을 순차적으로 저장하고 연속된 메모리 공간에 할당된다.
- 배열의 인덱스가 0부터 시작하는 이유는 성능때문이다.
  + 시작주소를 만들땐 (인덱스의 시작 주소) + 0 * (바이트수)를 이용을 하는데 만약 첫 인덱스를 1로 만든다면
  + (인덱스의 시작 주소) + (1-1) * (바이트수)를 이용하여 주소를 만들게 된다. 이 경우 모든 인덱스에 접근할때마다 '빼기'라는 연산을 추가로 수행해야한다.
  + 그렇게 되면 성능이 저하될 수 밖에 없기 때문에 0부터 인덱스를 시작한다.

## 클래스에 대해서
- 객체지향은 실세꼐 모델링에 중점을 둔 언어, 그 이유는 주로 계산을 위해 사용이 되어 순차적으로 진행이 되었다.
- 하지만 현재는 산업 전반에 활용이 된다. 그러다 보니 쓰이는 용도가 다양해지고 실세계에서 나타나는 현상들을 보다 쉽게 프로그래밍 하기위해 나온 것이 객체 중심의 프로그래밍 언어가 탄생했다.
- 객체 지향 프로그래밍의 장점은 소프트웨어 생산성 향상이 되고 상속, 다형성, 객체, 캐슐화 등의 개념들이 소프트웨어 재사용을 쉽게 하는 효과가 있다.
  + 소프트웨어의 '재사용'과 '부분 사용'을 용이하기 때문이다.
  + 캡슐화 : 데이터와 관련 함수를 하나로 결합, 데이터를 외부로부터 숨김(보소, 보안, 접근 제어)
    - 외부에서는 비공개 데이터에 직접 접근하거나 메소드의 구현 세부를 알 수 없다.
    - c언어에서 구조체는 내가 원하는 자료형을 하나로 묶어주기 위해 사용이 되었었다.
    - 객체지향은 관련 데이터뿐만 아니라 함수까지 하나로 결합.
  + 상속 : 상속 트리는 다양한 사물을 체계적으로 분류
    - 예) 나무는 식물, 생물 속성을 다 가지고 사람은 생물은 가지지만 식물은 가지지 않는다 
  + 다형성 :
- 클래스 : 객체를 만들기 위한 설계도, 객체의 속성(field)(데이터, 변수)과 행위(method) 선언
- 객체 : 클래스라는 설계도에 따라 만들어낸 실체, 객체를 클래스의 인스턴스라고도 함.
- 클래스는 붕어빵 틀, 객체는 붕어빵이다.
- 객체 생성은 new 키워드를 이용하여 생성한다. 생성될 때 객체의 생성자가 자동으로 호출. 아래와 같이 객체 생성.
```java
Person aPerson; // 1. 레퍼런스 변수 aPerson 선언
aPerson = new Person("김미남"); // 2.Person 객체 생성
```
- 레퍼런스 변수로 가리켜 두지 않은 객체는 접근할 수 없으므로 무용지물이다.
```java
Person[] p1 = new Person[10];// Person 타입 레퍼런스 10개를 만들어주는 부분.
for(int i = 0; i<10; i++){
  p1[i] = new Person(); // 실제로 Person 객체를 만드는 부분.
}
```

## 메소드에 대하여
- 메소드는 무조건 클래스안에 있어야한다. ( 캡슐화 법칙에 의함 )
- JAVA의 인자 전달 방식
  + 기본 타입 전달 : call by value
    - 변수 값이 복사되어 전달
    - 메소드의 매개 변수가 변경되어도 당연히 실인자 값은 변경 x
  + 객체/배열 전달: call by reference - 주소값을 복사해서 넘겨주는 방식.
    - 레퍼런스 변수 값이 복사되어 전달
    - 객체/배열이 통째로 복사되어 전달되는 것 아님!
    - 레퍼런스 변수를 통해 객체를 변경하면 당연히 실제 객체도 변경
- 메소드 오버로딩 ( 다형성의 예 )
  + 오버로딩 : 한 클래스 내에서 두 개 이상의 이름이 동일한 메소드 작성
    - 메소드 이름은 동일 하지만 매개 변수의 개수나 타입이 서로 달라 구분 가능해야 함.
    - 단, 리턴 타입만 다르면 에러가 난다.
  + 자바에서는 오퍼레이터 오버로딩이 없다.
- this란 ?
  + 현재 실행되는 메소드가 속한 객체에 대한 레퍼런스 하지만 컴파일러에 의해 자동 선언되어 별도로 선언할 필요가 없다.

## 접근지정자에 대하여
- 1단계) 클래스에 접근할 수 있는가?
  + 클래스의 유일한 용도는 객체 생성.
  + 따라서, '이 클래스에 new를 하여 객체를 생성할 수 있느가?'를 의미함.
- 2단계) 생성된 객체의 멤버에 접근할 수 있는가?
  + 멤버변수(필드)의 용도는 읽거나 쓰기.
  + 멤버함수(메소드)의 용도는 실행시키기.
  + 따라서, '이 객체의 필드에 읽거나 쓸 수 있는가 혹은 이 객체의 메소드를 실행시킬 수 있는가?'를 의미함.
- 클래스 접근 지정자
  + 클래스 앞에 올 수 있는 접근 지정자
    - 원칙 같은 패키지에 포함된 클래스만 접근 가능
      + 접근 지정자 생략 (디폴트 접근 지정자) -> ```java class Person {} ```
    - public 클래스는 다른 패키지에서도 접근 가능
      + 다른 모든 클래스가 접근 가능 -> ```java publi
  + non-static 멤버(변수, 메소드)의 특성
    - 공간적 특성 : 객체마다 별도 존재
    - 시간적 특성 : 객체 생성 후 비로소 접근 가능
  + static 멤버의 특성
    - (객체마다가 아니라) 클래스마다 하나만 생성됨
      + 객체를 생성하지 않고도 접근 가능
    - 특성
      + 공간적 특성: 클래스 당 하나만 생성
      + 시간적 특성: 클래스가 로딩될 때 이미 생성되어 접근 가능
    - static에서는 this 사용불가 애초에 객체가 만들어지지 않아서 사용할 수 없다.
    - static은 남발하는 것은 좋지 않다. static으로 선언하는 main안에서 자기자신 public class 객체를 만들고 그것을 이용해서 메소드를 이용해야 한다.
- final 클래스와 메소드
  + final 변수 : 더 이상 값이 변할 수 없는 변수
    - 상수 선언할 때 사용
      ``` java
      class SharedClass {
          public static final double PI = 3.141592; // 상수명은 대문자
      }
      ```
## 상속에 대하여
- 상위 클래스의 특성 ( 멤버 변수/메소드 )을 하위 클래스에 물려주는 것.
- 부모 클래스/수퍼 클래스(superclass)/기본(base) 클래스
  + 특성을 물려주는 상위 클래스
- 자식 클래스/ 서브 클래스(subclass)/파생(derived) 클래스
  + 특성을 물려받는 하위 클래스
- 자신은 부모 클래스의 특성을 수정할 수 있음 -> 오버라이딩
- 상속이 될수록 기능이 구체화된다. 부모의 기능은 반복 기술하지 않아도 계승된다.
- 상속 구조를 잘 설계하면 중복 코드가 크게 감소한다.
- 상속 선언
  ```java
  class Person {...}
  class Student extends Person {...} // Person을 상속받는 클래스 Student 선언
  class StudentWorker extends Student {...} // Student를 상속바든 StudentWorker 선언
  ```
- JAVA 상속의 특징
  + 상속의 최상위 클래스는 java.lang.* 패키지의 object 클래스
    - 모든 클래스는 자동으로 java.lang.Object 상속
  + 다중 상속 지원하지 않음
    - 여러 클래스를 동시에 상속받지 못함 (예: class A extends B, C(X))
- JAVA 상속 계층 구조
  ![자바의+클래스+계층+구조+자바에서는+모든+클래스는+반드시+java lang Object+클래스를+자동으로+상속받는다](https://user-images.githubusercontent.com/78334910/150274809-e3ef41a5-7294-4da2-bd32-fafe0f8450fd.jpg)
- 자바는 상속을 받았을때 오버라이드를 하면 visibility를 줄일 수 없음(public을 super 클래스에서 붙였으면 그대로 붙여야함.)
- super()를 이용하여 명시적 호출을 하지 않으면 default 생성자를 부르게 된다.
- 상속에서의 다형성에 관한 내용
  + 객체의 타입 변환
    - 업캐스팅(upcasting) : 자식 클래스의 객체를 부모 클래스 레퍼런스로 가리킴.
      + 객체의 모든 멤버를 접근할 수 없고 부모 클래스 멤버에만 접근 가능
      ```java
      class Person{}
      class Student extends Person {}
      Student s = new Student();
      Person p = s; // 업캐스팅, 자동타입변환
      ```
    - 다운캐스팅 : 부모 클래스 레퍼런스로 가리키던 자식 객체를, 원래대로 자식 클래스 레퍼런스가 가리키도록 하는 것
      + 명시적으로 타입지정, 다시 자식 객체의 모든 멤버 접근 가능
        ```java
        class Person {}
        class Student extends Person {}
        Person p = new Student();
        Student s = (Student) p; // 다운캐스팅, 강제 타입변환
        ```
    - 업캐스팅된 객체를 구별하기 위한 instanceof 연산자
      + 레퍼런스가 가리키는 객체의 진짜 타입 식별
      + 가능한 클래스 이름을 미리 알고 있어야 한다.
    - 클래스 이름 얻기 위한 Object->Class->getSimpleName()
      + 모든 객체는 Object 클래스 상속
      + Object.getClass() 메소드로 Object 객체의 멤버인 Class 객체에 접근
      + Object.getClass().getSimpleName() 메소드로 객체의 클래스 이름 알 수 있음.
      + Object.getClass().getName()은 패키지 이름과 함께 알려준다.
    - 메소드 오버라이딩 : 부모 클래스의 메소드를 자식 클래스에서 재정의
      - 객체 생성 -> 업캐스팅 -> 오버라이딩된 메소드 호출
        + 업캐스팅했으니 부모 클래스의 메소드가 호출될 것으로 예상
        + 놀랍게도 자식 클래스의 메소드가 실행됨.
- JAVA의 인터페이스
  + 극단적으로 '형식'만 남긴 클래스 : 껍데기만 남은 클래스
  + 멤버 변수 정의 불가 : 상수는 정의 가능
  + 모든 메소드가 추상 메소드
  + 클래스가 아니라 interface 키워드로 선언
  + 특징
    - 인터페이스의 메소드 : 반드시 public abstract 타입이라서 생략 가능
    - 인터페이스의 상수 : 반드시 public static final 타입이라 생략 가능
    - 객체 생성 불가
    - 레퍼런스 변수는 선언 가능
  + 인터페이스의 필요성
    - JAVA는 '다이아몬드 문제'를 피하기 위해 다중 상속 미지원
      + 그러나, 가끔 다중 상속이 필요한 경우 발생 -> 하나의 객체를 다양한 형태로 업캐스팅하고 싶다(다형성 활용)
    - '다이아몬드 문제'가 발생하지 않도록 알맹이 없는 클래스인 인터페이스를 정의하여 인터페이스는 다중 상속을 허용함.
  + implements 키워드 사용
  + 여러 개의 인터페이스 동시 구현 가능
  + 상속과 구현이 동시에 가능
## 패키지에 대하여
- 여러 사람이 분담하여 자바 응용프로그램을 개발하는 경우 동일한 이름의 클래스가 존재할 가능성있음 -> 합칠때 오류 발생
- 패키지란 서로 관련된 클래스와 인터페이스를 하나의 디렉터리로 묶어 놓은 것이다.
- 하나의 응용프로그램은 여러 개의 패키지로 작성 가능하고 하나의 패키지로 만들고 모든 클래스 파일을 넣어둘 수도 있다.
- 패키지는 jar 파일로 압출할 수 있다.
- JDK에서 제공되는 패키지는 java.awt라는 패키지명을 가진 곳에 여러 클래스가 존재하고 한예로 java.awt.Color이란 클래스가 있다.
- import는 java.util이라는 패키지에서 Scanner라는 클래스를 이용할 수 있는 것처럼 사용할 수 있다.
- 패키지의 특징
  + 계층 구조 : 클래스나 인터페이스가 너무 많아지면 관리가 어려워 관련된 클래스 파일을 하나의 패키지로 계층화하여 관리한다.
  + 패키지별 접근 제한 : default로 선언된 클래스나 멤버는 동일 패키지 내의 클래스들이 자유롭게 접근하도록 허용한다.( 같은 패키지면 import 없이 사용할 수 있음. )
  + 동일한 이름의 클래스와 인터페이스의 사용 가능하다. 서로 다른 패키지에 이름이 같은 클래스와 인터페이스가 존재할 수 있다.
  + 소프트웨어 재사용 : 오라클에서 제공하는 자바 API는 패키지로 구성되어 있고 그 덕에 일일이 코딩없이 입출력 프로그램 등을 간단히 작성할 수 있다.
- 주요 패키지
  + java.lang : 자바 랭귀지 패키지이다. 스트링, 수학, 함수, 입출력 등 자바 프로그래밍에 필요한 기본적인 클래스와 인터페이스이다. 자동으로 import 된다.
    1) Object는 java.lang에 포함되고 자바 '클래스 계층 구조'의 최상위에 위치한다. 모든 클래스의 슈퍼 클래스이다.
  + java.util : 자바 유틸리트 패키지이다. 날짜, 시간, 벡터, 해시맵 등과 같은 다양한 유틸리티 클래스와 인터페이스를 제공한다.
  + java.io : 키보드, 모니터, 프린터, 디스크 등에 입출력을 할 수 있는 클래스와 인터페이스를 제공한다.
  + java.awt, javax.swing : 자바 GUI 프로그래밍을 위한 클래스와 인터페이스를 제공한다.
    

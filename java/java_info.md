## 자바의 태동
- 원래 임베디드에 올릴려고 만들어짐 -> 확장성을 좋게 만들어서 프로세서가 달라져도 동작할 수 있게 하기 위해 만들어짐 ( 플랫폼 독립적인 언어가 필요 )
  + ABI ( application binary interface ) = 프로그램이 만들어진 cpu와 os에 따라서 호환이 되는지 안되는지에 대한 이유.
  + CPU마다 기계어가 다르고 os마다 실행파일 형식이 다르고 api가 달라서 프로그램의 플랫폼 호환성이 없다. ( 플랫폼 = 하드웨어 + os )
- but 현재는 임베디드에 쓰이지 않음. ( 내가 추정할땐 가상머신을 만들어 이 위에서 프로그램이 실행되기에 무겁고 느려서 해당 언어를 쓰지않는다고 추정 )
- 자바가 나옴으로써 동적인 웹을 만들 수 있었음. 자바가 인기가 많아진 이유가 웹브라우저에서 실행 가능해서 웹의 발전과 함께 확산되었음.
- 자바(draw.java)는 소스코드에서 컴파일러를 거치면 바이트 코드(draw.class)가 되고 이 바이트 코드가 실행될때 해당 클래스와 바인딩되어 실행됨.
  + 바이트코드는 가상의 cpu에 맞는 중립적인 코드이다.
  + JVM은 플랫폼 종속적이고 실행전 미리 설치해야함.
- 링크 과정 없이 컴파일러가 바로 바이트 코드 생성을 하고 이것은 JVM에서만 실행 가능하고 필요한 클래스들을 프로그램 실행 중에 동적으로 로딩

## 소스 파일과 클래스
- 하나의 소스 파일에 여러 클래스 코드 작성 가능. 단, public 클래스는 파일당 최대 하나 소스파일 이름과 같아야함.

## 배열에 대해서
- c는 무조건 배열이 사각형이지만 자바는 비정방형이 있다.
- 그래서 배열을 생성하는 구문이 필요하다.
```java
int intArray[][]; // 2차원 배열을 선언하는 부분
int[][] intArray = new int[2][5]; // 2차원 배열을 생성한다. ( 2행에 5열의 크기로 생성한다. , 즉 얘는 정방형!!)
//c랑 그럼 같은가? 완전같지는 않다 그이유는 행안의 인덱스들은 주소가 연속되지만 다른 행간의 주소는 연속될 수도 있고 아닐 수도 있기 때문이다.

int[][] intArray = new int[4][]; // 이렇게도 배열을 만들수있다. 배열의 시작주소를 가르치는 레퍼런스를 만들었다.
intArray[0] = new int[0]; // 비정방형으로 만들기 위해선 각 행을 가르치는 레퍼런스도 필요하기 때문에 생성을 해주는 부분이다.
intArray[1] = new int[1];
intArray[2] = new int[2];
intArray[3] = new int[3];
```
- 같은 타입의 데이터들을 순차적으로 저장하고 연속된 메모리 공간에 할당된다.
- 배열의 인덱스가 0부터 시작하는 이유는 성능때문이다.
  + 시작주소를 만들땐 (인덱스의 시작 주소) + 0 * (바이트수)를 이용을 하는데 만약 첫 인덱스를 1로 만든다면
  + (인덱스의 시작 주소) + (1-1) * (바이트수)를 이용하여 주소를 만들게 된다. 이 경우 모든 인덱스에 접근할때마다 '빼기'라는 연산을 추가로 수행해야한다.
  + 그렇게 되면 성능이 저하될 수 밖에 없기 때문에 0부터 인덱스를 시작한다.

## 클래스에 대해서
- 객체지향은 실세꼐 모델링에 중점을 둔 언어, 그 이유는 주로 계산을 위해 사용이 되어 순차적으로 진행이 되었다.
- 하지만 현재는 산업 전반에 활용이 된다. 그러다 보니 쓰이는 용도가 다양해지고 실세계에서 나타나는 현상들을 보다 쉽게 프로그래밍 하기위해 나온 것이 객체 중심의 프로그래밍 언어가 탄생했다.
- 객체 지향 프로그래밍의 장점은 소프트웨어 생산성 향상이 되고 상속, 다형성, 객체, 캐슐화 등의 개념들이 소프트웨어 재사용을 쉽게 하는 효과가 있다.
  + 소프트웨어의 '재사용'과 '부분 사용'을 용이하기 때문이다.
  + 캡슐화 : 데이터와 관련 함수를 하나로 결합, 데이터를 외부로부터 숨김(보소, 보안, 접근 제어)
    - 외부에서는 비공개 데이터에 직접 접근하거나 메소드의 구현 세부를 알 수 없다.
    - c언어에서 구조체는 내가 원하는 자료형을 하나로 묶어주기 위해 사용이 되었었다.
    - 객체지향은 관련 데이터뿐만 아니라 함수까지 하나로 결합.
  + 상속 : 상속 트리는 다양한 사물을 체계적으로 분류
    - 예) 나무는 식물, 생물 속성을 다 가지고 사람은 생물은 가지지만 식물은 가지지 않는다 
  + 다형성 :
- 클래스 : 객체를 만들기 위한 설계도, 객체의 속성(field)(데이터, 변수)과 행위(method) 선언
- 객체 : 클래스라는 설계도에 따라 만들어낸 실체, 객체를 클래스의 인스턴스라고도 함.
- 클래스는 붕어빵 틀, 객체는 붕어빵이다.
- 객체 생성은 new 키워드를 이용하여 생성한다. 생성될 때 객체의 생성자가 자동으로 호출. 아래와 같이 객체 생성.
```java
Person aPerson; // 1. 레퍼런스 변수 aPerson 선언
aPerson = new Person("김미남"); // 2.Person 객체 생성
```
- 레퍼런스 변수로 가리켜 두지 않은 객체는 접근할 수 없으므로 무용지물이다.
```java
Person[] p1 = new Person[10];// Person 타입 레퍼런스 10개를 만들어주는 부분.
for(int i = 0; i<10; i++){
  p1[i] = new Person(); // 실제로 Person 객체를 만드는 부분.
}
```

## 메소드에 대하여
- 메소드는 무조건 클래스안에 있어야한다. ( 캡슐화 법칙에 의함 )
- JAVA의 인자 전달 방식
  + 기본 타입 전달 : call by value
    - 변수 값이 복사되어 전달
    - 메소드의 매개 변수가 변경되어도 당연히 실인자 값은 변경 x
  + 객체/배열 전달: call by reference - 주소값을 복사해서 넘겨주는 방식.
    - 레퍼런스 변수 값이 복사되어 전달
    - 객체/배열이 통째로 복사되어 전달되는 것 아님!
    - 레퍼런스 변수를 통해 객체를 변경하면 당연히 실제 객체도 변경
- 메소드 오버로딩 ( 다형성의 예 )
  + 오버로딩 : 한 클래스 내에서 두 개 이상의 이름이 동일한 메소드 작성
    - 메소드 이름은 동일 하지만 매개 변수의 개수나 타입이 서로 달라 구분 가능해야 함.
    - 단, 리턴 타입만 다르면 에러가 난다.
  + 자바에서는 오퍼레이터 오버로딩이 없다.
- this란 ?
  + 현재 실행되는 메소드가 속한 객체에 대한 레퍼런스 하지만 컴파일러에 의해 자동 선언되어 별도로 선언할 필요가 없다.

## 접근지정자에 대하여
- 1단계) 클래스에 접근할 수 있는가?
  + 클래스의 유일한 용도는 객체 생성.
  + 따라서, '이 클래스에 new를 하여 객체를 생성할 수 있느가?'를 의미함.
- 2단계) 생성된 객체의 멤버에 접근할 수 있는가?
  + 멤버변수(필드)의 용도는 읽거나 쓰기.
  + 멤버함수(메소드)의 용도는 실행시키기.
  + 따라서, '이 객체의 필드에 읽거나 쓸 수 있는가 혹은 이 객체의 메소드를 실행시킬 수 있는가?'를 의미함.
- 클래스 접근 지정자
  + 클래스 앞에 올 수 있는 접근 지정자
    - 원칙 같은 패키지에 포함된 클래스만 접근 가능
      + 접근 지정자 생략 (디폴트 접근 지정자) -> ```java class Person {} ```
    - public 클래스는 다른 패키지에서도 접근 가능
      + 다른 모든 클래스가 접근 가능 -> ```java publi
  + non-static 멤버(변수, 메소드)의 특성
    - 공간적 특성 : 객체마다 별도 존재
    - 시간적 특성 : 객체 생성 후 비로소 접근 가능
  + static 멤버의 특성
    - (객체마다가 아니라) 클래스마다 하나만 생성됨
      + 객체를 생성하지 않고도 접근 가능
    - 특성
      + 공간적 특성: 클래스 당 하나만 생성
      + 시간적 특성: 클래스가 로딩될 때 이미 생성되어 접근 가능
    - static에서는 this 사용불가 애초에 객체가 만들어지지 않아서 사용할 수 없다.
    - static은 남발하는 것은 좋지 않다. static으로 선언하는 main안에서 자기자신 public class 객체를 만들고 그것을 이용해서 메소드를 이용해야 한다.
- final 클래스와 메소드
  + final 변수 : 더 이상 값이 변할 수 없는 변수
    - 상수 선언할 때 사용
      ``` java
      class SharedClass {
          public static final double PI = 3.141592; // 상수명은 대문자
      }
      ```
